## 通用测试用例八要素

![img](https://img-blog.csdnimg.cn/img_convert/fde5e8955b1c0d7366ea094708cd1fc6.png)　　<img src="https://img-blog.csdnimg.cn/da3dfbaa6b9441589dd178540d3552ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASVTlpbPlrak=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 80%;" />

**1、用例编号；**

> 一般是数字和字符组合成的字符串，可以包括（下划线、单词缩写、数字等等），但是需要注意的是，尽量不要写汉语拼音，因为拼音的意义可能有好几种，有可能会导致乱码； 
>
> 用例编号具有唯一性和易识别性。（ 比如说我们唯一标识一个人：中国-上海市-xx区xx号-xx楼--xx室-xxx.这样标识的话就具有唯一性了。)

　　不同阶段的测试用例的用例编号有不同的规则：
　　（1）系统测试用例：产品编号-ST-系统测试项名-系统测试子项名-XXX
　　（2）集成测试用例：产品编号-IT-系统测试项名-系统测试子项名-XXX
　　（3）单元测试用例：产品编号-UT-系统测试项名-系统测试子项名-XXX
　　**其中产品编号也叫项目标识，每个公司都有若干不同的项目或者产品，如何来区分它们呢？这就需要有产品编号了，每个公司都有自己的一套定义产品编号的规则，并且每个现有产品的编号已经制定好了，直接拿过来用就可以了。
　　**产品编号后的ST、IT、UT分别对应系统测试阶段、集成测试阶段、单元测试阶段。实际工作中有些公司会将产品编号以及测试阶段省略。
　　**测试阶段后面就是测试项目名了，对应的是较大较系统的测试点。
　　**测试项目名后面就是测试子项目名，有些测试是没有子项目名的，只有当测试项力度比较大的时候才会有成都市子项 （比如说：我们要测试用户能否成功登录这个功能，那我们就可以分为很多个子项，qq登录、邮箱登录等等）。
　	测试子项名后面就是具体的用例编号了，可以是数字：01、001、002等等。



　　**2、测试项目；**

（1）系统测试用例：对应一个功能点（功能测试）、性能指标（性能测试）、界面中控件（GUI测试）等等。
（2）集成测试用例：对应集成后的模块功能或者接口功能。
（3）单元测试用例：对应函数名。 



　　**3、测试标题；**

　　**4、重要级别；**

用例的重要级别一般分成三个级别：高、中、低。
高级别：对应保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例；
中级别：对应重要程度介于高和低之间的测试用例；
低级别：对应实际使用频率不高，对系统业务功能影响比较大的模块或功能的测试用例。



　　**5、预置条件；**

> 　 测试用例在执行前需要满足一些前提条件，否则测试用例是无法执行的，这些前提条件就是预置条件。

　　预置条件分为两种情况：
　　（1）环境的设置。
　　例如：测试word打开文件的功能，预置条件就是：需要提前准备被打开的文件；
　　例如：登录成功的预置条件就是：该用户名已经注册过了。
　　例如：购买商品成功的预置条件就是：后台已经配置好商品、发货区域、以及支付方式了。
　　（2）先要运行的其他用例，有些操作系统会比较复杂，如果都是从最开始的操作开始会导致用例写起来比较麻烦，这样可以在预置条件中设定要先运行的测试用例，后面的用例只需要写后续的操作就可以了。
　　例如：对自动取款机进行测试，有针对的输入账户信息的测试，有对输入取钱金额的测试，后者的预置条件就可以写成输入正确账户信息的测试用例。
　　注：具体预置条件的设置不同的公司会有自己的规定，比如有的公司是不允许第二种情况出现的。



　　**6、测试输入；**

测试输入是用于运行测试用例的具体数据或值。这些输入数据用于模拟不同的用户操作和场景。

- **示例**：

  - 用户名和密码用于登录测试。
  - 搜索关键词用于搜索功能测试。

- **重要性**：

  - 它们是产生预期结果的“触发器”。

  - 用于验证应用程序如何处理不同类型和范围的数据。

    

　　**7、操作步骤；**

明确描述测试执行过程中具体的操作步骤，以方便测试执行人员可以根据该操作步骤完成测试用例执行。

- **示例**：

  1. 打开应用程序。
  2. 在用户名字段中输入预定义的用户名。
  3. 在密码字段中输入预定义的密码。
  4. 点击“登录”按钮。

- **重要性**：

  - 提供了一种结构化的方式来执行测试，确保测试的一致性和可重复性。

  - 有助于准确地复现缺陷和问题。

    

　　**8、预期输出；**

> （1）界面显示：在操作步骤完成之后，界面会有显示；比如说我们测试用户登录功能，界面可能会显示登录成功或者登录失败。
>
> （2）数据库的变化：在操作步骤完成之后，数据库中的记录会发生相应的变化，比如删除功能的测试，点击删除后，数据库中该记录会被删除。
>
> （3）相关信息的变化：在操作步骤执行完成后，一些和被测对象相关的信息会发生变化，比如：注销功能的测试，点击注销后，以前能访问的页面将无法再访问。 



## 测试要点

![img](https://img-blog.csdn.net/20180505154820871)

## 软件测试类别

![img](https://img-blog.csdnimg.cn/20210919103511372.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57qi55uu6aaZ6Jaw,size_20,color_FFFFFF,t_70,g_se,x_16)





### 白盒测试（White-box Testing）

白盒测试又叫结构测试或透明盒测试，主要针对软件内部结构、工作流程和功能进行测试。测试者需要了解被测试软件的内部结构和工作原理。白盒测试主要包括以下几种：

1. **单元测试（Unit Testing）**: 测试单个程序、子程序、模块或对象。
2. **路径测试（Path Testing）**: 验证所有代码路径都被正确执行。
3. **数据流测试（Data Flow Testing）**: 测试程序变量的初始化和修改。
4. **循环测试（Loop Testing）**: 针对软件中的所有循环结构进行测试。
5. **条件测试（Condition Testing）**: 验证决策语句（if、switch等）。
6. **代码覆盖测试（Code Coverage）**: 确保代码中的每一行、每一个分支都被执行过。
7. **静态分析（Static Analysis）**: 不执行代码，通过代码检查或使用静态分析工具进行测试。
8. **集成测试（Integration Testing）**: 在这个上下文中，集成测试通常针对模块间的接口进行。

### 黑盒测试（Black-box Testing）

黑盒测试又称为功能测试，它是在不了解内部结构和工作原理的情况下，对软件外部行为进行测试。主要包括以下几种：

1. **功能测试（Functional Testing）**: 测试软件所有功能是否按照需求规格书工作。

2. **边界值测试（Boundary Testing）**: 测试输入或输出数据边界条件。

3. **等价类划分（Equivalence Partitioning）**: 将输入数据分为几个等价类别，然后用这几个类别进行测试。

   等价类划分是一种测试设计技术，其中输入域被分为几个等价类。一个等价类中的所有值都应该具有相同的特性，并被预期产生相同的结果。通常从每个等价类中选取一个或几个代表性的值进行测试。

   例子：

   假设有一个函数，该函数接受年龄（1-100）作为输入并返回是否成年（>= 18）。这里有两个等价类：

   1. 1-17（未成年）
   2. 18-100（成年）

   选择每个等价类中的一个或两个值进行测试即可。

   优缺点：

   - **优点**：减少了测试用例的数量，同时保持了高覆盖率。
   - **缺点**：可能会错过一些边界条件。

4. **因果图**

5. **错误推测法：**

   错误推测法是一种经验性的测试方法，它依赖于测试人员或开发人员对系统可能出现错误的直觉和经验。

   例子：

   在一个电子商务应用中，对于信用卡号的验证，除了正常的输入检查外，测试人员可能会尝试一些常见的错误情况，如使用过期的卡、无效的卡号等。

   优缺点：

   - **优点**：能够找出那些正规测试方法可能忽视的问题。

   - **缺点**：完全依赖于个人经验和直觉，不系统化。

     

6. **决策表测试（Decision Table Testing）**: 用表格的方式来表示复杂业务规则，并据此进行测试。

   决策表测试是一种表格形式的测试设计技术，用于处理多个相关的输入和输出条件。这种方法特别适用于复杂的业务逻辑和决策过程。

   例子：

   在一个贷款批准流程中，输入可能包括“年收入”，“信用评分”，“拥有财产”等，输出则是“批准”或“拒绝”。通过决策表，可以列出所有可能的输入组合和相应的输出。

   优缺点：

   - **优点**：结构清晰，易于理解和维护。
   - **缺点**：对于具有大量输入/输出和决策路径的系统，决策表可能变得很复杂。

7. **状态转换测试（State Transition Testing）**: 测试从一个状态转换到另一个状态是否成功。

8. **压力测试（Stress Testing）**: 测试软件在极端条件（如资源不足、高并发）下的表现。

9. **性能测试（Performance Testing）**: 测量软件某些特定操作的响应时间或吞吐量。

10. **兼容性测试（Compatibility Testing）**: 测试软件在不同环境（如不同的浏览器、操作系统、硬件等）中的运行情况。

11. **接受测试（Acceptance Testing）**: 最终用户或客户进行的测试，以确定软件是否能被接受



  黑盒测试主要的方法有：等价类划分法、边界值分析法、错误推测法、因果图法、决策表法、场景法等。 

  白盒测试的主要方法有：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖等。 

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135003126.png" alt="image-20231020135003126" style="zoom: 50%;" />

负载测试：是通过逐步增加系统负载，测试系统性能的变化，并在**满足最终确定性能指标的情况下**，系统所能承受的**最大负载量**的测试

压力测试：逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载下系统性能**处于失效状态**，并以此来获得系统能提供的**最大服务级别的测试**

#### 负载测试（Load Testing）

1. **目的**: 负载测试的主要目的是确定系统在正常和预期的负载下的性能。
2. **范围**: 负载测试通常会模拟多个用户同时访问或使用应用，但这些负载都是预先设定并且在系统承受能力之内的。
3. **指标**: 主要关注的性能指标包括响应时间、吞吐量、系统资源（CPU、内存、磁盘、网络等）的使用情况。
4. **测试场景**: 通常模拟真实世界的正常业务操作和用户行为。

#### 压力测试（Stress Testing）

1. **目的**: 压力测试的目标是找出系统的极限性能和确定系统在极端负载下的稳定性。
2. **范围**: 这种测试涉及将系统推向其极限，经常超过系统的预期或设计能力，以查看它会如何失败和恢复。
3. **指标**: 主要关注系统的故障点、可恢复性，以及在高负载或资源不足的情况下是否会导致系统崩溃或数据丢失。
4. **测试场景**: 通常涉及极端情况，如数据库突然不可用、网络突然断开或者非常大量的用户请求。

#### 稳定性测试（Stability Testing）

稳定性测试是一种软件测试类型，其主要目的是确保软件或系统在长时间运行或在复杂负载下依然保持稳定和可靠的性能。这通常涉及在多种不同的环境和条件下，对软件进行长时间或持续不断的测试。

**主要特点：**

1. **持续运行**: 测试可能需要持续数小时、数天或更长时间，以模拟实际运行环境。
2. **复杂负载**: 除了正常操作外，还可能包括各种边缘案例和复杂的用户交互。
3. **多种环境**: 可能需要在不同的操作系统、硬件和网络配置下进行测试。

**主要目标：**

- **性能维持**: 确保在长时间运行后，性能（如响应时间、吞吐量等）没有明显下降。
- **资源管理**: 观察系统资源（如CPU、内存、磁盘等）的使用情况，确保没有内存泄漏、资源泄漏或其他稳定性问题。
- **错误处理**: 验证系统能够有效地处理错误和异常情况，并能够在发生故障后安全地恢复。
- **数据完整性**: 在各种操作和故障情况下，数据应保持完整和一致。



### 接口测试

#### 接口文档分析

接口文档一般是由后端开发提供，可以是在线的swagger也可以是word。

![img](https://pic2.zhimg.com/80/v2-f7e9e8a489498c0c878cb83d9d885df9_1440w.webp)

####  **接口信息五要素**

**1）接口地址url：**

http-请求协议，api.lemonban.com-域名或ip，8765-端口号，/futureloan/member/register-资源路径

**2）请求方法：**

看开发定义的请求方法是什么，测试就对应用什么方法。restful风格中常见的请求方法为post、get、put、patch、delete等

**3）请求头：**

发送请求到服务器，包含的头部信息。常见的content-type。

**4）请求体：**

发送请求到服务器，具体传递的数据。例如要完成注册接口的调用，请求体包含手机号mobile_phone、密码pwd、用户名reg_name、验证码verification_code。

**5）响应内容：**

接口文档中描述的响应内容，与接口测试的实际结果做比较，可以判断当前接口是否通过。响应内容包含：响应码-http状态码、响应头、响应体。



#### 接口用例设计

接口用例设计跟功能测试思维相通，需要：

1）清楚项目业务

 2）运用用例设计8大方法：等价类、边界值、场景法、因果图、判定表、正交试验法、状态迁移法、错误推测法。

**1. 等价类划分（Equivalence Class Partitioning）**

**目的**：简化测试用例的数量，同时保持测试的有效性。

**步骤**：

1. 识别输入参数和它们的值范围。
2. 划分等价类：有效等价类和无效等价类。
3. 为每个等价类设计一个或几个测试用例。

**例子**：测试年龄输入字段，接受18-60岁。有效等价类：[18, 60]，无效等价类：小于18和大于60。

**2. 边界值分析（Boundary Value Analysis）**

**目的**：测试输入或输出边界条件。

**步骤**：

1. 确定输入或输出边界。
2. 设计测试用例，包括边界值。

**例子**：使用年龄18、19、59、60作为测试用例。

**3. 场景法（Scenario Testing）**

**目的**：模拟真实世界的情况。

**步骤**：

1. 理解用户如何使用系统。
2. 根据实际使用场景设计测试用例。

**4. 因果图（Cause-Effect Graphing）**

**目的**：识别输入和输出之间的依赖关系。

**步骤**：

1. 列出所有可能的输入条件（因）和输出结果（果）。
2. 绘制因果图。
3. 生成测试用例。

**5. 判定表（Decision Table）**

**目的**：处理复杂的业务规则。

**步骤**：

1. 确定输入和输出变量。
2. 构建判定表。
3. 根据判定表生成测试用例。

**6. 正交试验法（Orthogonal Array Testing）**

**目的**：在多变量系统中找出最优的测试组合。

**步骤**：

1. 确定要测试的变量和它们的可能值。
2. 使用正交数组来确定测试组合。

**7. 状态迁移法（State Transition Testing）**

**目的**：测试系统在不同状态间的行为。

**步骤**：

1. 确定系统的各种状态。
2. 确定从一个状态到另一个状态的转换。
3. 设计测试用例以覆盖所有可能的状态转换。

**8. 错误推测法（Error Guessing）**

**目的**：基于经验和直觉来设计测试用例。

**步骤**：

1. 根据之前的缺陷或常见的错误模式来推测可能的错误。

2. 设计针对这些错误的测试用例。

   

以下是接口用例模板参考：

![img](https://pic2.zhimg.com/80/v2-71755a986c543385af8e1aac3897d7d9_1440w.webp)



#### 发现bug、定位、提交并跟踪

怎么判断是否是bug呢？

1）接口测试中响应结果错误，返回了错误的code码、msg信息：

- 判断请求：请求地址、方式、请求头、请求正文是否正确，如果不正确则修改对应请求信息再做发送；如果正确，则说明是服务器端问题
- 进一步查看服务器日志、数据库信息，并整理信息提交bug

2）接口测试中响应结果，code码、msg正确，但返回的data数据不正确：

- 查看数据库数据正确完整性，并结合服务器日志，整理信息提交bug

3）接口测试中响应结果正确，但若是增删改业务操作：

- 需进一步确认到数据库层面，数据增删改的正确性

4）考虑安全性：一般接口对请求会做出一些限制,比如请求次数、请求频率限制；涉及敏感信息是否加密



## 常用自动化测试工具

https://zhuanlan.zhihu.com/p/603190738

https://blog.csdn.net/weixin_44015669/article/details/121082810

**Selenium**--WebUI自动化测试

**Postman**--接口测试

Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。

**Jmeter**--性能测试

最初是为了测试Web应用程序而开发的

1. **模拟高负载**：JMeter 可以模拟多个用户同时访问一个服务，以测试该服务在高负载下的性能和稳定性。
2. **性能分析**：JMeter 不仅可以测试服务在极限负载下的性能，还可以分析服务在不同负载级别下的整体性能。

**Jenkins**

**Appium** -- AppUI自动化测试



## 游戏测试

![img](https://pic2.zhimg.com/v2-c46b7e26ed62cd0f46f77cb2fab125b1_r.jpg)



**步骤1：理解游戏需求和功能** 首先，你需要深入了解游戏的需求和功能。这包括游戏的规则、游戏性、目标、角色、物品、关卡设计等等。与游戏开发团队密切合作，以确保你对游戏的功能有全面的了解。

**步骤2：确定测试类型** 游戏测试可以包括多种类型，如功能测试、性能测试、兼容性测试、用户界面测试等。根据游戏的性质和需求，确定测试类型。例如，如果游戏是一个多人在线游戏，那么网络性能可能是一个关键因素，需要进行性能测试。

**步骤3：制定测试策略** 制定一个测试策略，包括测试的范围、优先级和时间表。确定哪些部分需要优先测试，哪些可以稍后测试。

**步骤4：编写测试用例** 现在开始编写测试用例。每个测试用例应该包括以下要素：

- 测试名称：简洁描述测试的名称。
- 测试描述：详细描述测试的目标和步骤。
- 预期结果：描述测试成功的标准。
- 先决条件：描述运行测试所需的前提条件，例如特定的游戏状态或设置。

测试用例应该尽可能全面地覆盖游戏的各个方面。例如，如果你正在测试一个角色扮演游戏，可以编写测试用例来验证角色的动作、对话、装备、技能等各个方面。

**步骤5：执行测试用例** 按照编写的测试用例执行测试。确保按照预期结果来验证每个测试，记录任何发现的问题或错误。

**步骤6：记录和报告问题** 当你在测试过程中发现问题时，要详细记录问题的描述、复现步骤和问题的严重程度。然后，将问题报告给游戏开发团队，以便他们可以修复问题。

**步骤7：回归测试** 一旦问题得到修复，进行回归测试，确保修复不会引入新问题或导致其他功能失效。

**步骤8：重复测试周期** 游戏测试是一个迭代的过程，通常需要多次重复上述步骤，直到游戏达到满意的质量水平。

**步骤9：最终验收测试** 最终验收测试是确保游戏符合要求并准备发布的最后一步。在这个阶段，需要验证游戏是否满足了所有的功能和性能要求。





### **针对一个用户登录页面的网页，你可以编写那些测试用例？**

**功能测试**

1. **正常登录**：使用有效的用户名和密码进行登录。
2. **无效用户名和/或密码**：使用无效的用户名和密码，应显示错误消息。
3. **空白字段**：不填写用户名或密码或两者都不填写，应显示必填或错误消息。
4. **特殊字符支持**：检查是否可以在用户名和密码中使用特殊字符。
5. **大小写敏感性**：验证用户名和密码是否区分大小写。
6. **忘记密码**：测试忘记密码功能，是否能通过邮箱或手机等方式重置密码。
7. **会话超时**：验证长时间不活动后是否自动登出。

**安全性测试**

1. **SQL注入**：确保应用程序不受SQL注入攻击的影响。

   假设一个简单的登录表单，后端代码用于检索用户信息可能如下：

   ```
   SELECT * FROM users WHERE username = '$username' AND password = '$password';
   ```

   在这里，`$username` 和 `$password` 是用户输入的内容。如果应用程序没有正确地处理这些输入，攻击者可以输入特殊的字符串来操纵SQL查询，例如：

   ```
   Username: admin' --
   Password: (任意值)
   ```

   这将使SQL查询变为：

   ```
   SELECT * FROM users WHERE username = 'admin' --' AND password = '(任意值)';
   ```

   由于 `--` 是SQL中的注释标记，所以查询的其余部分将被注释掉，这意味着只要用户名为 `admin` 的用户存在，查询就会成功，不管密码是否正确。

2. **XSS攻击**：确保没有跨站脚本（XSS）漏洞。

3. **多次错误尝试**：在多次连续错误登录尝试后，应限制用户尝试登录或触发验证码。

4. **数据传输安全**：确保密码和其他敏感信息在网络上传输时是加密的。

5. **密码安全策略**：检查是否实施了强密码策略。

**性能测试**

1. **加载时间**：确保页面在不同网络环境下能快速加载。
2. **并发用户**：测试系统能否在多个用户同时登录的情况下保持稳定。

**用户体验测试**

1. **响应式设计**：确保登录页面在不同大小和类型的设备上都能正常工作。
2. **错误消息**：确保所有错误消息都是清晰和用户友好的。
3. **字段焦点**：在输入错误后，焦点是否会自动移到错误字段。
4. **键盘快捷键**：例如，是否可以使用Enter键提交表单。



### 测试用例设计并讲解：微信发送图片

**功能测试**

1. **基础发送测试**
   - **目的**：验证正常情况下能否成功发送图片。
   - **步骤**：选择一个聊天窗口，点击添加图片的图标，选择一张图片，点击发送。
   - **预期结果**：图片应成功发送并在聊天窗口中显示。
2. **多图发送测试**
   - **目的**：验证是否能同时发送多张图片。
   - **步骤**：在同一个聊天窗口中选择多张图片并发送。
   - **预期结果**：所有选定的图片都应成功发送。
3. **格式支持测试**
   - **目的**：验证支持的图片格式（如 JPEG, PNG, GIF 等）。
   - **步骤**：尝试发送不同格式的图片。
   - **预期结果**：支持的格式应能成功发送，不支持的格式应给出警告。

**性能测试**

1. **大文件发送测试**
   - **目的**：验证大文件（接近或达到微信允许的最大限制）是否能成功发送。
   - **步骤**：选择一张大文件大小的图片尝试发送。
   - **预期结果**：如果在微信允许的大小内，应能成功发送；否则，应有相应的错误提示。
2. **高并发测试**
   - **目的**：模拟多用户同时发送图片的场景。
   - **步骤**：使用测试工具模拟多个用户账号同时发送图片。
   - **预期结果**：图片应成功发送，不应有延迟或失败。

**异常测试**

1. **网络不稳定环境下发送图片**
   - **目的**：测试在网络信号差或不稳定的情况下能否成功发送图片。
   - **步骤**：在网络不稳定的环境下尝试发送图片。
   - **预期结果**：应有合适的处理机制，如重试、提示用户网络不稳定等。
2. **无网络环境下发送图片**
   - **目的**：测试在没有网络的情况下应用的表现。
   - **步骤**：关闭所有网络连接，尝试发送图片。
   - **预期结果**：应提示用户当前无网络，不能发送图片。

**安全性测试**

1. 非法文件测试

   - **目的**：验证应用是否能阻止发送包含恶意代码的图片文件。

   - **步骤**：尝试发送一个包含恶意代码的图片文件。

   - **预期结果**：应阻止发送并给出警告。

     

![image-20231020135518141](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135518141.png)

   工作说明书/需求规格说明书—SOW 制定测试的进度  

   概要设计说明书-HLD 设计测试的用例  

   详细设计说明书-LLD 程序员编码实现  

   单元测试用例-UTC  单元测试使用  



![image-20231020135751807](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135751807.png)

无效等价类是指对于软件规格说明而言，是没有意义的、不合理的输入数据集合。



![image-20231020140004148](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140004148.png)

 (1)所有的测试都应追溯到用户需求。

 (2)应当把“尽早地和不断地进行软件测试”作为座右铭。

 (3)pareto原则：测试发现的错误中80%很可能起源于20%的模块中。  

 (4)完全测试是不可能的，测试需要终止。  

 (5)应由独立的第三方来构造测试。 

 (6)充分注意测试中的群集现象。

 (7)尽量避免测试的随意性。  

 (8)兼顾合理的输入和不合理的输入数据。

 (9)程序修改后要回归测试。

 (10)应长期保留用例，直至系统废弃.



![image-20231020140346592](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140346592.png)





![image-20231020140748992](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140748992.png)

A. 并发用户数：这不是疲劳强度测试主要关注的问题。这更多地与性能测试和负载测试有关。

**B. 内存泄漏：这是疲劳强度测试最可能首先发现的问题。长时间的运行可能会暴露内存泄漏问题。**

C. 系统安全性：疲劳强度测试通常不聚焦**于系统的安全性问题。**

D. 功能错误：虽然长时间的运行可能会触发某些功能错误，但这并不是疲劳强度测试的主要关注点。



![image-20231020140837318](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140837318.png)

一般来说，集成测试计划不会在需求分析阶段末提交。集成测试是在多个单元或组件已经分别进行了单元测试之后，将它们集成到一个更大的系统或子系统中时进行的测试。因此，集成测试通常是在单元测试之后进行的，也就是在编码和单元测试阶段之后。集成测试计划通常会在详细设计阶段完成或编码阶段开始时准备。

在软件开发的生命周期中，需求分析阶段主要关注于明确客户和系统的需求，而不是关注软件的测试活动。测试活动通常在稍后的阶段更为明确和活跃，尤其是在设计和编码阶段完成之后。



![image-20231020141144427](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141144427.png)

 **单元测试工具集合:** 

  **Parasoft jtest** 

  第一个自动化Java单元**测试**工具. 

  **Parasoft C++Test** 

  是**单元测试**和静态分析工具，自动测试C和C＋＋类别、功能或组件. 

  **Parasoft .TEST** 

  **是单元测试和静态分析工具，自动测试写在Microsoft?.NET框架的类别** 

  **Parasoft Insure++** 

  是一个自动化的内存错误、内存泄漏的精确检测工具。 

  **Parasoft CodeWizard** 

  是高级C/C++源代码分析工具，采用三百种以上行业相关的编码准则，自动识别编译器未检测到的危险的编码构造。 

  **DevPartner Studio Professional** 

  是针对软件开发小组使用 Microsoft Visual C++，Microsoft Visual Basic，Java,ASP 或 HTML 设计的一套紧密配合的调试，测试和管理工具。 

  **Rational Purify** 

  是一个面向VC, VB或者Java开发的测试Visual C/C++ 和Java代码中与内存有关的错误，确保整个应用程序的质量和可靠性。 

  **Rational Quantify** 

  是一个面向VC、VB 或者Java开发的测试性能瓶颈检测工具 

  **Rational PureCoverage** 

  是一个面向VC、VB或者Java开发的测试覆盖程度检测工具 



![image-20231020141624928](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141624928.png)

α测试是指软件开发公司组织内部人员模拟各类用户对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。α测试的关键在于尽可能逼真地模拟实际运行环境和用户对软件产品的操作并尽最大努力涵盖所有可能的 用户操作方式。经过α测试调整的软件产品称为β版本。 

β测试是由软件的多个用户在实际使用环境下进行的测试，这些用户返回有关错误信息给开发者。测试时，开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。在β测试中，由用户记下遇到的所有问题，包括真实的以及主观认定的，定期向开发者报告。β测试主要衡量产品的FLURPS，着重于产品的支持性，包括文档，客户培训和支持产品生产能力。 只有当α测试达到一定的可靠程度时，才能开始β测试。它处在整个测试的最后阶段。同时，产品的所有手册文本也应该在此阶段完全定稿。



###  Alpha 测试：

1. **定义**：Alpha 测试通常是软件开发团队内部进行的第一轮用户界面测试。在这个阶段，开发者通常会自己进行测试或请公司内部的其他专门的测试人员进行。
2. **环境**：Alpha 测试通常在开发环境中进行，而不是在用户环境中。
3. **参与者**：主要是内部开发者和测试人员。
4. **目的**：
   - 确保所有显而易见的缺陷已经被解决
   - 验证软件的功能和性能
   - 确保软件满足用户需求和规格说明
5. **局限性**：因为测试是在开发环境下进行的，所以可能无法完全模拟用户实际操作的环境和条件。
6. **时机**：通常在软件开发周期的后期，但在产品推向市场之前。
7. **反馈渠道**：通常通过内部渠道（如开发者或内部测试人员）。

### Beta 测试：

1. **定义**：Beta 测试是第二轮的用户测试，通常由最终用户进行。
2. **环境**：Beta 测试通常在用户的实际环境下进行。
3. **参与者**：选定的终端用户、客户或者公开招募的测试人员。
4. **目的**：
   - 发现那些在 Alpha 测试中可能遗漏的缺陷
   - 收集用户关于界面可用性、功能和整体体验的反馈
   - 在实际应用环境下评估产品性能
5. **局限性**：由于测试通常是由用户进行的，所以可能不如 Alpha 测试系统。
6. **时机**：通常在 Alpha 测试后，但在最终版本发布之前。
7. **反馈渠道**：通常通过在线问卷、电子邮件或其他形式收集用户反馈。

两者的主要区别在于测试的执行者和测试环境。Alpha 测试主要是内部人员进行，目的更侧重于查找明显的缺陷和问题；而 Beta 测试则由实际用户进行，在真实环境下检验软件的可用性和稳定性。这两个测试阶段通常都是在软件发布之前进行的，以确保产品尽可能地无缺陷。



![image-20231020141747127](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141747127.png)

4个，case0，case1，case2和3，default

语句覆盖是指选择足够多的测试数据，使被测程序中的每条语句至少执行一次。0，1，2，3一共四条语句即可，因为在执行2，3时无break，所以default语句也将被执行。 



![image-20231020141920907](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141920907.png)

 v模型

用户需求————————————————>验收测试

​       需求测试————————————>系统测试

​              概要设计————————>集成测试

​                     详细设计————>单元测试

​                                       编码

在项目的早期阶段就开始设计系统测试用例，因为这样更容易发现问题，并且给予更多的时间来解决这些问题。所以，如果要选择最佳的时间开始设计测试用例，**需求完成（选项A）**通常被认为是最适当的，尤其是在敏捷或迭代的开发环境中。然而，在更传统的瀑布模型中，可能会选择在**详细设计完成（选项B）**后开始。



![image-20231020142218237](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142218237.png)



![image-20231020142517483](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142517483.png)

比较判断与控制流常常紧密相关，测试时注意下列错误：  1. 不同数据类型的对象之间进行比较;  2. 错误地使用逻辑运算符或优先级;  3. 因计算机表示的局限性，期望理论上相等而实际上不相等的两个量相等;  4. 比较运算或变量出错;  5. 循环终止条件或不可能出现;  6. 迭代发散时不能退出;  7. 错误地修改了循环变量。 

![image-20231020142819415](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142819415.png)

A. **`@Test`注解标注的测试方法只能是 `public void` 的，且不能有任何输入参数**

- 这是正确的。使用 `@Test` 注解标注的测试方法必须是 `public void` 类型，并且不能有输入参数。

B. **`AssertEquals`、`AssertNotEquals`：判断两个对象是否为同一个**

- 这是不正确的。`assertEquals` 用于检查两个对象是否相等（即调用 `.equals()` 方法的结果），而不是检查是否为同一个对象（即通过 `==` 操作符检查）。`assertNotEquals` 则用于检查两个对象是否不相等。

C. **`@BeforeClass`注解每一个测试方法都要执行一次，且必须为 `static void`**

- 这是不正确的。`@BeforeClass` 注解标注的方法在该测试类的所有测试方法执行前只执行一次，而不是每一个测试方法执行前都执行。此外，这个方法必须是 `static void`。



  Junit单元测试框架—基于java语言对的主流单元测试框架 

  @**beforeClass**—位于数据准备前期或者其他前期准备（测试类调用前） 

  --用于提取代码中的共用部分减少冗余，只能声明注解一次 

  --必须在public static void,方法名随意，，只运行一次。 

  @**AfterClass**—位于所有用例运行之后，处理测试后续工作。 

​        --测试类被调用运行结束之前，只能声明注解一次。 

​        --必须在public static void,方法名随意，，只运行一次。 

  @**Test**—在Junit3中通过对测试类和测试方法的命名来确定是否为测试 

​     --在Junit4中，只要在方法前加@Test就行，此注解必为单元测试。 

​     --在一个测试类可多次注解，每个只被执行一次，必须是public void 

​     --可以抛异常 

  使用Assert断言 

  1、断言相等：**assertEquals**(100,x)，判断对象是否为同一个 

  断言不相等：**assertNotEquals**(100,x)，判断对象是否不为同一个 

  2、断言数组内容相等：assertArrayEquals({1,2,3},x) 

  3、断言浮点数相等：assertEquals(3.1416, x, 0.0001)（必须设置误差值） 

  4、断言为null：assertNull(x) 

  5、断言真伪性：assertTrue(x > 0)/assertFalse(x < 0) 

  6、 校准测试函数，使用操作符'=='比较实际和预期的是否重复



![image-20231020143228307](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143228307.png)

因果图法着重测试规格说明中的输入与输出间的依赖关系。

  等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。 

 如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。



![image-20231020143505803](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143505803.png)

【软件需求】是软件开发之前做好的，软件开发是根据这个做的，那么软件测试自然也需要参考该文件 【迭代计划】是软件的某个周期的计划，自然也需要参考 【可行性】是软件开发前做好，用于证明该计划可行的，没有必要参考 



![image-20231020143918748](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143918748.png)

性能测试、压力测试、负载测试的关系

- 性能测试是正常情况下的性能指标； (选择时间)
- 压力测试是测试系统的瓶颈所在； 
- 负载测试是指系统重负荷性能指标; 



![image-20231020153010638](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153010638.png)

这种策略是一种“非增量集成测试”（Non-incremental Integration Testing）。在非增量集成测试中，各个模块独立地进行测试，然后所有模块一起集成，执行一个集成测试，而不是逐步地、增量地添加模块进行测试。

增量集成测试（Incremental Integration Testing）是指逐步添加模块并进行测试，而不是一次性集成所有模块。

三明治集成测试（Sandwich Integration Testing）是一种结合了自顶向下和自底向上集成测试的方法，这里没有提到这种情况。

![image-20231020153101436](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153101436.png)

LoadRunner-负载压力测试：预测系统性能。 JMeter+Badboy：基于JAVA的压力测试工具，Badboy用来进行脚本的录制 功能测试：通过自动录制、检测和回放用户的应用操作。将输出记录同预先给定的记录比较。 Junit：白盒测试工具：针对代码测试 测试管理工具：对测试需求、计划、用例、实施进行管理 测试辅助工具：本身不执行，可以生成测试数据，为测试提供数据准备 负载压力测试：LoadRunner:预测系统行为和性能的工业标准级负载测试工具。模拟上千万用户同时实施并发操作，来实时监控可能发生的问题。 功能测试： QTP(quicktest professional):自动测试工具 白盒测试：C++ TEST（做C和C++的白盒测试）、JUnit（Java白盒测试） 缺陷管理工具：Mantis、BugFree、QC、TD 用例管理工具：TestLink、QC 测试辅助工具：SVN



![image-20231020153553708](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153553708.png)

在自底向上集成测试（Bottom-up Integration Testing）中，测试通常从最底层的模块（也就是没有依赖的模块）开始，然后逐渐向上集成更高层次的模块。由于最底层的模块通常被上层模块调用，因此在它们单独存在时，需要一个“驱动程序”（Driver）来模拟上层模块的行为，以便能够执行测试。

驱动程序负责初始化测试环境，调用下层模块，并接收这些模块返回的数据，以检查其是否正常工作。因此，测试员确实需要编写驱动程序来进行自底向上的集成测试。

