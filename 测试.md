### 白盒测试（White-box Testing）

白盒测试又叫结构测试或透明盒测试，主要针对软件内部结构、工作流程和功能进行测试。测试者需要了解被测试软件的内部结构和工作原理。白盒测试主要包括以下几种：

1. **单元测试（Unit Testing）**: 测试单个程序、子程序、模块或对象。
2. **路径测试（Path Testing）**: 验证所有代码路径都被正确执行。
3. **数据流测试（Data Flow Testing）**: 测试程序变量的初始化和修改。
4. **循环测试（Loop Testing）**: 针对软件中的所有循环结构进行测试。
5. **条件测试（Condition Testing）**: 验证决策语句（if、switch等）。
6. **代码覆盖测试（Code Coverage）**: 确保代码中的每一行、每一个分支都被执行过。
7. **静态分析（Static Analysis）**: 不执行代码，通过代码检查或使用静态分析工具进行测试。
8. **集成测试（Integration Testing）**: 在这个上下文中，集成测试通常针对模块间的接口进行。

### 黑盒测试（Black-box Testing）

黑盒测试又称为功能测试，它是在不了解内部结构和工作原理的情况下，对软件外部行为进行测试。主要包括以下几种：

1. **功能测试（Functional Testing）**: 测试软件所有功能是否按照需求规格书工作。

2. **边界值测试（Boundary Testing）**: 测试输入或输出数据边界条件。

3. **等价类划分（Equivalence Partitioning）**: 将输入数据分为几个等价类别，然后用这几个类别进行测试。

   等价类划分是一种测试设计技术，其中输入域被分为几个等价类。一个等价类中的所有值都应该具有相同的特性，并被预期产生相同的结果。通常从每个等价类中选取一个或几个代表性的值进行测试。

   例子：

   假设有一个函数，该函数接受年龄（1-100）作为输入并返回是否成年（>= 18）。这里有两个等价类：

   1. 1-17（未成年）
   2. 18-100（成年）

   选择每个等价类中的一个或两个值进行测试即可。

   优缺点：

   - **优点**：减少了测试用例的数量，同时保持了高覆盖率。
   - **缺点**：可能会错过一些边界条件。

4. **因果图**

5. **错误推测法：**

   错误推测法是一种经验性的测试方法，它依赖于测试人员或开发人员对系统可能出现错误的直觉和经验。

   例子：

   在一个电子商务应用中，对于信用卡号的验证，除了正常的输入检查外，测试人员可能会尝试一些常见的错误情况，如使用过期的卡、无效的卡号等。

   优缺点：

   - **优点**：能够找出那些正规测试方法可能忽视的问题。

   - **缺点**：完全依赖于个人经验和直觉，不系统化。

     

6. **决策表测试（Decision Table Testing）**: 用表格的方式来表示复杂业务规则，并据此进行测试。

   决策表测试是一种表格形式的测试设计技术，用于处理多个相关的输入和输出条件。这种方法特别适用于复杂的业务逻辑和决策过程。

   例子：

   在一个贷款批准流程中，输入可能包括“年收入”，“信用评分”，“拥有财产”等，输出则是“批准”或“拒绝”。通过决策表，可以列出所有可能的输入组合和相应的输出。

   优缺点：

   - **优点**：结构清晰，易于理解和维护。
   - **缺点**：对于具有大量输入/输出和决策路径的系统，决策表可能变得很复杂。

7. **状态转换测试（State Transition Testing）**: 测试从一个状态转换到另一个状态是否成功。

8. **压力测试（Stress Testing）**: 测试软件在极端条件（如资源不足、高并发）下的表现。

9. **性能测试（Performance Testing）**: 测量软件某些特定操作的响应时间或吞吐量。

10. **兼容性测试（Compatibility Testing）**: 测试软件在不同环境（如不同的浏览器、操作系统、硬件等）中的运行情况。

11. **接受测试（Acceptance Testing）**: 最终用户或客户进行的测试，以确定软件是否能被接受



  黑盒测试主要的方法有：等价类划分法、边界值分析法、错误推测法、因果图法、决策表法、场景法等。 

  白盒测试的主要方法有：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖等。 





![image-20231020135003126](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135003126.png)

负载测试：是通过逐步增加系统负载，测试系统性能的变化，并在**满足最终确定性能指标的情况下**，系统所能承受的**最大负载量**的测试

压力测试：逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载下系统性能**处于失效状态**，并以此来获得系统能提供的**最大服务级别的测试**

#### 负载测试（Load Testing）

1. **目的**: 负载测试的主要目的是确定系统在正常和预期的负载下的性能。
2. **范围**: 负载测试通常会模拟多个用户同时访问或使用应用，但这些负载都是预先设定并且在系统承受能力之内的。
3. **指标**: 主要关注的性能指标包括响应时间、吞吐量、系统资源（CPU、内存、磁盘、网络等）的使用情况。
4. **测试场景**: 通常模拟真实世界的正常业务操作和用户行为。

#### 压力测试（Stress Testing）

1. **目的**: 压力测试的目标是找出系统的极限性能和确定系统在极端负载下的稳定性。
2. **范围**: 这种测试涉及将系统推向其极限，经常超过系统的预期或设计能力，以查看它会如何失败和恢复。
3. **指标**: 主要关注系统的故障点、可恢复性，以及在高负载或资源不足的情况下是否会导致系统崩溃或数据丢失。
4. **测试场景**: 通常涉及极端情况，如数据库突然不可用、网络突然断开或者非常大量的用户请求。

#### 稳定性测试（Stability Testing）

稳定性测试是一种软件测试类型，其主要目的是确保软件或系统在长时间运行或在复杂负载下依然保持稳定和可靠的性能。这通常涉及在多种不同的环境和条件下，对软件进行长时间或持续不断的测试。

**主要特点：**

1. **持续运行**: 测试可能需要持续数小时、数天或更长时间，以模拟实际运行环境。
2. **复杂负载**: 除了正常操作外，还可能包括各种边缘案例和复杂的用户交互。
3. **多种环境**: 可能需要在不同的操作系统、硬件和网络配置下进行测试。

**主要目标：**

- **性能维持**: 确保在长时间运行后，性能（如响应时间、吞吐量等）没有明显下降。
- **资源管理**: 观察系统资源（如CPU、内存、磁盘等）的使用情况，确保没有内存泄漏、资源泄漏或其他稳定性问题。
- **错误处理**: 验证系统能够有效地处理错误和异常情况，并能够在发生故障后安全地恢复。
- **数据完整性**: 在各种操作和故障情况下，数据应保持完整和一致。
- 

![image-20231020135518141](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135518141.png)

   工作说明书/需求规格说明书—SOW 制定测试的进度  

   概要设计说明书-HLD 设计测试的用例  

   详细设计说明书-LLD 程序员编码实现  

   单元测试用例-UTC  单元测试使用  



![image-20231020135751807](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020135751807.png)

无效等价类是指对于软件规格说明而言，是没有意义的、不合理的输入数据集合。



![image-20231020140004148](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140004148.png)

 (1)所有的测试都应追溯到用户需求。

 (2)应当把“尽早地和不断地进行软件测试”作为座右铭。

 (3)pareto原则：测试发现的错误中80%很可能起源于20%的模块中。  

 (4)完全测试是不可能的，测试需要终止。  

 (5)应由独立的第三方来构造测试。 

 (6)充分注意测试中的群集现象。

 (7)尽量避免测试的随意性。  

 (8)兼顾合理的输入和不合理的输入数据。

 (9)程序修改后要回归测试。

 (10)应长期保留用例，直至系统废弃.



![image-20231020140346592](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140346592.png)



![image-20231020140748992](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140748992.png)

A. 并发用户数：这不是疲劳强度测试主要关注的问题。这更多地与性能测试和负载测试有关。

B. 内存泄漏：这是疲劳强度测试最可能首先发现的问题。长时间的运行可能会暴露内存泄漏问题。

C. 系统安全性：疲劳强度测试通常不聚焦于系统的安全性问题。

D. 功能错误：虽然长时间的运行可能会触发某些功能错误，但这并不是疲劳强度测试的主要关注点。



![image-20231020140837318](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020140837318.png)

一般来说，集成测试计划不会在需求分析阶段末提交。集成测试是在多个单元或组件已经分别进行了单元测试之后，将它们集成到一个更大的系统或子系统中时进行的测试。因此，集成测试通常是在单元测试之后进行的，也就是在编码和单元测试阶段之后。集成测试计划通常会在详细设计阶段完成或编码阶段开始时准备。

在软件开发的生命周期中，需求分析阶段主要关注于明确客户和系统的需求，而不是关注软件的测试活动。测试活动通常在稍后的阶段更为明确和活跃，尤其是在设计和编码阶段完成之后。



![image-20231020141144427](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141144427.png)

 **单元测试工具集合:** 

  **Parasoft jtest** 

  第一个自动化Java单元**测试**工具. 

  **Parasoft C++Test** 

  是**单元测试**和静态分析工具，自动测试C和C＋＋类别、功能或组件. 

  **Parasoft .TEST** 

  **是单元测试和静态分析工具，自动测试写在Microsoft?.NET框架的类别** 

  **Parasoft Insure++** 

  是一个自动化的内存错误、内存泄漏的精确检测工具。 

  **Parasoft CodeWizard** 

  是高级C/C++源代码分析工具，采用三百种以上行业相关的编码准则，自动识别编译器未检测到的危险的编码构造。 

  **DevPartner Studio Professional** 

  是针对软件开发小组使用 Microsoft Visual C++，Microsoft Visual Basic，Java,ASP 或 HTML 设计的一套紧密配合的调试，测试和管理工具。 

  **Rational Purify** 

  是一个面向VC, VB或者Java开发的测试Visual C/C++ 和Java代码中与内存有关的错误，确保整个应用程序的质量和可靠性。 

  **Rational Quantify** 

  是一个面向VC、VB 或者Java开发的测试性能瓶颈检测工具 

  **Rational PureCoverage** 

  是一个面向VC、VB或者Java开发的测试覆盖程度检测工具 



![image-20231020141624928](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141624928.png)

α测试是指软件开发公司组织内部人员模拟各类用户对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。α测试的关键在于尽可能逼真地模拟实际运行环境和用户对软件产品的操作并尽最大努力涵盖所有可能的 用户操作方式。经过α测试调整的软件产品称为β版本。 

β测试是由软件的多个用户在实际使用环境下进行的测试，这些用户返回有关错误信息给开发者。测试时，开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。在β测试中，由用户记下遇到的所有问题，包括真实的以及主观认定的，定期向开发者报告。β测试主要衡量产品的FLURPS，着重于产品的支持性，包括文档，客户培训和支持产品生产能力。 只有当α测试达到一定的可靠程度时，才能开始β测试。它处在整个测试的最后阶段。同时，产品的所有手册文本也应该在此阶段完全定稿。



###  Alpha 测试：

1. **定义**：Alpha 测试通常是软件开发团队内部进行的第一轮用户界面测试。在这个阶段，开发者通常会自己进行测试或请公司内部的其他专门的测试人员进行。
2. **环境**：Alpha 测试通常在开发环境中进行，而不是在用户环境中。
3. **参与者**：主要是内部开发者和测试人员。
4. **目的**：
   - 确保所有显而易见的缺陷已经被解决
   - 验证软件的功能和性能
   - 确保软件满足用户需求和规格说明
5. **局限性**：因为测试是在开发环境下进行的，所以可能无法完全模拟用户实际操作的环境和条件。
6. **时机**：通常在软件开发周期的后期，但在产品推向市场之前。
7. **反馈渠道**：通常通过内部渠道（如开发者或内部测试人员）。

### Beta 测试：

1. **定义**：Beta 测试是第二轮的用户测试，通常由最终用户进行。
2. **环境**：Beta 测试通常在用户的实际环境下进行。
3. **参与者**：选定的终端用户、客户或者公开招募的测试人员。
4. **目的**：
   - 发现那些在 Alpha 测试中可能遗漏的缺陷
   - 收集用户关于界面可用性、功能和整体体验的反馈
   - 在实际应用环境下评估产品性能
5. **局限性**：由于测试通常是由用户进行的，所以可能不如 Alpha 测试系统。
6. **时机**：通常在 Alpha 测试后，但在最终版本发布之前。
7. **反馈渠道**：通常通过在线问卷、电子邮件或其他形式收集用户反馈。

两者的主要区别在于测试的执行者和测试环境。Alpha 测试主要是内部人员进行，目的更侧重于查找明显的缺陷和问题；而 Beta 测试则由实际用户进行，在真实环境下检验软件的可用性和稳定性。这两个测试阶段通常都是在软件发布之前进行的，以确保产品尽可能地无缺陷。



![image-20231020141747127](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141747127.png)

4个，case0，case1，case2和3，default

语句覆盖是指选择足够多的测试数据，使被测程序中的每条语句至少执行一次。0，1，2，3一共四条语句即可，因为在执行2，3时无break，所以default语句也将被执行。 



![image-20231020141920907](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020141920907.png)

 v模型

用户需求————————————————>验收测试

​       需求测试————————————>系统测试

​              概要设计————————>集成测试

​                     详细设计————>单元测试

​                                       编码

在项目的早期阶段就开始设计系统测试用例，因为这样更容易发现问题，并且给予更多的时间来解决这些问题。所以，如果要选择最佳的时间开始设计测试用例，**需求完成（选项A）**通常被认为是最适当的，尤其是在敏捷或迭代的开发环境中。然而，在更传统的瀑布模型中，可能会选择在**详细设计完成（选项B）**后开始。



![image-20231020142218237](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142218237.png)



![image-20231020142517483](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142517483.png)

比较判断与控制流常常紧密相关，测试时注意下列错误：  1. 不同数据类型的对象之间进行比较;  2. 错误地使用逻辑运算符或优先级;  3. 因计算机表示的局限性，期望理论上相等而实际上不相等的两个量相等;  4. 比较运算或变量出错;  5. 循环终止条件或不可能出现;  6. 迭代发散时不能退出;  7. 错误地修改了循环变量。 

![image-20231020142819415](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020142819415.png)

A. **`@Test`注解标注的测试方法只能是 `public void` 的，且不能有任何输入参数**

- 这是正确的。使用 `@Test` 注解标注的测试方法必须是 `public void` 类型，并且不能有输入参数。

B. **`AssertEquals`、`AssertNotEquals`：判断两个对象是否为同一个**

- 这是不正确的。`assertEquals` 用于检查两个对象是否相等（即调用 `.equals()` 方法的结果），而不是检查是否为同一个对象（即通过 `==` 操作符检查）。`assertNotEquals` 则用于检查两个对象是否不相等。

C. **`@BeforeClass`注解每一个测试方法都要执行一次，且必须为 `static void`**

- 这是不正确的。`@BeforeClass` 注解标注的方法在该测试类的所有测试方法执行前只执行一次，而不是每一个测试方法执行前都执行。此外，这个方法必须是 `static void`。



  Junit单元测试框架—基于java语言对的主流单元测试框架 

  @**beforeClass**—位于数据准备前期或者其他前期准备（测试类调用前） 

  --用于提取代码中的共用部分减少冗余，只能声明注解一次 

  --必须在public static void,方法名随意，，只运行一次。 

  @**AfterClass**—位于所有用例运行之后，处理测试后续工作。 

​        --测试类被调用运行结束之前，只能声明注解一次。 

​        --必须在public static void,方法名随意，，只运行一次。 

  @**Test**—在Junit3中通过对测试类和测试方法的命名来确定是否为测试 

​     --在Junit4中，只要在方法前加@Test就行，此注解必为单元测试。 

​     --在一个测试类可多次注解，每个只被执行一次，必须是public void 

​     --可以抛异常 

  使用Assert断言 

  1、断言相等：**assertEquals**(100,x)，判断对象是否为同一个 

  断言不相等：**assertNotEquals**(100,x)，判断对象是否不为同一个 

  2、断言数组内容相等：assertArrayEquals({1,2,3},x) 

  3、断言浮点数相等：assertEquals(3.1416, x, 0.0001)（必须设置误差值） 

  4、断言为null：assertNull(x) 

  5、断言真伪性：assertTrue(x > 0)/assertFalse(x < 0) 

  6、 校准测试函数，使用操作符'=='比较实际和预期的是否重复



![image-20231020143228307](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143228307.png)

因果图法着重测试规格说明中的输入与输出间的依赖关系。

  等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。 

 如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。



![image-20231020143505803](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143505803.png)

【软件需求】是软件开发之前做好的，软件开发是根据这个做的，那么软件测试自然也需要参考该文件 【迭代计划】是软件的某个周期的计划，自然也需要参考 【可行性】是软件开发前做好，用于证明该计划可行的，没有必要参考 



![image-20231020143918748](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020143918748.png)

性能测试、压力测试、负载测试的关系

- 性能测试是正常情况下的性能指标； (选择时间)
- 压力测试是测试系统的瓶颈所在； 
- 负载测试是指系统重负荷性能指标; 



![image-20231020153010638](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153010638.png)

这种策略是一种“非增量集成测试”（Non-incremental Integration Testing）。在非增量集成测试中，各个模块独立地进行测试，然后所有模块一起集成，执行一个集成测试，而不是逐步地、增量地添加模块进行测试。

增量集成测试（Incremental Integration Testing）是指逐步添加模块并进行测试，而不是一次性集成所有模块。

三明治集成测试（Sandwich Integration Testing）是一种结合了自顶向下和自底向上集成测试的方法，这里没有提到这种情况。

![image-20231020153101436](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153101436.png)

LoadRunner-负载压力测试：预测系统性能。 JMeter+Badboy：基于JAVA的压力测试工具，Badboy用来进行脚本的录制 功能测试：通过自动录制、检测和回放用户的应用操作。将输出记录同预先给定的记录比较。 Junit：白盒测试工具：针对代码测试 测试管理工具：对测试需求、计划、用例、实施进行管理 测试辅助工具：本身不执行，可以生成测试数据，为测试提供数据准备 负载压力测试：LoadRunner:预测系统行为和性能的工业标准级负载测试工具。模拟上千万用户同时实施并发操作，来实时监控可能发生的问题。 功能测试： QTP(quicktest professional):自动测试工具 白盒测试：C++ TEST（做C和C++的白盒测试）、JUnit（Java白盒测试） 缺陷管理工具：Mantis、BugFree、QC、TD 用例管理工具：TestLink、QC 测试辅助工具：SVN



![image-20231020153553708](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020153553708.png)

在自底向上集成测试（Bottom-up Integration Testing）中，测试通常从最底层的模块（也就是没有依赖的模块）开始，然后逐渐向上集成更高层次的模块。由于最底层的模块通常被上层模块调用，因此在它们单独存在时，需要一个“驱动程序”（Driver）来模拟上层模块的行为，以便能够执行测试。

驱动程序负责初始化测试环境，调用下层模块，并接收这些模块返回的数据，以检查其是否正常工作。因此，测试员确实需要编写驱动程序来进行自底向上的集成测试。