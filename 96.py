# 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

class Solution:
    def numTrees(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1

        # 创建一个字典（或者数组）来存储已经计算过的值
        memo = {}

        def DFS(l, r):
            if l >= r:
                return 1

            # 检查是否已经计算过这个值
            if (l, r) in memo:
                return memo[(l, r)]

            res = 0
            for i in range(l, r+1):
                res += DFS(l, i-1)*DFS(i+1, r)
                # 将计算过的值存储在字典中
            memo[(l, r)] = res
            return res

        return DFS(1, n)


if __name__ == "__main__":
    solution = Solution()
    print(solution.numTrees(19))

# 使用memo（记忆化）的核心思想是保存已经计算过的子问题的解，以便在将来需要时可以直接使用，从而避免重复计算。这在递归算法中尤其有效，因为递归算法往往会多次计算相同的子问题。

# 考虑numTrees(19)这个例子，它需要计算的子问题涉及的范围是[1, 19]。这样的子问题数量本身就是非常多的。如果没有记忆化，那么相同的子问题（同样的(l, r)值对）会被多次重新计算，导致大量的时间浪费。

# 例如，考虑子问题DFS(1, 18)和DFS(2, 19)。两者都需要计算DFS(2, 18)作为其子问题之一。在没有记忆化的情况下，DFS(2, 18)会被重新计算两次，而使用记忆化后，DFS(2, 18)只会被计算一次，其结果会被保存起来供以后使用。

# 这样的重复子问题在整个计算过程中会出现非常多次。通过记忆化，我们可以大大减少这些重复计算，从而显著提高算法效率。

# 记忆化通常能将时间复杂度从指数级（或更高）降低到多项式级。在这个具体的例子中，记忆化能够将算法的时间复杂度降低到O(n^2)（这里 n=19），这对于n=19来说是完全可接受的。

# 所以，使用memo字典节省了大量时间，使得即使对于较大的n值（如19），算法也能在合理的时间内运行完成。