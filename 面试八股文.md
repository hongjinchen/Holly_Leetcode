





# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）**: 单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

   在单例模式的实现中，通常会：

   1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
   2. 创建一个私有静态成员变量，用于保存单一实例。
   3. 提供一个公共静态方法来获取这个唯一的实例。

2. **工厂方法模式（Factory Method）**: 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个接口用于创建对象，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

   工厂方法模式主要包括以下几个组件：

   1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
   2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
   3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
   4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

   如何实现

   1. **定义一个返回对象（Product）的工厂接口（Creator）**。
   2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
   3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

   ```python
   from abc import ABC, abstractmethod
   
   # Product 类
   class Button(ABC):
   
       @abstractmethod
       def click(self):
           pass
   
   # ConcreteProduct 类
   class WindowsButton(Button):
       
       def click(self):
           print("Windows button clicked")
   
   class LinuxButton(Button):
       
       def click(self):
           print("Linux button clicked")
   
   # Creator 类
   class ButtonFactory(ABC):
       
       @abstractmethod
       def create_button(self):
           pass
   
   # ConcreteCreator 类
   class WindowsButtonFactory(ButtonFactory):
       
       def create_button(self):
           return WindowsButton()
   
   class LinuxButtonFactory(ButtonFactory):
       
       def create_button(self):
           return LinuxButton()
   
   # 客户端代码
   def button_client_code(factory):
       button = factory.create_button()
       button.click()
   
   # 使用
   windows_factory = WindowsButtonFactory()
   button_client_code(windows_factory)
   
   linux_factory = LinuxButtonFactory()
   button_client_code(linux_factory)
   
   ```

   

3. **抽象工厂模式（Abstract Factory）**: 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

   **结构和组件**

   1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

   2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

   3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

   4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

      

      1. **定义抽象产品的接口（AbstractProduct）**。

      2. **创建实现该接口的具体产品（ConcreteProduct）**。

      3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

      4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

      5. **使用具体工厂和抽象工厂来创建产品实例**。

         

      ```python
      from abc import ABC, abstractmethod
      
      # 抽象产品
      class Button(ABC):
          @abstractmethod
          def click(self):
              pass
      
      class Checkbox(ABC):
          @abstractmethod
          def check(self):
              pass
      
      # 具体产品
      class WindowsButton(Button):
          def click(self):
              print("Windows Button clicked")
      
      class WindowsCheckbox(Checkbox):
          def check(self):
              print("Windows Checkbox checked")
      
      class LinuxButton(Button):
          def click(self):
              print("Linux Button clicked")
      
      class LinuxCheckbox(Checkbox):
          def check(self):
              print("Linux Checkbox checked")
      
      # 抽象工厂
      class GUIFactory(ABC):
          @abstractmethod
          def create_button(self):
              pass
      
          @abstractmethod
          def create_checkbox(self):
              pass
      
      # 具体工厂
      class WindowsGUIFactory(GUIFactory):
          def create_button(self):
              return WindowsButton()
      
          def create_checkbox(self):
              return WindowsCheckbox()
      
      class LinuxGUIFactory(GUIFactory):
          def create_button(self):
              return LinuxButton()
      
          def create_checkbox(self):
              return LinuxCheckbox()
      
      # 客户端代码
      def client_code(factory):
          button = factory.create_button()
          checkbox = factory.create_checkbox()
          
          button.click()
          checkbox.check()
      
      # 使用
      windows_factory = WindowsGUIFactory()
      client_code(windows_factory)
      
      linux_factory = LinuxGUIFactory()
      client_code(linux_factory)
      
      ```

      

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

### 结构型模式（Structural Patterns）

1. **适配器模式（Adapter）**: 允许不兼容的接口可以一起工作。
2. **装饰器模式（Decorator）**: 在不改变对象本身的基础上，动态地添加额外的功能。
3. **组合模式（Composite）**: 将对象组合成树形结构以表示“部分-整体”的层次结构。

### 行为型模式（Behavioral Patterns）

1. **观察者模式（Observer）**: 当一个对象的状态发生变化时，其依赖者都会得到通知。
2. **策略模式（Strategy）**: 定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。
3. **命令模式（Command）**: 将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。

# 计算机网络

## HTTP 和 HTTPS 的基本概念

**HTTP**：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP 原理**：

①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 **TCP** 来完成的，一般 TCP 连接的端口号是**80**。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。



**HTTPS**：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。**SSL 握手协议（SSL Handshake Protocol）**，它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
![img](https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70)

**HTTPS 设计目标**：

(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。

(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。



### HTTP 与 HTTPS  的区别

1、HTTPS  协议需要到 **CA （Certificate Authority，证书颁发机构）**申请证书，一般免费证书较少，因而需要一定费用。（但是云服务器供应商会免费配置HTTPS  证书）

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

- **HTTP**: 使用明文进行传输，信息在传输过程中没有加密。这意味着第三方可以容易地截获和查看数据。
- **HTTPS**: 使用 SSL/TLS 协议对数据进行加密，保证了数据在传输过程中的安全性。这使得第三方即使截获了数据也很难解读。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

5、CPU 资源消耗

- **HTTP**: 由于没有加密和解密过程，所以 CPU 资源消耗相对较少。
- **HTTPS**: 加密和解密需要额外的 CPU 资源，从而导致更高的计算成本。





### HTTPS 相对于 HTTP 的改进

#### **双向的身份认证**

客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：

- 客户端发起 SSL 握手消息给服务端要求连接。

- 服务端将证书发送给客户端。

- 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

- 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。



注意：

(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是*一对公钥和私钥*。

(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。

(3) 客户端内置的是 **CA 的根证书(Root Certificate)**，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。



#### 数据传输的机密性

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的**加密算法**。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的**密钥交换算法** ( 一般是**RSA**)，**数据签名摘要算法** ( 一般是SHA或者MD5) ，加密传输数据的**对称加密算法** ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。



#### 防止重放攻击

SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。

可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。

重放攻击（Replay Attack）是一种网络攻击类型，其中攻击者拦截并记录了有效的数据传输，然后在稍后的时间里再次发送（或“重放”）该数据，以尝试进行未授权的操作。因为这些数据包在初次传输时是有效的，所以在没有额外安全措施的情况下，接收方可能会认为重放的数据包也是有效和合法的。



**如何进行重放攻击？**

1. **拦截阶段**: 攻击者首先需要能够拦截目标和服务器之间的通信。这通常通过嗅探、中间人攻击或者其他网络侦听技术来完成。
2. **记录阶段**: 攻击者记录拦截到的数据包。
3. **重放阶段**: 攻击者在合适的时机将记录的数据包重新发送给服务器或目标。

**重放攻击的影响**

1. **身份冒充**: 如果拦截的是身份验证信息（如登录令牌或密码），攻击者可能通过重放攻击成功冒充用户。
2. **数据篡改**: 如果拦截的是一个修改数据的操作，重放攻击可能导致数据被重复修改。
3. **信息泄露**: 攻击者可能通过分析拦截的数据包获取敏感信息。

**防御措施**

1. **时间戳**: 在数据包中包含一个时间戳，并在接收数据包时检查它是否在一个合理的时间窗口内。这样，过时的数据包（即可能已经被记录和重放的数据包）就会被拒绝。

2. **序列号**: 使用一个递增的序列号来标记每个数据包。服务器会记录最后一个接收到的有效序列号，并拒绝所有序列号小于或等于该值的数据包。

3. **一次性令牌**: 使用一次性令牌（如 OTP，One-Time Password）进行身份验证。

4. **加密和完整性校验**: 使用像 HTTPS 这样的安全协议，其内部有措施（如消息认证码）来防止重播攻击。

5. **多因素认证**: 使用多种方式进行身份验证，降低单一数据包被重放导致的风险。

   

### HTTPS 的优点

1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。



### HTTPS 的缺点（对比优点）

1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。

3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。

5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。



### HTTPS连接过程

HTTPS 的连接过程涉及多个步骤，主要目的是建立一个安全的加密通道，并进行服务器和（可选的）客户端的身份验证。这通常是通过 TLS（传输层安全）或其前身 SSL（安全套接字层）来实现的。以下是 HTTPS 连接的基本流程，分为几个关键步骤：

#### 1. TCP 握手

在进行任何 HTTPS 交互之前，客户端（通常是一个Web浏览器）和服务器首先需要建立一个 TCP 连接。这是通过三次握手（SYN, SYN-ACK, ACK）完成的。

#### 2. 客户端发起 TLS 握手

一旦 TCP 连接建立，客户端会发起一个 TLS 握手。握手开始时，客户端会发送一个 `ClientHello` 消息，该消息中包含：

- 支持的加密算法列表
- 一个随机生成的客户端随机数（Client Random）
- 其他设置和扩展

#### 3. 服务器响应

服务器接收 `ClientHello` 消息后，会选择一组加密算法和其他设置，然后发送一个 `ServerHello` 消息，其中包含：

- 选定的加密算法
- 一个随机生成的服务器随机数（Server Random）
- 服务器的数字证书

#### 4. 证书验证

客户端接收到服务器的证书后，会对其进行验证以确认服务器的身份。这通常包括：

- 检查证书是否由受信任的证书颁发机构（CA）签发
- 验证证书是否过期
- 验证证书是否被撤销

#### 5. 密钥交换

客户端和服务器使用各自的随机数和一个（在某些密钥交换算法中的）预主密钥（Pre-Master Secret）来生成主密钥（Master Secret）。主密钥将用于加密和解密数据。

客户端生成预主密钥，并使用服务器公钥进行加密，然后发送给服务器。服务器使用其私钥解密获取预主密钥。

#### 6. 完成握手

客户端和服务器都发送一个 `Finished` 消息，该消息使用之前生成的主密钥进行加密。

#### 7. 加密数据传输

一旦 TLS 握手完成，客户端和服务器就会使用生成的主密钥进行加密和解密数据，从而确保数据传输的安全性。

#### 8. 连接关闭

连接完成后，任何一方都可以选择关闭连接。通常，这是通过发送一个 `close_notify` 警告来完成的。这样，双方都能知道连接将安全地关闭，而不是因为某种错误或攻击而突然中断。



#### tcp的三次挥手和四次挥手

**三次握手（Three-Way Handshake）**

三次握手是 TCP 连接建立的过程，涉及三个主要步骤：

1. **SYN（同步序列编号）**: 客户端发送一个 TCP 包，其中设置了 SYN 标志位，以请求建立连接。这个包也包含一个初始的序列号 `x`。
2. **SYN-ACK（同步应答）**: 服务器收到 SYN 包后，回复一个设置了 SYN 和 ACK（确认）标志位的 TCP 包。这个包确认了客户端的 SYN，并提供了服务器自己的初始序列号 `y`。
3. **ACK（应答）**: 客户端收到 SYN-ACK 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 SYN。

完成这三个步骤后，TCP 连接就建立了，数据可以双向传输。

**四次挥手（Four-Way Handshake）**

四次挥手是 TCP 连接终止的过程，涉及四个主要步骤：

1. **FIN（完成）**: 当一方（假设是客户端）准备关闭连接时，它发送一个设置了 FIN 标志位的 TCP 包。
2. **ACK（应答）**: 服务器收到 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认客户端的 FIN。此时，从客户端到服务器的连接关闭，但服务器到客户端的连接仍然打开。
3. **FIN（完成）**: 当服务器准备关闭连接时（可能是立即，也可能是稍后），它发送一个设置了 FIN 标志位的 TCP 包。
4. **ACK（应答）**: 客户端收到服务器的 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 FIN。

完成这四个步骤后，TCP 连接就完全关闭了。

![img](https://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116161802952-584681349.png)

https://www.cnblogs.com/liyuhui-Z/p/7844880.html

### HTTP连接过程

#### 1. DNS 解析

首先，浏览器会对目标服务器的域名进行 DNS（Domain Name System）解析，以获取其 IP 地址。

#### 2. 建立 TCP 连接

DNS 解析完成后，浏览器与服务器的 IP 地址建立一个 TCP 连接。这是通过 TCP 的三次握手过程（SYN, SYN-ACK, ACK）完成的。

#### 3. 发送 HTTP 请求

TCP 连接建立后，浏览器会通过该连接发送一个 HTTP 请求给服务器。HTTP 请求通常包括：

- 请求方法（GET、POST、PUT、DELETE 等）
- 目标 URL
- HTTP 版本
- 请求头（如 `User-Agent`, `Accept-Language` 等）
- 可选的请求体（主要用于 POST 和 PUT 请求）

#### 4. 服务器处理请求

服务器接收到 HTTP 请求后，会根据请求的类型和目标资源进行处理。这可能包括查询数据库、执行服务器端代码等。

#### 5. 发送 HTTP 响应

服务器处理完请求后，会发送一个 HTTP 响应回到客户端。HTTP 响应通常包括：

- HTTP 状态码（如 200 OK，404 Not Found 等）
- 响应头（如 `Content-Type`, `Cache-Control` 等）
- 响应体（返回的实际数据，如 HTML 文档、图像等）

#### 6. 渲染和显示

客户端（通常是浏览器）接收到 HTTP 响应后，会根据响应内容进行相应的处理。例如，如果返回的是一个 HTML 文档，浏览器会解析并渲染它。

#### 7. 关闭 TCP 连接

数据传输完成后，客户端和服务器可以选择关闭 TCP 连接，或者保持它以用于后续的请求和响应（HTTP/1.1 默认行为是保持连接）。关闭连接通常是通过发送 TCP FIN 包来完成的。



[^https://blog.csdn.net/qq_38289815/article/details/80969419]: 



## **浏览器的渲染过程**

### DNS解析

- 浏览器首先需要知道目标服务器的IP地址。如果该地址不在本地DNS缓存中，浏览器或操作系统会发出一个DNS查询请求。



### TCP连接

- 浏览器与服务器建立一个TCP连接。这通常涉及一个“三次握手”过程。

  

### 发送HTTP请求

- TCP连接建立后，浏览器会通过该连接发送一个HTTP请求到服务器。这个请求包含了许多信息，如请求方法（GET、POST等）、headers、以及可能的请求体。



### 服务器处理请求

- 服务器收到HTTP请求后，会进行各种处理，这可能包括查询数据库、计算、身份验证等。



### 发送HTTP响应

- 处理完成后，服务器会创建一个HTTP响应，并通过TCP连接发送回浏览器。这个响应通常包含一个状态码（如200 OK）、响应头和响应体（通常是HTML文档）。



### 浏览器解析HTML

- 浏览器收到HTTP响应后，开始解析HTML代码，创建DOM（文档对象模型）。



### 资源加载和渲染

- 在解析HTML的同时，浏览器也会请求其他资源，如CSS、JavaScript文件和图片等。这些资源可能来自同一个服务器，也可能来自其他服务器。

  

### 执行JavaScript



### 页面渲染完成

- 当所有的资源都加载完成并且所有的JavaScript代码都被执行后，页面就算是完全渲染完成。



# Git

### 初始化和配置

1. **`git init`**：在当前目录下初始化一个新的 Git 仓库。
2. **`git config`**: 用于设置 Git 配置信息。

### 克隆和远程操作

1. **`git clone [url]`**：克隆（复制）一个远程仓库到本地。
2. **`git remote`**: 用于管理远程仓库。
3. **`git fetch`**: 获取远程仓库的最新版本，但不合并。
4. **`git pull`**: 获取并合并远程仓库的最新版本。

### 文件和状态操作

1. **`git status`**: 显示工作目录和暂存区的状态。
2. **`git add [file]`**: 将文件添加到暂存区。
3. **`git rm [file]`**: 从版本控制中移除文件。

### 提交和历史

1. **`git commit`**: 提交暂存区的文件。
2. **`git log`**: 查看提交历史。
3. **`git revert`**: 回滚到之前的提交。

### 分支和标签

1. **`git branch`**: 列出、创建或删除分支。
2. **`git checkout [branch]`**: 切换到指定分支。
3. **`git merge [branch]`**: 将指定分支合并到当前分支。
4. **`git tag`**: 用于操作标签。

### 其他

1. **`git stash`**: 临时保存当前的修改。
2. **`git reset`**: 重置当前分支到某个状态。
3. **`git diff`**: 查看文件差异。



# 测试

## 通用测试用例八要素

![img](https://img-blog.csdnimg.cn/img_convert/fde5e8955b1c0d7366ea094708cd1fc6.png)　　<img src="https://img-blog.csdnimg.cn/da3dfbaa6b9441589dd178540d3552ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASVTlpbPlrak=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

**1、用例编号；**

> 一般是数字和字符组合成的字符串，可以包括（下划线、单词缩写、数字等等），但是需要注意的是，尽量不要写汉语拼音，因为拼音的意义可能有好几种，有可能会导致乱码； 
>
> 用例编号具有唯一性和易识别性。（ 比如说我们唯一标识一个人：中国-上海市-xx区xx号-xx楼--xx室-xxx.这样标识的话就具有唯一性了。)

　　不同阶段的测试用例的用例编号有不同的规则：
　　（1）系统测试用例：产品编号-ST-系统测试项名-系统测试子项名-XXX
　　（2）集成测试用例：产品编号-IT-系统测试项名-系统测试子项名-XXX
　　（3）单元测试用例：产品编号-UT-系统测试项名-系统测试子项名-XXX
　　**其中产品编号也叫项目标识，每个公司都有若干不同的项目或者产品，如何来区分它们呢？这就需要有产品编号了，每个公司都有自己的一套定义产品编号的规则，并且每个现有产品的编号已经制定好了，直接拿过来用就可以了。
　　**产品编号后的ST、IT、UT分别对应系统测试阶段、集成测试阶段、单元测试阶段。实际工作中有些公司会将产品编号以及测试阶段省略。
　　**测试阶段后面就是测试项目名了，对应的是较大较系统的测试点。
　　**测试项目名后面就是测试子项目名，有些测试是没有子项目名的，只有当测试项力度比较大的时候才会有成都市子项 （比如说：我们要测试用户能否成功登录这个功能，那我们就可以分为很多个子项，qq登录、邮箱登录等等）。
　	测试子项名后面就是具体的用例编号了，可以是数字：01、001、002等等。



　　**2、测试项目；**

（1）系统测试用例：对应一个功能点（功能测试）、性能指标（性能测试）、界面中控件（GUI测试）等等。
（2）集成测试用例：对应集成后的模块功能或者接口功能。
（3）单元测试用例：对应函数名。 



　　**3、测试标题；**

　　**4、重要级别；**

用例的重要级别一般分成三个级别：高、中、低。
高级别：对应保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例；
中级别：对应重要程度介于高和低之间的测试用例；
低级别：对应实际使用频率不高，对系统业务功能影响比较大的模块或功能的测试用例。



　　**5、预置条件；**

> 　 测试用例在执行前需要满足一些前提条件，否则测试用例是无法执行的，这些前提条件就是预置条件。

　　预置条件分为两种情况：
　　（1）环境的设置。
　　例如：测试word打开文件的功能，预置条件就是：需要提前准备被打开的文件；
　　例如：登录成功的预置条件就是：该用户名已经注册过了。
　　例如：购买商品成功的预置条件就是：后台已经配置好商品、发货区域、以及支付方式了。
　　（2）先要运行的其他用例，有些操作系统会比较复杂，如果都是从最开始的操作开始会导致用例写起来比较麻烦，这样可以在预置条件中设定要先运行的测试用例，后面的用例只需要写后续的操作就可以了。
　　例如：对自动取款机进行测试，有针对的输入账户信息的测试，有对输入取钱金额的测试，后者的预置条件就可以写成输入正确账户信息的测试用例。
　　注：具体预置条件的设置不同的公司会有自己的规定，比如有的公司是不允许第二种情况出现的。



　　**6、测试输入；**

测试输入是用于运行测试用例的具体数据或值。这些输入数据用于模拟不同的用户操作和场景。

- **示例**：

  - 用户名和密码用于登录测试。
  - 搜索关键词用于搜索功能测试。

- **重要性**：

  - 它们是产生预期结果的“触发器”。

  - 用于验证应用程序如何处理不同类型和范围的数据。

    

　　**7、操作步骤；**

明确描述测试执行过程中具体的操作步骤，以方便测试执行人员可以根据该操作步骤完成测试用例执行。

- **示例**：

  1. 打开应用程序。
  2. 在用户名字段中输入预定义的用户名。
  3. 在密码字段中输入预定义的密码。
  4. 点击“登录”按钮。

- **重要性**：

  - 提供了一种结构化的方式来执行测试，确保测试的一致性和可重复性。

  - 有助于准确地复现缺陷和问题。

    

　　**8、预期输出；**

> （1）界面显示：在操作步骤完成之后，界面会有显示；比如说我们测试用户登录功能，界面可能会显示登录成功或者登录失败。
>
> （2）数据库的变化：在操作步骤完成之后，数据库中的记录会发生相应的变化，比如删除功能的测试，点击删除后，数据库中该记录会被删除。
>
> （3）相关信息的变化：在操作步骤执行完成后，一些和被测对象相关的信息会发生变化，比如：注销功能的测试，点击注销后，以前能访问的页面将无法再访问。 



## 测试要点

![img](https://img-blog.csdn.net/20180505154820871)

## 软件测试类别

![img](https://img-blog.csdnimg.cn/20210919103511372.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57qi55uu6aaZ6Jaw,size_20,color_FFFFFF,t_70,g_se,x_16)



## 常用自动化测试工具

https://zhuanlan.zhihu.com/p/603190738

https://blog.csdn.net/weixin_44015669/article/details/121082810

**Selenium**--WebUI自动化测试

**Postman**--接口测试

Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。

**Jmeter**--性能测试

最初是为了测试Web应用程序而开发的

1. **模拟高负载**：JMeter 可以模拟多个用户同时访问一个服务，以测试该服务在高负载下的性能和稳定性。
2. **性能分析**：JMeter 不仅可以测试服务在极限负载下的性能，还可以分析服务在不同负载级别下的整体性能。

**Jenkins**

**Appium** -- AppUI自动化测试



## 软件测试开发流程



## 美团面试真题

### TCP（传输控制协议）与 UDP（用户数据报协议）的区别

#### TCP

1. **面向连接**: 在数据传输之前需要先建立连接（三次握手）。
2. **可靠性高**: 提供数据传输的确认机制、错误恢复等。
3. **有序传输**: 数据报文段按照其发送顺序进行接收。
4. **拥塞控制**: 通过流量控制和拥塞控制机制，适应网络状态。
5. **速度较慢**: 由于上述特性，通常比UDP慢。
6. **重量级**: 由于保证可靠性和有序性，所以报头较大，消耗更多的CPU资源。

#### UDP

1. **无连接**: 不需要预先建立连接。

2. **可靠性低**: 不提供数据传输的确认机制。

3. **无序传输**: 数据报文段可能会乱序到达。

4. **无拥塞控制**: 速度快，但在网络拥塞时可能会丢包。

5. **速度较快**: 由于较少的检查和确认，通常比TCP快。

6. **轻量级**: 报头小，消耗较少的CPU资源。

   

### 应用场景

#### 适合使用TCP的场景

1. **文件传输**: 如FTP, HTTP，需要确保数据的完整性。

2. **电子邮件**: 如SMTP。

3. **远程登录**: 如SSH, Telnet。

4. **数据库操作**: 如MySQL。

5. **流媒体的可靠传输**: 如用于实时但需要可靠传输的WebRTC。

   

#### 适合使用UDP的场景

1. **实时应用**: 如VoIP，实时视频会议。

2. **广播和多播应用**: 如IPTV。

3. **快速交互**: 如DNS查询。

4. **在线游戏**: 对实时性要求高，允许少量丢包。

5. **流媒体的不可靠传输**: 如用于实时但可以容忍一定丢包的流媒体应用。

   

### 常用的排序算法

1. ### **冒泡排序（Bubble Sort）**

   #### 基本思路

   1. 遍历整个数组，比较相邻的两个元素，如果它们是逆序的，则交换它们。
   2. 重复这个过程，每次遍历少看一个元素。
   3. 如果一次遍历中没有发生任何交换，则数组已经是有序的，可以提前结束算法。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def bubble_sort(arr):
       n = len(arr)
       for i in range(n):
           swapped = False
           for j in range(0, n-i-1):
               if arr[j] > arr[j+1]:
                   arr[j], arr[j+1] = arr[j+1], arr[j]
                   swapped = True
           if not swapped:
               break
   ```

2. ### **归并排序（Merge Sort）**

   #### 基本思路

   1. 分：将原始数组分成两个或更多的空间。
   2. 解决：递归地将子数组排序。
   3. 合并（Merge）：将排序后的子数组合并，形成一个新的排序数组。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```python
   def merge_sort(arr):
       # 如果数组长度小于或等于 1，那么它已经是有序的
       if len(arr) <= 1:
           return arr
       
       # 计算中点并分割数组为两个子数组
       mid = len(arr) // 2
       left_half = arr[:mid]
       right_half = arr[mid:]
       
       # 递归地对两个子数组进行排序
       sorted_left = merge_sort(left_half)
       sorted_right = merge_sort(right_half)
       
       # 将两个已排序的子数组进行归并
       return merge(sorted_left, sorted_right)
   
   def merge(left, right):
       result = []
       i = j = 0
       
       # 比较 left 和 right 数组中的元素，并添加到结果数组中
       while i < len(left) and j < len(right):
           if left[i] < right[j]:
               result.append(left[i])
               i += 1
           else:
               result.append(right[j])
               j += 1
       
       # 如果 left 数组还有剩余元素，将其添加到结果数组中
       while i < len(left):
           result.append(left[i])
           i += 1
       
       # 如果 right 数组还有剩余元素，将其添加到结果数组中
       while j < len(right):
           result.append(right[j])
           j += 1
       
       return result
   
   # 测试归并排序函数
   if __name__ == "__main__":
       arr = [38, 27, 43, 3, 9, 82, 10]
       sorted_arr = merge_sort(arr)
       print("Sorted Array:", sorted_arr)
   
   ```

   

3. ### **快速排序（Quick Sort）**

   快速排序（Quick Sort）是一种被广泛应用的排序算法，由英国计算机科学家 Tony Hoare 在1960年提出。它是一种分治法（Divide and Conquer）的应用，能够在平均情况下实现 O(n log n) 的时间复杂度。下面是快速排序的基本思路和详细解释。

   **基本思路**

   1. **选取基准元素（Pivot）**: 在数组中选择一个元素作为基准。
   2. **分区（Partitioning）**: 重新排列数组，使得比基准元素小的元素在其左侧，比基准元素大的元素在其右侧。在这一过程中，基准元素到达其最终位置。
   3. **递归排序子数组**: 对基准元素左右两侧的子数组进行同样的操作。
   4. **结束条件**: 当子数组的大小为 0 或 1 时，该子数组已经是有序的，不需要进一步处理。

   **算法步骤**

   假设我们有一个数组 `arr = [3, 6, 8, 10, 1, 2, 1]`，并且我们选择最后一个元素作为基准元素。

   1. **选取基准元素**:
      - 我们选择 `1` 作为基准元素。
   2. **分区**:
      - 定义两个指针 `i` 和 `j`。其中，`i` 从数组的第一个元素开始，`j` 从数组的倒数第二个元素开始。
      - 遍历数组，使得所有小于 `1` 的元素都移到它的左侧，所有大于 `1` 的元素都移到它的右侧。
      - 例如，我们可能得到一个这样的数组：`[1, 1, 8, 10, 3, 6, 2]`。
      - 现在，基准元素 `1` 已经到达了它应该在的位置。
   3. **递归排序子数组**:
      - 对于基准元素左侧的子数组 `[1]` 和右侧的子数组 `[8, 10, 3, 6, 2]`，我们递归地进行快速排序。
   4. **结束条件**:
      - 当递归到数组大小为 0 或 1 时，递归结束。

   **代码示例（Python）**

   ```python
   def quick_sort(arr, low, high):
       if low < high:
           # 找到基准元素后的正确位置
           pivot_index = partition(arr, low, high)
           
           # 递归地对基准元素左边和右边的子数组进行快速排序
           quick_sort(arr, low, pivot_index - 1)
           quick_sort(arr, pivot_index + 1, high)
   
   def partition(arr, low, high):
       # 选择最右侧的元素作为基准
       pivot = arr[high]
       i = low - 1
       
       # 将小于基准的元素移动到基准的左侧
       for j in range(low, high):
           if arr[j] < pivot:
               i += 1
               arr[i], arr[j] = arr[j], arr[i]
               
       # 将基准元素移动到正确的位置
       arr[i + 1], arr[high] = arr[high], arr[i + 1]
       return i + 1
   
   # 测试快速排序函数
   if __name__ == "__main__":
       arr = [10, 7, 8, 9, 1, 5]
       n = len(arr)
       quick_sort(arr, 0, n - 1)
       print("Sorted array:", arr)
   
   ```

   **时间复杂度和空间复杂度**

   - 时间复杂度
     - 最好情况：O(n log n)
     - 平均情况：O(n log n)
     - 最坏情况：O(n^2)
   - **空间复杂度**: O(log n) 到 O(n)

   快速排序是不稳定的排序算法，但是它的优点是排序速度快，实现相对简单。希望这个解释有助于你更好地理解快速排序的工作原理。

   

4. ### **选择排序（Selection Sort）**

   **基本思路**

   选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每次从未排序的元素中找出最小（或最大）元素，将其存放到序列的起始（或末尾）位置。这样，每次迭代后，最小（或最大）元素就被放到了它最终排序后应处于的位置。该过程会持续进行，直到所有元素都被正确排序。

   **时间复杂度和空间复杂度**

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：不稳定

   **示例代码（Python）**

   ```python
   def selection_sort(arr):
       n = len(arr)
       
       # 遍历整个数组
       for i in range(n):
           # 找到从当前位置到数组末尾的最小元素的索引
           min_index = i
           for j in range(i + 1, n):
               if arr[j] < arr[min_index]:
                   min_index = j
                   
           # 交换找到的最小元素和当前位置的元素
           arr[i], arr[min_index] = arr[min_index], arr[i]
   
   # 测试选择排序函数
   if __name__ == "__main__":
       arr = [64, 25, 12, 22, 11]
       selection_sort(arr)
       print("Sorted array:", arr)
   
   ```

5. ### **插入排序（Insertion Sort）**

   #### 基本思路

   1. 从第一个元素开始，该元素可以认为已经被排序。
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
   4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def insertion_sort(arr):
       for i in range(1, len(arr)):
           key = arr[i]
           j = i - 1
           while j >= 0 and key < arr[j]:
               arr[j + 1] = arr[j]
               j -= 1
           arr[j + 1] = key
   ```

### **合并所有的重叠区间，合并后的区间按照升序排列** 

合并所有重叠区间并按照升序排列是一个经典的算法问题，通常用于间隔调度、时间表生成等场景。这个问题的解决方法一般分为以下几个步骤：

**步骤：**

1. **排序**：首先对给定的区间按照起始点进行排序。

2. **初始化**：将第一个区间添加到结果列表中。

3. 合并

   ：遍历其余的区间，与结果列表中最后一个区间进行比较，看是否有重叠。

   - 如果有重叠，合并它们。
   - 如果没有重叠，直接将当前区间添加到结果列表中。

4. **输出**：返回合并后的结果列表。

**Python 代码示例：**

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    
    # 按区间的起始点进行排序
    intervals.sort(key=lambda x: x[0])
    
    # 初始化结果列表，并将第一个区间添加进去
    result = [intervals[0]]
    
    # 遍历剩下的区间
    for current in intervals[1:]:
        # 获取结果列表中最后一个区间
        last = result[-1]
        
        # 检查当前区间和最后一个区间是否有重叠
        if current[0] <= last[1]:
            # 合并两个重叠的区间
            result[-1] = [last[0], max(last[1], current[1])]
        else:
            # 如果没有重叠，直接添加到结果列表中
            result.append(current)
    
    return result

# 测试代码
if __name__ == "__main__":
    intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
    print("Merged intervals:", merge_intervals(intervals))
```

运行这段代码后，输出的合并后的区间应该是 `[[1, 6], [8, 10], [15, 18]]`。

这个算法的时间复杂度是 O*(*n*log*n*)，主要消耗在排序步骤上。空间复杂度则为 O*(*n*)，用于存储结果列表。



### **如何判断链表里有环**

#### 快慢指针法

该算法使用两个指针，一个快指针和一个慢指针。快指针每次移动两个节点，而慢指针每次移动一个节点。如果链表中存在环，快慢指针最终会在环内的某个节点相遇。



**快慢指针法的终止条件：**

该算法有两个主要的终止条件：

1. **相遇条件**：如果快指针和慢指针在链表中的某个点相遇，这意味着链表存在环。
2. **空指针条件**：如果快指针或其下一个节点成为空指针（`None`），这意味着链表没有环。

**Python 代码示例：**

下面是使用 Python 定义一个简单的链表节点和使用快慢指针法检测链表中是否存在环的代码：

```
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    # 初始化慢指针和快指针
    slow = head
    fast = head
    
    while fast is not None and fast.next is not None:
        # 慢指针移动一步
        slow = slow.next
        # 快指针移动两步
        fast = fast.next.next
        
        # 检查快慢指针是否相遇
        if slow == fast:
            return True  # 存在环
    
    return False  # 不存在环

# 创建一个没有环的链表
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

# 测试函数
print("Has cycle:", has_cycle(head))  # 输出应为 False

# 创建一个有环的链表
head.next.next.next = head

# 测试函数
print("Has cycle:", has_cycle(head))  # 输出应为 True
```

在这个示例中，`ListNode` 类用于创建链表节点，`has_cycle` 函数则用于检测链表是否包含环。我们首先创建一个没有环的链表进行测试，然后修改链表以形成一个环，并再次进行测试。

这种使用快慢指针的方法时间复杂度为 O*(*n*)，其中 n 是链表中的节点数。空间复杂度为 O*(1)，因为我们只使用了两个指针。



### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）



### **针对一个用户登录页面的网页，你可以编写那些测试用例？**

#### 功能测试

1. **正常登录**：使用有效的用户名和密码进行登录。
2. **无效用户名和/或密码**：使用无效的用户名和密码，应显示错误消息。
3. **空白字段**：不填写用户名或密码或两者都不填写，应显示必填或错误消息。
4. **特殊字符支持**：检查是否可以在用户名和密码中使用特殊字符。
5. **大小写敏感性**：验证用户名和密码是否区分大小写。
6. **忘记密码**：测试忘记密码功能，是否能通过邮箱或手机等方式重置密码。
7. **会话超时**：验证长时间不活动后是否自动登出。

#### 安全性测试

1. **SQL注入**：确保应用程序不受SQL注入攻击的影响。

   假设一个简单的登录表单，后端代码用于检索用户信息可能如下：

   ```
   SELECT * FROM users WHERE username = '$username' AND password = '$password';
   ```

   在这里，`$username` 和 `$password` 是用户输入的内容。如果应用程序没有正确地处理这些输入，攻击者可以输入特殊的字符串来操纵SQL查询，例如：

   ```
   Username: admin' --
   Password: (任意值)
   ```

   这将使SQL查询变为：

   ```
   SELECT * FROM users WHERE username = 'admin' --' AND password = '(任意值)';
   ```

   由于 `--` 是SQL中的注释标记，所以查询的其余部分将被注释掉，这意味着只要用户名为 `admin` 的用户存在，查询就会成功，不管密码是否正确。

2. **XSS攻击**：确保没有跨站脚本（XSS）漏洞。

3. **多次错误尝试**：在多次连续错误登录尝试后，应限制用户尝试登录或触发验证码。

4. **数据传输安全**：确保密码和其他敏感信息在网络上传输时是加密的。

5. **密码安全策略**：检查是否实施了强密码策略。

#### 性能测试

1. **加载时间**：确保页面在不同网络环境下能快速加载。
2. **并发用户**：测试系统能否在多个用户同时登录的情况下保持稳定。

#### 用户体验测试

1. **响应式设计**：确保登录页面在不同大小和类型的设备上都能正常工作。
2. **错误消息**：确保所有错误消息都是清晰和用户友好的。
3. **字段焦点**：在输入错误后，焦点是否会自动移到错误字段。
4. **键盘快捷键**：例如，是否可以使用Enter键提交表单。



### Cookie和Session

**存储位置**

- **Cookie**：存储在客户端（浏览器）。这意味着每次发送HTTP请求时，浏览器都会自动附加与该站点相关的所有Cookie。
- **Session**：通常存储在服务器端。客户端存储一个与服务器端Session相关联的`Session ID`，通常这个`Session ID`是存储在Cookie中的。

**存储容量**

- **Cookie**：由于存储在客户端，因此存储空间有限，通常最大为4KB。
- **Session**：存储在服务器，通常没有存储限制。但是，存储大量数据可能会影响服务器性能。

**存储期限**

- **Cookie**：可以设置过期时间，如果不设置，生命周期则与浏览器会话（Session）同长，即关闭浏览器后消失。
- **Session**：在没有活动的情况下，Session会在一定时间后过期。这个时间是可以配置的。

**数据类型**

- **Cookie**：仅能存储文本信息。
- **Session**：可以存储各种类型的数据，如对象和数组。

**速度和效率**

- **Cookie**：由于每次HTTP请求都会带上Cookie，因此可能会影响性能，特别是当Cookie信息较多时。
- **Session**：由于存储在服务器端，不需要每次都传送，因此相对更高效。



### TCP四层协议

#### 1. 应用层（Application Layer）

- **作用**：负责提供网络服务的接口，以便最终用户和应用程序可以交互。
- **常用协议**：
  - HTTP（超文本传输协议）
  - FTP（文件传输协议）
  - SMTP（简单邮件传输协议）
  - DNS（域名系统）

#### 2. 传输层（Transport Layer）

- **作用**：负责端到端（即主机到主机）的数据传输和流量控制。它确保数据从源端到目的端可靠、有效地传输。
- **常用协议**：
  - TCP（传输控制协议）：提供可靠、面向连接的通信
  - UDP（用户数据报协议）：提供不可靠、无连接的通信

#### 3. 网络层（Network Layer）

- **作用**：负责将数据包从源主机路由到目的主机。这一过程可能涉及多个网络和连接多个网络设备（如路由器、交换机等）。
- **常用协议**：
  - IP（互联网协议）
  - ICMP（互联网控制消息协议）
  - OSPF（开放最短路径优先）

#### 4. 链路层（Link Layer）

- **作用**：负责将网络层传来的数据帧从一台机器传输到另一台机器，这通常是在同一局域网内或者在两台相邻网络设备之间。
- **常用协议/标准**：
  - Ethernet
  - Wi-Fi
  - ARP（地址解析协议）



### **回文串判断**

#### 1. 双指针法

- **步骤**：
  1. 初始化两个指针：一个在字符串的起始位置（`left`），一个在字符串的结束位置（`right`）。
  2. 比较两个指针所指向的字符是否相等。如果不相等，则该字符串不是回文串。
  3. 如果相等，将两个指针分别向中间移动，并重复步骤2。
  4. 当`left`大于等于`right`时，确认该字符串是回文串。
- **时间复杂度**：O(n)，其中n是字符串的长度。





### 如果需要访问多个域名，那么可以如何节省网络消耗？

**DNS预解析（DNS Prefetch）**

预解析可以预先进行DNS查询，减少实际请求时的DNS解析时间。

```
<link rel="dns-prefetch" href="//example.com">
```

**预连接（Preconnect）**

预连接不仅会预解析DNS，还会预先进行TCP握手和TLS协商。

```
<link rel="preconnect" href="https://example.com">
```

**数据压缩**

使用Gzip或Brotli等压缩算法可以减少传输的数据量。

**使用HTTP/2或HTTP/3**

这些新版本的HTTP协议提供了多路复用、头部压缩等特性，可以减少网络消耗。

**使用持久连接（Keep-Alive）**

通过复用TCP连接，你可以减少TCP握手所需的时间和带宽。

**优化资源**

- **合并文件**：将多个小的CSS或JavaScript文件合并为一个大文件，以减少HTTP请求的数量。
- **异步加载**：对于非关键资源，可以使用异步加载来减少初始页面加载所需的时间。
- **懒加载**：对于例如图片这样的大资源，使用懒加载可以延迟加载直到用户实际需要。

**缓存**

充分利用浏览器缓存和服务器缓存可以减少重复请求，从而减少网络消耗。

**限制重定向**

尽量减少或避免使用重定向，因为每次重定向都会消耗额外的网络资源。



### 接口测试

#### 接口文档分析

接口文档一般是由后端开发提供，可以是在线的swagger也可以是word。

![img](https://pic2.zhimg.com/80/v2-f7e9e8a489498c0c878cb83d9d885df9_1440w.webp)

####  **接口信息五要素**

**1）接口地址url：**

http-请求协议，api.lemonban.com-域名或ip，8765-端口号，/futureloan/member/register-资源路径

**2）请求方法：**

看开发定义的请求方法是什么，测试就对应用什么方法。restful风格中常见的请求方法为post、get、put、patch、delete等

**3）请求头：**

发送请求到服务器，包含的头部信息。常见的content-type。

**4）请求体：**

发送请求到服务器，具体传递的数据。例如要完成注册接口的调用，请求体包含手机号mobile_phone、密码pwd、用户名reg_name、验证码verification_code。

**5）响应内容：**

接口文档中描述的响应内容，与接口测试的实际结果做比较，可以判断当前接口是否通过。响应内容包含：响应码-http状态码、响应头、响应体。



#### 接口用例设计

接口用例设计跟功能测试思维相通，需要：

1）清楚项目业务

 2）运用用例设计8大方法：等价类、边界值、场景法、因果图、判定表、正交试验法、状态迁移法、错误推测法。

**1. 等价类划分（Equivalence Class Partitioning）**

**目的**：简化测试用例的数量，同时保持测试的有效性。

**步骤**：

1. 识别输入参数和它们的值范围。
2. 划分等价类：有效等价类和无效等价类。
3. 为每个等价类设计一个或几个测试用例。

**例子**：测试年龄输入字段，接受18-60岁。有效等价类：[18, 60]，无效等价类：小于18和大于60。

**2. 边界值分析（Boundary Value Analysis）**

**目的**：测试输入或输出边界条件。

**步骤**：

1. 确定输入或输出边界。
2. 设计测试用例，包括边界值。

**例子**：使用年龄18、19、59、60作为测试用例。

**3. 场景法（Scenario Testing）**

**目的**：模拟真实世界的情况。

**步骤**：

1. 理解用户如何使用系统。
2. 根据实际使用场景设计测试用例。

**4. 因果图（Cause-Effect Graphing）**

**目的**：识别输入和输出之间的依赖关系。

**步骤**：

1. 列出所有可能的输入条件（因）和输出结果（果）。
2. 绘制因果图。
3. 生成测试用例。

**5. 判定表（Decision Table）**

**目的**：处理复杂的业务规则。

**步骤**：

1. 确定输入和输出变量。
2. 构建判定表。
3. 根据判定表生成测试用例。

**6. 正交试验法（Orthogonal Array Testing）**

**目的**：在多变量系统中找出最优的测试组合。

**步骤**：

1. 确定要测试的变量和它们的可能值。
2. 使用正交数组来确定测试组合。

**7. 状态迁移法（State Transition Testing）**

**目的**：测试系统在不同状态间的行为。

**步骤**：

1. 确定系统的各种状态。
2. 确定从一个状态到另一个状态的转换。
3. 设计测试用例以覆盖所有可能的状态转换。

**8. 错误推测法（Error Guessing）**

**目的**：基于经验和直觉来设计测试用例。

**步骤**：

1. 根据之前的缺陷或常见的错误模式来推测可能的错误。

2. 设计针对这些错误的测试用例。

   

以下是接口用例模板参考：

![img](https://pic2.zhimg.com/80/v2-71755a986c543385af8e1aac3897d7d9_1440w.webp)



#### 发现bug、定位、提交并跟踪

怎么判断是否是bug呢？

1）接口测试中响应结果错误，返回了错误的code码、msg信息：

- 判断请求：请求地址、方式、请求头、请求正文是否正确，如果不正确则修改对应请求信息再做发送；如果正确，则说明是服务器端问题
- 进一步查看服务器日志、数据库信息，并整理信息提交bug

2）接口测试中响应结果，code码、msg正确，但返回的data数据不正确：

- 查看数据库数据正确完整性，并结合服务器日志，整理信息提交bug

3）接口测试中响应结果正确，但若是增删改业务操作：

- 需进一步确认到数据库层面，数据增删改的正确性

4）考虑安全性：一般接口对请求会做出一些限制,比如请求次数、请求频率限制；涉及敏感信息是否加密



### 对测试开发的理解以及他们日常会做什么工作

测试开发（Test Development 或 Test Automation Development）是软件测试的一个子领域，专注于通过编程来自动化测试过程。测试开发不仅涉及编写自动化测试脚本，还包括设计和维护自动化测试框架、与开发团队紧密合作以提高软件质量，以及参与持续集成（CI）和持续交付（CD）流程。下面详细地介绍一下测试开发的一些核心职责和他们日常可能会做的工作。

**核心职责**

1. **自动化测试脚本编写**：使用编程语言（如 Python、Java 等）和自动化测试工具（如 Selenium、Appium、Junit 等）来编写测试脚本。
2. **测试框架设计与维护**：设计和建立自动化测试框架，以便更容易、更快捷地编写和运行测试脚本。
3. **测试用例设计**：与需求分析师、产品经理和开发人员合作，理解新功能或改动，然后设计相应的测试用例。
4. **持续集成与持续交付（CI/CD）**：将自动化测试脚本融入CI/CD管道，确保每次代码更改都能自动触发相关测试。
5. **代码审查与质量保证**：参与代码审查，以确保测试代码质量；同时也关注产品代码，帮助开发人员提高代码质量。
6. **性能测试**：使用工具如 JMeter 进行性能、压力和负载测试。
7. **文档编写与维护**：编写测试报告和文档，以记录测试计划、测试用例和测试结果。

**日常工作流程**

1. **需求分析**：在一个迭代或开发周期开始时，与团队成员一起了解即将开发或修改的功能。
2. **测试计划与用例设计**：根据需求分析结果，制定测试计划并设计测试用例。
3. **环境准备**：设置和维护测试环境，包括数据准备、服务器配置等。
4. **编写与调试测试代码**：按照测试用例编写自动化测试脚本，并进行调试。
5. **执行测试**：运行测试脚本，手动或自动地执行测试用例。
6. **结果分析与报告**：分析测试结果，找出问题并编写测试报告。
7. **缺陷跟踪与修复**：与开发人员一起跟踪和修复在测试中发现的缺陷。
8. **代码提交与CI/CD**：将测试代码提交到版本控制系统，并确保它被纳入CI/CD流程。
9. **回归测试与维护**：在软件发布后，进行回归测试以确保新添加或修改的代码没有引入新的问题。



### 为什么选择测试开发

自我追求部分

能力匹配部分



1. 技术层面

**全面的技术观点:** 测试开发不仅涉及到测试，还需**理解软件的开发过程**，这为**深入了解整个系统**提供了机会。

**自动化与编程**: 现代测试开发大量依赖自动化，这也意味着有很多编程工作，对于喜欢编程的人来说是个好选择。

2. 问题解决

侦查与调查: **良好的测试能够发现隐藏的问题**，这需要扎实的问题解决能力。

质量保证: 你的工作直接**影响产品质量**，这是个相当有成就感的工作。

6. 学习与成长

- 不断学习: 软件工具和方法论不断更新，需要持续学习。
- 多元化的挑战: **测试开发会接触到多种类型的项目和问题**，这有助于个人成长



### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 测试用例设计并讲解：微信发送图片

**功能测试**

1. **基础发送测试**
   - **目的**：验证正常情况下能否成功发送图片。
   - **步骤**：选择一个聊天窗口，点击添加图片的图标，选择一张图片，点击发送。
   - **预期结果**：图片应成功发送并在聊天窗口中显示。
2. **多图发送测试**
   - **目的**：验证是否能同时发送多张图片。
   - **步骤**：在同一个聊天窗口中选择多张图片并发送。
   - **预期结果**：所有选定的图片都应成功发送。
3. **格式支持测试**
   - **目的**：验证支持的图片格式（如 JPEG, PNG, GIF 等）。
   - **步骤**：尝试发送不同格式的图片。
   - **预期结果**：支持的格式应能成功发送，不支持的格式应给出警告。

**性能测试**

1. **大文件发送测试**
   - **目的**：验证大文件（接近或达到微信允许的最大限制）是否能成功发送。
   - **步骤**：选择一张大文件大小的图片尝试发送。
   - **预期结果**：如果在微信允许的大小内，应能成功发送；否则，应有相应的错误提示。
2. **高并发测试**
   - **目的**：模拟多用户同时发送图片的场景。
   - **步骤**：使用测试工具模拟多个用户账号同时发送图片。
   - **预期结果**：图片应成功发送，不应有延迟或失败。

**异常测试**

1. **网络不稳定环境下发送图片**
   - **目的**：测试在网络信号差或不稳定的情况下能否成功发送图片。
   - **步骤**：在网络不稳定的环境下尝试发送图片。
   - **预期结果**：应有合适的处理机制，如重试、提示用户网络不稳定等。
2. **无网络环境下发送图片**
   - **目的**：测试在没有网络的情况下应用的表现。
   - **步骤**：关闭所有网络连接，尝试发送图片。
   - **预期结果**：应提示用户当前无网络，不能发送图片。

**安全性测试**

1. 非法文件测试

   - **目的**：验证应用是否能阻止发送包含恶意代码的图片文件。

   - **步骤**：尝试发送一个包含恶意代码的图片文件。

   - **预期结果**：应阻止发送并给出警告。

     

### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。



### UDP对应的协议

①DNS：用于域名解析服务，将域名地址转换为IP地址，使用53号端口。

②SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备。由于网络设备过多，无连接的服务体现优势。

③TFTP：简单文件传输协议，该协议在端口69号使用UDP服务。



### TCP对应的协议

FTP：定义了文件传输协议，使用21号端口。

Telnet：用于远程登录的端口，其使用23号端口，用户可以以自己的身份远程连接到计算机上。

SMTP：邮件传送协议，用于发送邮件。其使用25号端口。

POP3：其与SMTP对应，POP3用于接收邮件。使用了110端口。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议，端口是80号

HTTPs：端口是443号



### OSI七层协议

OSI（Open Systems Interconnection）模型是一个概念框架，用于标准化网络协议的不同功能层。该模型将网络协议分为七个不同的层次，以促进不同协议和设备间的互操作性。下面是各层的概述：

1. **物理层（Physical Layer）**: 这一层主要处理与物理媒体相关的细节，比如电缆、交换机、网卡等。主要任务是数据比特流（bits）的传输。
2. **数据链路层（Data Link Layer）**: 在物理层之上，数据链路层负责创建一个可靠的链路连接，主要负责 MAC（Media Access Control） 地址和帧的封装与解封装。
3. **网络层（Network Layer）**: 这一层负责数据包的路由和传输，即如何从源到目的地。**IP 协议**就工作在这一层。
4. **传输层（Transport Layer）**: 主要负责端到端（End-to-End）的数据传输和流量控制。**TCP 和 UDP 协议**就工作在这一层。
5. **会话层（Session Layer）**: 该层负责在数据传输中设置和维护会话。
6. **表示层（Presentation Layer）**: 主要负责数据格式的转换或加密。例如，将 EBCDIC 编码转换为 ASCII 编码。
7. **应用层（Application Layer）**: 这一层负责处理特定的应用程序细节。常见的应用层协议包括 **HTTP、FTP、SMTP** 等。

**TCP 和 HTTP 分别属于哪一层？**

- **TCP（Transmission Control Protocol）**: 通常被认为是传输层的一部分。它负责提供可靠、顺序的点对点通信。

- **HTTP（HyperText Transfer Protocol）**: 是应用层的一部分。它定义了客户端和服务器之间如何传送超文本数据。

  

### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。



### HTTP状态码

1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。

「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。

「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。

「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。

「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。

「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5xx 状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。



### Python八股文

#### python的回收机制

Python 使用一种称为引用计数的内存管理机制，以及一个垃圾回收器来清理不再使用的对象。下面我将详细地解释这两个方面。

**引用计数（Reference Counting）**

在 Python 中，每个对象都有一个与之关联的引用计数。当创建一个对象并将其分配给一个变量时，这个对象的引用计数就变为1。如果这个对象被其他变量引用，其引用计数会相应增加。每当一个对象的引用被删除或离开其作用域，引用计数就会减1。当引用计数达到0时，内存就会被释放。

```
pythonCopy code# 创建一个对象（引用计数为 1）
a = [1, 2, 3]

# 引用同一对象（引用计数增加到 2）
b = a

# 解除一个引用（引用计数减少到 1）
del a

# 解除另一个引用（引用计数减少到 0，对象被删除）
del b
```

**垃圾回收（Garbage Collection）**

引用计数有一些局限性，尤其是不能处理引用循环。垃圾回收机制可以检测到这样的循环，并将其打破。

```
pythonCopy code# 创建引用循环
a = {}
b = {}
a['b'] = b
b['a'] = a

# 此时即使 del a 和 del b，a 和 b 仍然存在引用循环，不会被销毁
```

Python 的垃圾回收机制主要基于“代”（Generations）的概念。所有新创建的对象开始时都位于第一代（youngest generation）。如果第一代的对象经过一次垃圾回收仍然存在，则被移动到第二代。同理，第二代对象经过垃圾回收后仍然存在的话，则被移动到第三代。

Python 默认开启垃圾回收机制，但你也可以手动控制它：

- `gc.collect()`：手动运行垃圾回收。
- `gc.set_threshold()`：设置垃圾回收触发的阈值。
- `gc.get_stats()`：获取垃圾回收统计信息。

**综合**

Python 的内存管理机制综合了引用计数和垃圾回收，以达到高效和准确的内存回收。这使得在大多数情况下，开发者可以不必担心内存泄漏，而可以集中精力去解决更有意义的问题。

希望这个详细的解释能帮助你更好地理解 Python 的内存回收机制。



#### **解释型和编译型语言的区别**

- 编译型语言：把做好的源程序全部编译成**二进制**的可运行程序。然后，可直接运行这个程序。如：C，C++ ；
- 解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！如：Python。

####  **简述下 Python 中的字符串、列表、元组和字典**

字符串（**str**）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。
列表（**list**）：列表是有序的集合，可以向其中添加或删除元素。
元组（**tuple**）：元组也是有序集合，元组中的数无法修改。即元组是不可变的。
字典（**dict**）：字典是无序的集合，是由键值对（key-value）组成的。
集合（**set**）：是一组 key 的集合，每个元素都是唯一，不重复且无序的。



#### **字符串常见操作**

1. 切片：`'luobodazahui'[1:3]``

2. ``join`：可以用来连接字符串，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。`'-'.join(['luo', 'bo', 'da', 'za', 'hui'])`

3. `String.replace(old,new,count)`：将字符串中的 `old`字符替换为 `New`字符，`count`为替换的个数 `'luobodazahui-haha'.replace('haha', 'good')`

4. split：切割字符串，得到一个列表

   ```
   >>> mystr5 = 'luobo,dazahui good'
   
   >>> print(mystr5.split())  # 默认以空格分割
   ['luobo,dazahui', 'good']
   
   >>> print(mystr5.split('h'))  # 以h分割
   ['luobo,daza', 'ui good']
   
   >>> print(mystr5.split(','))  # 以逗号分割
   ['luobo', 'dazahui good']
   ```

   

**列表常见操作**

1. 切片，同字符串

2. `append`和 `extend`向列表中添加元素

   ```
   >>> mylist1 = [1, 2]
   >>> mylist2 = [3, 4]
   >>> mylist3 = [1, 2]
   
   >>> mylist1.append(mylist2)
   >>> print(mylist1)
   [1, 2, [3, 4]]
   
   >>> mylist3.extend(mylist2)
   >>> print(mylist3)
   [1, 2, 3, 4]
   ```

   

3. 删除元素

    `del`:根据下标进行删除

   `pop`：删除最后一个元素

   `remove`：根据元素的值进行删除

   ```
   >>> mylist4 = ['a', 'b', 'c', 'd']
   
   >>> del mylist4[0]
   >>> print(mylist4)
   ['b', 'c', 'd']
   
   >>> mylist4.pop()
   >>> print(mylist4)
   ['b', 'c']
   
   >>> mylist4.remove('c')
   >>> print(mylist4)
   ['b']
   ```

   

1. 元素排序 `sort`：是将`list`按特定顺序重新排列，默认为由小到大，参数 `reverse=True`可改为倒序，由大到小。

```
>>> mylist5 = [1, 5, 2, 3, 4]
>>> mylist5.sort()
>>> print(mylist5)
[1, 2, 3, 4, 5]
>>> mylist5.reverse()
>>> print(mylist5)
[5, 4, 3, 2, 1]
```

1. `reverse`：是将`list`逆置。

   

**字典常见操作**

1. 清空字典 `dict.clear()`

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> dict1.clear()
   >>> dict1
   {}
   ```

2. 指定删除：使用 `pop`方法来指定删除字典中的**某一项**（随机的）。

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> d1 = dict1.pop('key1')
   >>> dict1
   {'key2': 2}
   >>> d1
   1
   ```

3. 遍历字典

   ```
   >>> dict2 = {'key1':1, 'key2':2}
   >>> mykey = [key for key in dict2]  # ['key1', 'key2']
   >>> mykey
   ['key1', 'key2']
   >>> myvalue = [value for value in dict2.values()]
   >>> myvalue
   [1, 2]
   >>> key_value = [(k, v) for k, v in dict2.items()]
   >>> key_value
   [('key1', 1), ('key2', 2)]
   ```

4. `fromkeys`用于创建一个新字典，以序列中元素做字典的键，`value`为字典所有键对应的初始值。

```
>>> keys = ['zhangfei', 'guanyu', 'liubei', 'zhaoyun']
>>> dict.fromkeys(keys, 0)
{'zhangfei': 0, 'guanyu': 0, 'liubei': 0, 'zhaoyun': 0}
```



**一行代码实现数值交换**

```
>>> a, b = 1, 2
>>> a, b = b, a
>>> print(a, b)
```



**is 和 == 的区别**

`==`是比较操作符，只是判断对象的**值**（value）是否一致，而 `is` 则判断的是对象之间的身份（**内存地址**）是否一致。对象的身份，可以通过 `id()` 方法来查看。

```
>>> c = d = [1, 2]
>>> e = [1, 2]

>>> print(c is d)
True

>>> print(c == d)
True

>>> print(c is e)
False

>>> print(c == e)
True
```

只有 `id`一致时，`is`比较才会返回 `True`，而当 `value`一致时，`==` 比较就会返回 `True`。



`*arg` 和 `**kwarg` 作用

允许我们在调用函数的时候传入多个实参

```
>>> def test(*arg, **kwarg):
...     if arg:
...         print("arg:", arg)
...     if kwarg:
...         print("kearg:", kwarg)
...
>>> test('ni', 'hao', key='world')
arg: ('ni', 'hao')
kearg: {'key': 'world'}
```



**[lambda x:i*x for i in range(4)]**

```
>>> def num():
...     return [lambda x:i*x for i in range(4)]
...
>>> [m(1) for m in num()]
[3, 3, 3, 3]
```

https://blog.csdn.net/qq_37085158/article/details/126821933



#### python浅拷贝（Shallow Copy）

1. 使用切片操作（只适用于列表和其他序列类型）。

   ```
   original_list = [1, [2, 3], 4]
   copied_list = original_list[:]
   ```

2. 使用 `copy` 模块的 `copy()` 函数。

   ```
   import copy
   copied_object = copy.copy(original_object)
   ```

3. 对于字典，可以使用 `dict.copy()` 方法。

   ```
   original_dict = {'a': 1, 'b': [2, 3]}
   copied_dict = original_dict.copy()
   ```

4. 对于集合，可以使用 `set.copy()` 方法。

   ```
   original_set = {1, 2, 3}
   copied_set = original_set.copy()
   ```



#### python深拷贝（Deep Copy）

深拷贝会复制对象以及其包含的所有嵌套对象。这意味着，生成的新对象是原始对象的完全独立副本。

1. 使用 模块的  函数。

   ```
   deepcopy()
   ```

   ```
   import copy
   deep_copied_object = copy.deepcopy(original_object)
   ```

#### 深拷贝示例

```
import copy

original_list = [1, [2, 3], 4]
deep_copied_list = copy.deepcopy(original_list)

# 修改原始列表
original_list[0] = 0
original_list[1][0] = 0

# 输出两个列表
print("Original:", original_list)  # Output: [0, [0, 3], 4]
print("Deep Copied:", deep_copied_list)  # Output: [1, [2, 3], 4]
```



### JAVA八股文

#### **Java的回收机制（Garbage Collection）**

Java 使用垃圾回收机制自动管理内存，主要目标是识别并回收不再使用的对象。Java中的垃圾收集器通常是后台运行的，它自动地查找不再被引用的对象并释放其占用的内存。

**引用计数（Reference Counting）**



#### **java多态**

多态（Polymorphism）是面向对象编程中的一个重要概念，**它允许你使用一个接口来表示多种数据类型**。在 Java 中，多态主要通过**接口、继承和方法重载来实现**。下面我会详细解释这个概念。

**主要类型：**

1. **编译时多态（静态多态）**：主要是通过方法重载实现的。
2. **运行时多态（动态多态）**：主要是通过继承和接口实现的。

**编译时多态**

方法重载是一种编译时多态。同一个类中可以有多个同名但参数列表不同的方法。

```
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```

**运行时多态**

1. **继承**：子类继承父类，子类对象可以赋值给父类引用。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal makes a sound");
       }
   }
   
   class Dog extends Animal {
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   
   Animal myAnimal = new Dog();  // Dog 对象存储在 Animal 类型的变量中
   myAnimal.makeSound();  // 输出 "Dog barks"
   ```

2. **接口**：一个类可以实现多个接口，接口的实例可以指向实现该接口的任何类的对象。

   ```
   interface Drawable {
       void draw();
   }
   
   class Circle implements Drawable {
       public void draw() {
           System.out.println("Drawing a circle");
       }
   }
   
   Drawable d = new Circle();
   d.draw();
   ```

**优点：**

1. **代码可重用**：你可以编写能以多种方式工作的代码。
2. **可扩展性**：你可以添加新的类型，而不必修改现有的代码。
3. **维护性**：代码结构更清晰，更易于管理和维护。

**注意事项：**

1. 运行时多态在 Java 中是通过虚拟方法表（Virtual Method Table）来实现的，这会带来一定的性能开销。
2. 需要正确地使用方法覆盖（Override）和重载（Overload）。

多态是面向对象编程的四大基本特性之一（封装、继承、多态和抽象）。正确地使用多态可以使代码更灵活、可扩展和易于维护。



#### Java继承

在 Java 中，继承是一种允许我们重用代码和建立类之间关系的机制。通过继承，一个类（称为子类或派生类）可以获得另一个类（称为父类或基类）的字段（变量）和方法。下面详细介绍 Java 中继承的各个方面。

**基础语法**

要创建一个子类，您可以使用 `extends` 关键字：

```
public class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

public class Dog extends Animal {
    // Dog 类继承了 Animal 类
}
```

在这个例子中，`Dog` 类继承了 `Animal` 类，因此 `Dog` 类具有 `Animal` 类的所有非私有属性和方法。您可以创建一个 `Dog` 对象并调用 `makeSound` 方法，即使 `Dog` 类自己并没有定义这个方法：

```
Dog myDog = new Dog();
myDog.makeSound();  // 输出 "Some generic animal sound"
```



**方法覆盖（Method Overriding）**

子类可以提供父类已有方法的特定实现。这被称为方法覆盖。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof woof");
    }
}
```

现在，如果您创建一个 `Dog` 对象并调用 `makeSound` 方法，将输出 "Woof woof"，而不是 "Some generic animal sound"。



**调用父类的方法和构造函数**

子类可以使用 `super` 关键字来调用父类的方法和构造函数。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();
        System.out.println("Woof woof");
    }
}
```



**访问修饰符和继承**

- `private` 成员不会被继承。
- `public` 和 `protected` 成员会被继承，并且在子类中是可访问的。
- 默认（package-private）成员会被继承，但只在同一个包中的子类中是可访问的。



**final 关键字**

如果一个类用 `final` 关键字标记，那么它不能被继承。

```
public final class ImmutableClass {
    // 代码
}
```

同样地，`final` 方法不能在子类中被覆盖。



**Object 类**

在 Java 中，所有类都是 `Object` 类的子类（直接或间接）。这意味着每个 Java 对象都有 `Object` 类的方法，如 `toString()`, `equals()`, `hashCode()` 等。



**抽象类和接口**

- **抽象类**: 定义了一些方法但没有完全实现的类。这些类通常包含抽象方法（没有实现的方法），子类必须提供实现。
- **接口**: 是一种完全抽象的类，它只定义（而不实现）方法。Java 支持多接口继承。



#### Java多线程的实现

在Java中，多线程主要可以通过以下几种方式实现：

**1. 继承 `Thread` 类**

你可以创建一个新类，继承自 `Thread` 类，并重写 `run()` 方法。然后通过创建该类的实例并调用其 `start()` 方法来创建并启动新线程。

```
class MyThread extends Thread {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

**2. 实现 `Runnable` 接口**

你也可以通过实现 `Runnable` 接口来创建多线程。这种方法更为灵活，因为Java不支持多重继承，所以实现接口是一种更好的选择。

```
class MyRunnable implements Runnable {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
```

**3. 使用 `Executor` 框架**

Java的 `java.util.concurrent` 包提供了更高级的多线程支持，包括线程池。

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        executorService.execute(new MyRunnable());
        
        executorService.shutdown();
    }
}
```

**4. 使用 `Callable` 和 `Future`**

如果你需要获取线程执行完毕后的结果，可以使用 `Callable` 接口和 `Future` 类。

```
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Main {
    public static void main(String[] args) throws Exception {
        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "Hello, world!";
            }
        });

        new Thread(futureTask).start();
        
        String result = futureTask.get();
        System.out.println(result);
    }
}
```

注意事项：

1. **线程安全**：当多个线程共享资源时，需要注意线程安全问题。可以使用`synchronized`关键字或其他并发工具类进行同步。
2. **死锁**：避免多个线程相互等待资源，导致程序卡住。
3. **线程间通信**：`wait()`, `notify()`, `notifyAll()` 等方法可用于线程间的基本通信。

多线程编程通常涉及更多复杂的概念，例如线程局部存储、线程优先级、守护线程等。但上述几种方法是最基本和最常用的多线程实现方式。



#### 覆盖（Override）和重载（Overload）

`覆盖（Override）` 和 `重载（Overload）` 是 Java 中两个非常重要的概念，它们在形式和目的上有明显的不同。下面详细解释它们之间的主要区别。

**覆盖（Override）**

1. **定义**: 子类提供了一个与父类方法签名（方法名和参数类型）完全相同的方法。

2. **目的**: 为了改变继承自父类的同名方法的行为。

3. **修饰符**: 必须与父类方法的修饰符相同或更为宽松。例如，如果父类方法是 `protected`，则子类覆盖的方法可以是 `protected` 或 `public`。

4. **返回类型**: 必须与父类方法的返回类型相同或是其子类型。

5. **抛出异常**: 子类覆盖的方法所抛出的异常应该是被父类抛出异常的子集。

6. **运行时行为**: Java 使用运行时多态性来选择要执行的方法版本，即它执行的是对象实际类的方法版本。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal sound");
       }
   }
   
   class Dog extends Animal {
       @Override  // 这个注解是可选的，但有助于编译器检查
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   ```



**重载（Overload）**

1. **定义**: 在同一个类中定义一个与已有方法名相同但参数列表不同的方法。

2. **目的**: 让同一个方法可以有不同类型或数量的参数。

3. **修饰符**: 可以与已有的重载方法有不同的访问修饰符。

4. **返回类型**: 可以与已有的重载方法有不同的返回类型。

5. **抛出异常**: 可以与已有的重载方法有不同的异常抛出列表。

6. **编译时行为**: Java 使用编译时多态性来解析应该调用哪个方法。

   ```
   public class Calculator {
       public int add(int a, int b) {
           return a + b;
       }
   
       public double add(double a, double b) {
           return a + b;
       }
   }
   ```



**主要区别总结**

|                 | 覆盖（Override）           | 重载（Overload）         |
| --------------- | -------------------------- | ------------------------ |
| 方法签名        | 必须与父类相同             | 必须与同类中其他方法不同 |
| 返回类型        | 与父类相同或是其子类型     | 可以不同                 |
| 修饰符          | 不能比父类更严格           | 可以不同                 |
| 所在类          | 子类                       | 同一个类                 |
| 抛出的异常      | 只能是父类异常的子集或相同 | 可以不同                 |
| 运行/编译时行为 | 运行时多态                 | 编译时多态               |

这两个概念在 Java 中是非常基础和重要的，正确理解和使用它们可以使代码更为灵活和可维护。



#### 守护线程和非守护线程

守护线程（Daemon Thread）和非守护线程（Non-daemon Thread）是编程中多线程概念的一部分，特别是在Java和Python这样的编程语言中比较常见。这两种线程的主要区别在于程序是否等待它们执行完成。

**守护线程（Daemon Thread）**

1. **生命周期**：守护线程是一种在后台运行的线程，主要用于执行那些不应阻止程序退出的任务。
2. **程序退出**：一旦程序中所有的非守护线程都结束了，守护线程将被自动终止，即使它们没有完成执行。
3. **用例**：常见的例子包括垃圾回收、日志服务等。

**非守护线程（Non-daemon Thread）**

1. **生命周期**：非守护线程是程序的主要工作线程，用于执行核心任务。
2. **程序退出**：程序会等待所有的非守护线程执行完毕才会退出。
3. **用例**：主程序逻辑、用户交互等。



### 动态分配与静态分配

#### 动态分配

动态分配（Dynamic Allocation）是一种在程序运行时（而非编译时）分配内存空间的方法。这与静态分配相对，静态分配是在程序编译时就确定了内存的大小。动态分配的主要优点是它允许程序更灵活地使用内存，适应不同的数据规模和运行环境。

**为什么需要动态分配？**

在很多情况下，你可能无法预先知道需要多少内存。例如：

1. 当你从文件或网络中读取数据时，数据的大小可能是不确定的。
2. 当你实现数据结构（如链表、树、图等）时，元素的数量可能会动态变化。

在这些情况下，动态分配允许你根据需要分配或释放内存，使得内存使用更为高效。

**如何进行动态分配？**

不同的编程语言提供了不同的机制来进行动态内存分配。

1. C/C++

   : 使用 

   ```
   malloc()
   ```

   , 

   ```
   calloc()
   ```

   , 

   ```
   realloc()
   ```

    和 

   ```
   free()
   ```

    等函数进行内存的动态分配和释放。

   ```
   cCopy codeint *arr = (int*) malloc(10 * sizeof(int)); // 分配一个大小为 10 的整数数组
   free(arr); // 释放内存
   ```

2. Java

   : 使用 

   ```
   new
   ```

    关键字进行对象的动态分配。

   ```
   javaCopy code
   int[] arr = new int[10]; // 分配一个大小为 10 的整数数组
   ```

3. Python

   : 动态分配是自动进行的，你只需创建新的对象即可。

   ```
   pythonCopy code
   arr = [None] * 10  # 分配一个大小为 10 的列表
   ```

4. JavaScript

   : 同样自动进行，通常通过字面量或构造函数来创建对象。

   ```
   javascriptCopy code
   const arr = new Array(10);  // 分配一个大小为 10 的数组
   ```

**内存管理和泄漏**

动态分配的内存必须谨慎管理。在一些低级语言（如 C/C++）中，你需要手动释放不再使用的内存，否则会导致内存泄漏。而在一些高级语言（如 Java、Python）中，垃圾回收机制会自动释放不再使用的内存。

#### 静态分配

静态分配是在编译时分配内存的一种方式。这意味着当程序被编译时，内存的大小和位置就已经确定了，无法在程序运行时改变。下面是几个静态分配的例子：

**C/C++ 中的静态数组**

```
cCopy code
int arr[10]; // 分配一个大小为 10 的整数数组，其大小在编译时确定。
```

**Java 中的基础数据类型**

```
javaCopy code
int a; // 在栈上分配一个整数变量，大小和位置在编译时确定。
```

**Python 中的不可变数据类型**

虽然 Python 主要依赖动态分配，但不可变数据类型（如元组和字符串）一旦创建就不能更改，因此可以看作是静态分配的一种。

```
pythonCopy code
t = (1, 2, 3)  # 元组一旦创建，其大小和内容就不能更改。
```

**全局和静态变量**

全局变量和静态变量（在 C/C++ 中使用 `static` 关键字定义）也是静态分配的例子。它们在程序的生命周期内一直存在，不会被动态地创建或销毁。

```
cCopy code
static int x;  // 静态变量，其生命周期在整个程序执行期间。
```

**常量**

常量是在编译时就确定其值的变量，因此它们也是静态分配的。

```
javaCopy code
final int MAX_VALUE = 100;  // 常量，其值在编译时就确定。
```

**结构体和类的静态成员（C++）**

在 C++ 中，类或结构体的静态成员变量也是静态分配的。

```
c++Copy codeclass MyClass {
public:
    static int staticVar;  // 静态成员变量，其生命周期在整个程序执行期间。
};
```