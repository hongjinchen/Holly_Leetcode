





# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）**: 单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

   在单例模式的实现中，通常会：

   1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
   2. 创建一个私有静态成员变量，用于保存单一实例。
   3. 提供一个公共静态方法来获取这个唯一的实例。

2. **工厂方法模式（Factory Method）**: 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个接口用于创建对象，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

   工厂方法模式主要包括以下几个组件：

   1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
   2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
   3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
   4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

   如何实现

   1. **定义一个返回对象（Product）的工厂接口（Creator）**。
   2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
   3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

   ```python
   from abc import ABC, abstractmethod
   
   # Product 类
   class Button(ABC):
   
       @abstractmethod
       def click(self):
           pass
   
   # ConcreteProduct 类
   class WindowsButton(Button):
       
       def click(self):
           print("Windows button clicked")
   
   class LinuxButton(Button):
       
       def click(self):
           print("Linux button clicked")
   
   # Creator 类
   class ButtonFactory(ABC):
       
       @abstractmethod
       def create_button(self):
           pass
   
   # ConcreteCreator 类
   class WindowsButtonFactory(ButtonFactory):
       
       def create_button(self):
           return WindowsButton()
   
   class LinuxButtonFactory(ButtonFactory):
       
       def create_button(self):
           return LinuxButton()
   
   # 客户端代码
   def button_client_code(factory):
       button = factory.create_button()
       button.click()
   
   # 使用
   windows_factory = WindowsButtonFactory()
   button_client_code(windows_factory)
   
   linux_factory = LinuxButtonFactory()
   button_client_code(linux_factory)
   
   ```

   

3. **抽象工厂模式（Abstract Factory）**: 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

   **结构和组件**

   1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

   2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

   3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

   4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

      

      1. **定义抽象产品的接口（AbstractProduct）**。

      2. **创建实现该接口的具体产品（ConcreteProduct）**。

      3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

      4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

      5. **使用具体工厂和抽象工厂来创建产品实例**。

         

      ```python
      from abc import ABC, abstractmethod
      
      # 抽象产品
      class Button(ABC):
          @abstractmethod
          def click(self):
              pass
      
      class Checkbox(ABC):
          @abstractmethod
          def check(self):
              pass
      
      # 具体产品
      class WindowsButton(Button):
          def click(self):
              print("Windows Button clicked")
      
      class WindowsCheckbox(Checkbox):
          def check(self):
              print("Windows Checkbox checked")
      
      class LinuxButton(Button):
          def click(self):
              print("Linux Button clicked")
      
      class LinuxCheckbox(Checkbox):
          def check(self):
              print("Linux Checkbox checked")
      
      # 抽象工厂
      class GUIFactory(ABC):
          @abstractmethod
          def create_button(self):
              pass
      
          @abstractmethod
          def create_checkbox(self):
              pass
      
      # 具体工厂
      class WindowsGUIFactory(GUIFactory):
          def create_button(self):
              return WindowsButton()
      
          def create_checkbox(self):
              return WindowsCheckbox()
      
      class LinuxGUIFactory(GUIFactory):
          def create_button(self):
              return LinuxButton()
      
          def create_checkbox(self):
              return LinuxCheckbox()
      
      # 客户端代码
      def client_code(factory):
          button = factory.create_button()
          checkbox = factory.create_checkbox()
          
          button.click()
          checkbox.check()
      
      # 使用
      windows_factory = WindowsGUIFactory()
      client_code(windows_factory)
      
      linux_factory = LinuxGUIFactory()
      client_code(linux_factory)
      
      ```

      

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

### 结构型模式（Structural Patterns）

1. **适配器模式（Adapter）**: 允许不兼容的接口可以一起工作。
2. **装饰器模式（Decorator）**: 在不改变对象本身的基础上，动态地添加额外的功能。
3. **组合模式（Composite）**: 将对象组合成树形结构以表示“部分-整体”的层次结构。

### 行为型模式（Behavioral Patterns）

1. **观察者模式（Observer）**: 当一个对象的状态发生变化时，其依赖者都会得到通知。
2. **策略模式（Strategy）**: 定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。
3. **命令模式（Command）**: 将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。





## 美团面试真题

### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）





### 如果需要访问多个域名，那么可以如何节省网络消耗？

**DNS预解析（DNS Prefetch）**

预解析可以预先进行DNS查询，减少实际请求时的DNS解析时间。

```
<link rel="dns-prefetch" href="//example.com">
```

**预连接（Preconnect）**

预连接不仅会预解析DNS，还会预先进行TCP握手和TLS协商。

```
<link rel="preconnect" href="https://example.com">
```

**数据压缩**

使用Gzip或Brotli等压缩算法可以减少传输的数据量。

**使用HTTP/2或HTTP/3**

这些新版本的HTTP协议提供了多路复用、头部压缩等特性，可以减少网络消耗。

**使用持久连接（Keep-Alive）**

通过复用TCP连接，你可以减少TCP握手所需的时间和带宽。

**优化资源**

- **合并文件**：将多个小的CSS或JavaScript文件合并为一个大文件，以减少HTTP请求的数量。
- **异步加载**：对于非关键资源，可以使用异步加载来减少初始页面加载所需的时间。
- **懒加载**：对于例如图片这样的大资源，使用懒加载可以延迟加载直到用户实际需要。

**缓存**

充分利用浏览器缓存和服务器缓存可以减少重复请求，从而减少网络消耗。

**限制重定向**

尽量减少或避免使用重定向，因为每次重定向都会消耗额外的网络资源。



### 对测试开发的理解以及他们日常会做什么工作

测试开发（Test Development 或 Test Automation Development）是软件测试的一个子领域，专注于通过编程来自动化测试过程。测试开发不仅涉及编写自动化测试脚本，还包括设计和维护自动化测试框架、与开发团队紧密合作以提高软件质量，以及参与持续集成（CI）和持续交付（CD）流程。下面详细地介绍一下测试开发的一些核心职责和他们日常可能会做的工作。

**核心职责**

1. **自动化测试脚本编写**：使用编程语言（如 Python、Java 等）和自动化测试工具（如 Selenium、Appium、Junit 等）来编写测试脚本。
2. **测试框架设计与维护**：设计和建立自动化测试框架，以便更容易、更快捷地编写和运行测试脚本。
3. **测试用例设计**：与需求分析师、产品经理和开发人员合作，理解新功能或改动，然后设计相应的测试用例。
4. **持续集成与持续交付（CI/CD）**：将自动化测试脚本融入CI/CD管道，确保每次代码更改都能自动触发相关测试。
5. **代码审查与质量保证**：参与代码审查，以确保测试代码质量；同时也关注产品代码，帮助开发人员提高代码质量。
6. **性能测试**：使用工具如 JMeter 进行性能、压力和负载测试。
7. **文档编写与维护**：编写测试报告和文档，以记录测试计划、测试用例和测试结果。

**日常工作流程**

1. **需求分析**：在一个迭代或开发周期开始时，与团队成员一起了解即将开发或修改的功能。
2. **测试计划与用例设计**：根据需求分析结果，制定测试计划并设计测试用例。
3. **环境准备**：设置和维护测试环境，包括数据准备、服务器配置等。
4. **编写与调试测试代码**：按照测试用例编写自动化测试脚本，并进行调试。
5. **执行测试**：运行测试脚本，手动或自动地执行测试用例。
6. **结果分析与报告**：分析测试结果，找出问题并编写测试报告。
7. **缺陷跟踪与修复**：与开发人员一起跟踪和修复在测试中发现的缺陷。
8. **代码提交与CI/CD**：将测试代码提交到版本控制系统，并确保它被纳入CI/CD流程。
9. **回归测试与维护**：在软件发布后，进行回归测试以确保新添加或修改的代码没有引入新的问题。



### 为什么选择测试开发

自我追求部分

能力匹配部分



1. 技术层面

**全面的技术观点:** 测试开发不仅涉及到测试，还需**理解软件的开发过程**，这为**深入了解整个系统**提供了机会。

**自动化与编程**: 现代测试开发大量依赖自动化，这也意味着有很多编程工作，对于喜欢编程的人来说是个好选择。

2. 问题解决

侦查与调查: **良好的测试能够发现隐藏的问题**，这需要扎实的问题解决能力。

质量保证: 你的工作直接**影响产品质量**，这是个相当有成就感的工作。

6. 学习与成长

- 不断学习: 软件工具和方法论不断更新，需要持续学习。
- 多元化的挑战: **测试开发会接触到多种类型的项目和问题**，这有助于个人成长



### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。



### 内存泄漏

内存泄漏（Memory Leak）是一个编程问题，出现在一个程序分配了内存但未能释放，即使它不再使用这些内存。这会导致程序运行时占用越来越多的内存资源，可能最终导致系统资源枯竭，程序崩溃或性能下降。以下是内存泄漏的一些主要特点和影响：

**主要特点：**

1. **持续增长**: 内存泄漏通常导致程序的内存使用持续增长。
2. **难以检测**: 尤其在大型、复杂的程序中，内存泄漏可能很难发现。
3. **长时间运行问题**: 在短时间内，内存泄漏可能不会立即导致问题，但在长时间运行的程序（如服务器）中，它们可以成为一个严重问题。

**影响：**

1. **性能下降**: 随着内存使用量的增加，操作系统可能需要使用虚拟内存（硬盘），从而导致性能下降。
2. **资源枯竭**: 在极端情况下，内存泄漏可能导致可用内存完全耗尽，从而导致其他程序或整个系统崩溃。
3. **系统不稳定**: 由于资源的不断耗尽，可能导致系统运行不稳定。

**如何检测：**

1. **手动检查代码**: 通过仔细阅读和理解代码来识别潜在的内存泄漏。
2. **静态代码分析**: 使用静态代码分析工具来识别常见的模式和潜在的内存泄漏。
3. **动态分析工具**: 如 Valgrind、Instruments 或专用的内存分析库。
4. **运行时监控**: 使用性能监控工具来观察程序的内存使用情况。

**如何解决：**

1. **垃圾回收**: 在支持自动垃圾回收的编程语言（如 Java, Python）中，内存泄漏通常较少出现，但仍然可能。
2. **手动内存管理**: 在需要手动管理内存的编程语言（如 C/C++）中，开发者需要更加谨慎地分配和释放内存。
3. **使用智能指针**: 在C++11及以后版本中，可以使用智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）来自动管理内存。
4. **代码重构**: 识别和修改导致内存泄漏的代码部分。



### OSI七层协议

OSI（Open Systems Interconnection）模型是一个概念框架，用于标准化网络协议的不同功能层。该模型将网络协议分为七个不同的层次，以促进不同协议和设备间的互操作性。下面是各层的概述：

1. **物理层（Physical Layer）**: 这一层主要处理与物理媒体相关的细节，比如电缆、交换机、网卡等。主要任务是数据比特流（bits）的传输。
2. **数据链路层（Data Link Layer）**: 在物理层之上，数据链路层负责创建一个可靠的链路连接，主要负责 MAC（Media Access Control） 地址和帧的封装与解封装。
3. **网络层（Network Layer）**: 这一层负责数据包的路由和传输，即如何从源到目的地。**IP 协议**就工作在这一层。
4. **传输层（Transport Layer）**: 主要负责端到端（End-to-End）的数据传输和流量控制。**TCP 和 UDP 协议**就工作在这一层。
5. **会话层（Session Layer）**: 该层负责在数据传输中设置和维护会话。
6. **表示层（Presentation Layer）**: 主要负责数据格式的转换或加密。例如，将 EBCDIC 编码转换为 ASCII 编码。
7. **应用层（Application Layer）**: 这一层负责处理特定的应用程序细节。常见的应用层协议包括 **HTTP、FTP、SMTP** 等。

**TCP 和 HTTP 分别属于哪一层？**

- **TCP（Transmission Control Protocol）**: 通常被认为是传输层的一部分。它负责提供可靠、顺序的点对点通信。

- **HTTP（HyperText Transfer Protocol）**: 是应用层的一部分。它定义了客户端和服务器之间如何传送超文本数据。

  

### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。





### 动态分配与静态分配

#### 动态分配

动态分配（Dynamic Allocation）是一种在程序运行时（而非编译时）分配内存空间的方法。这与静态分配相对，静态分配是在程序编译时就确定了内存的大小。动态分配的主要优点是它允许程序更灵活地使用内存，适应不同的数据规模和运行环境。

**为什么需要动态分配？**

在很多情况下，你可能无法预先知道需要多少内存。例如：

1. 当你从文件或网络中读取数据时，数据的大小可能是不确定的。
2. 当你实现数据结构（如链表、树、图等）时，元素的数量可能会动态变化。

在这些情况下，动态分配允许你根据需要分配或释放内存，使得内存使用更为高效。

**如何进行动态分配？**

不同的编程语言提供了不同的机制来进行动态内存分配。

1. C/C++

   : 使用 

   ```
   malloc()
   ```

   , 

   ```
   calloc()
   ```

   , 

   ```
   realloc()
   ```

    和 

   ```
   free()
   ```

    等函数进行内存的动态分配和释放。

   ```
   cCopy codeint *arr = (int*) malloc(10 * sizeof(int)); // 分配一个大小为 10 的整数数组
   free(arr); // 释放内存
   ```

2. Java

   : 使用 

   ```
   new
   ```

    关键字进行对象的动态分配。

   ```
   
   int[] arr = new int[10]; // 分配一个大小为 10 的整数数组
   ```

3. Python

   : 动态分配是自动进行的，你只需创建新的对象即可。

   ```
   
   arr = [None] * 10  # 分配一个大小为 10 的列表
   ```

4. JavaScript

   : 同样自动进行，通常通过字面量或构造函数来创建对象。

   ```
   
   const arr = new Array(10);  // 分配一个大小为 10 的数组
   ```

**内存管理和泄漏**

动态分配的内存必须谨慎管理。在一些低级语言（如 C/C++）中，你需要手动释放不再使用的内存，否则会导致内存泄漏。而在一些高级语言（如 Java、Python）中，垃圾回收机制会自动释放不再使用的内存。

#### 静态分配

静态分配是在编译时分配内存的一种方式。这意味着当程序被编译时，内存的大小和位置就已经确定了，无法在程序运行时改变。下面是几个静态分配的例子：

**C/C++ 中的静态数组**

```

int arr[10]; // 分配一个大小为 10 的整数数组，其大小在编译时确定。
```

**Java 中的基础数据类型**

```

int a; // 在栈上分配一个整数变量，大小和位置在编译时确定。
```

**Python 中的不可变数据类型**

虽然 Python 主要依赖动态分配，但不可变数据类型（如元组和字符串）一旦创建就不能更改，因此可以看作是静态分配的一种。

```

t = (1, 2, 3)  # 元组一旦创建，其大小和内容就不能更改。
```

**全局和静态变量**

全局变量和静态变量（在 C/C++ 中使用 `static` 关键字定义）也是静态分配的例子。它们在程序的生命周期内一直存在，不会被动态地创建或销毁。

```

static int x;  // 静态变量，其生命周期在整个程序执行期间。
```

**常量**

常量是在编译时就确定其值的变量，因此它们也是静态分配的。

```

final int MAX_VALUE = 100;  // 常量，其值在编译时就确定。
```

**结构体和类的静态成员（C++）**

在 C++ 中，类或结构体的静态成员变量也是静态分配的。

```
class MyClass {
public:
    static int staticVar;  // 静态成员变量，其生命周期在整个程序执行期间。
};
```