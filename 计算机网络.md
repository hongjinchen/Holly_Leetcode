# 第一部分：计算机网络体系结构

因特网是极为复杂的系统,它包含大量的软件以及硬件系统,大量的应用程序和协议、各种类型的端系统、分组交换机,面对这种庞大且复杂的系统,将其化简分层是极其有必要的,分层的好处如下：

各层之间相互独立、相关隔离。每层只考虑当前层如何实现，无需考虑其他层
提高整体结构的灵活性，层次之间结构解耦合
大问题变小，复杂问题变简单

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024142013287.png" alt="image-20231024142013287" style="zoom:50%;" />

**本章高频面试题**

- 计算机网络为什么要分层？
- 计算机网络是怎么分层的？
- 三种计算机网络模型的关系是什么？每一层分别包含哪些协议？
- 计算机网络中，数据如何在各层中传播？数据在网络各层中的存在形式是怎么样的？



## OSI 七层模型

OSI(Open System Interconnection Reference Model) 模型是国际标准化组织 ISO（International Organization for Standardization) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。
OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。

- 应用层：通过应用程序间的交互来完成特定的网络应用
- 表示层：解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述。
- 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。
- 传输层：负责因特网中两台主机的进程提供通信服务。
- 网络层：选择合适的网间路由和交换节点，确保数据按时成功传送。
- 数据链路层(链路层)：数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
- 物理层：实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）





## TCP/IP 五层参考模型

五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。

- 应用层 ：为特定应用程序提供数据传输服务。

  **协议和工具**：

  - HTTP/HTTPS：用于 Web 浏览
  - FTP：文件传输
  - SMTP/POP3/IMAP：电子邮件
  - DNS：域名解析

  **实例**：Web 浏览器、邮件客户端等。

  

- 传输层 ：为进程提供通用数据传输服务。

  **协议和工具**：

  - TCP：提供可靠、面向连接的数据传输
  - UDP：提供不可靠、无连接的数据传输
  - SCTP：流控制传输协议

  **实例**：Windows 的 Winsock API，Linux 的 socket 编程。

  

- 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。

  **协议和工具**：

  - IP：互联网协议，用于寻址和路由
  - ICMP：用于发送错误消息和网络故障排除
  - OSPF：开放最短路径优先，一种路由协议

  **实例**：路由器、IP 地址、子网掩码

  

- 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。

  **协议和工具**：

  - Ethernet：最常用的局域网技术
  - Wi-Fi：无线局域网
  - PPP：点对点协议

  **实例**：交换机、网桥、MAC 地址。

  

- 物理层 ：负责比特流在传输介质上的传播。

  **工具和技术**：

  - RJ45 连接器：用于以太网
  - 光纤：用于高速数据传输
  - 调制/解调器：用于模拟信号的数字化

  **实例**：网线、网卡、集线器。

  

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024143257920.png" alt="image-20231024143257920" style="zoom:67%;" />

## 数据如何在各层直接传输

![image-20231024143950906](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024143950906.png)

假设一个主机上的一个应用向另一个主机的一个应用发送数据。

- 在发送**主机端**，一个**应用层报文**被传送到**传输层**。在最简单的情况下，传输层收取到报文并附上附加信息，该首部将被接收端的传输层使用。
- 用**层报文和传输层首部信息**一道构成了**传输层报文段**。附加的信息可能包括：允许接收端传输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。
- 传输层则向**网络层**传递该报文段，**网络层增加了如源和目的端系统地址等网络层首部信息**，生成了网络层数据报文。
- 该数据报文接下来被传递给**链路层**，在数据链路层数据包添加发送**端 MAC 地址和接收端 MAC 地址**后被封装成**数据帧**。
- 在物理层数据帧被封装成**比特流**，之后通过传输介质传送到对端。而在接收主机端，整个过程正好反过来。



## TCP四层协议

#### 1. 应用层（Application Layer）

- **作用**：负责提供网络服务的接口，以便最终用户和应用程序可以交互。
- **常用协议**：
  - HTTP（超文本传输协议）
  - FTP（文件传输协议）
  - SMTP（简单邮件传输协议）
  - DNS（域名系统）

#### 2. 传输层（Transport Layer）

- **作用**：负责端到端（即主机到主机）的数据传输和流量控制。它确保数据从源端到目的端可靠、有效地传输。
- **常用协议**：
  - TCP（传输控制协议）：提供可靠、面向连接的通信
  - UDP（用户数据报协议）：提供不可靠、无连接的通信

#### 3. 网络层（Network Layer）

- **作用**：负责将数据包从源主机路由到目的主机。这一过程可能涉及多个网络和连接多个网络设备（如路由器、交换机等）。
- **常用协议**：
  - IP（互联网协议）
  - ICMP（互联网控制消息协议）
  - OSPF（开放最短路径优先）

#### 4. 链路层（Link Layer）

- **作用**：负责将网络层传来的数据帧从一台机器传输到另一台机器，这通常是在同一局域网内或者在两台相邻网络设备之间。
- **常用协议/标准**：
  - Ethernet
  - Wi-Fi
  - ARP（地址解析协议）



# 第二部分：应用层

**本章高频面试题**

- uri 和 url 的区别 ？
- dns 是啥工作原理，主要解析过程是啥？
- 用户输入网址到显示对应页面的全过程是啥？
- http 头部包含哪些信息？
- http 方法了解哪些？
- http 状态码了解哪些？
- get 和 post 的区别？
- https 和 https 的区别？
- https 的加密方式？
- http 是不保存状态的协议,如何保存用户状态？
- http 不同版本的区别？

## 万维网和域名系统

万维网 `(WWW，World Wide Web)`，通常称为 `Web`，是一种信息系统，使文档和其他 `Web`资源能够通过 `Internet` 访问。

### 网络资源

网络上的资源必须有一个唯一的表示，才可以在网络上被访问。

uri(uniform resource identifier) 统一资源标识符。
url(uniform resource location) 统一资源定位符，统指绝对路径。
urn(uniform resource name) 统一资源名。

三者之间关系为， url 和 urn 分别是 URI 的子集 。

<img src="https://pic.leetcode.cn/1676185149-fdgRhJ-image-20230211152708228.png" alt="image-20230211152708228.png" style="zoom: 50%;" />

其中 URN 还处于实验阶段，未大范围进行使用，目前使用最多的是 url。url 由三部分组成。

方案，一般是访问资源使用的协议类型，比如http://、https://。
服务器的 web 地址，可以为域名或者 ip 地址 + 端口号，比如 localhost:8080 或者 127.0.0.1:8080。不添加默认为 80 ，这是访问域名不用加端口号的原因 。
web 服务器上的某个资源，比如leetbook/read/networks-interview-highlights。

注意： url是否以/结尾，意义是不同的，用户无感知的原因是因为服务器自动处理了这种差异。



### 应用程序体系架构

应用程序体系体系架构主要分为两种。

**C/S(client/server)** ：客户端之间不进行通信，客户端向服务端发送请求获取数据，服务器要一直开机，需要配备大量的数据中心。比如：微信，google，bing等等。
**P2P(peer to peer)** ：对等通信，不需要数据中心，没有客户端和服务端的区别，应用程序在间断连接的主机对之间直接通信。主要应用在流量密集型应用。比如：迅雷，bitTorrent，或者在局域网的文件内部共享应用中。
目前大型互联网应用主要采用的是 C/S 架构，导致 P2P 架构逐渐被人遗忘。 C/S 架构又可以细分为 C/S(client/server) 和 B/S(browser/server)，即根据客户端类型划分。

**本地客户端：**速度快，安全，灵活性较高，但是开发成本就高，比如游戏客户端。
**浏览器：**不需要安装，依托于浏览器，安全性较低，成本极低。

### `web`的结构组件

web 是极为复杂的，不仅只有 client 与 server 之间简单的请求响应 ，还包含了一些特殊的 **server** ，他们承担着一些特殊的作用。

**代理**：位于客户端和服务器之间的 http中间实体。

出于安全考虑，通常会将代理做为转发所有 Web 流量的可信任中间节点使用，可以对请求和响应进行过滤。比如，校园网中可以过滤一些不健康的内容，禁止学生进行访问。

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024152329210.png" alt="image-20231024152329210" style="zoom: 33%;" />

**网关**：连接其他应用程序的特殊 web 服务器。

做为其他服务器的中间实体使用。常用于将 http 流量转化为其他的协议。网关接受请求时就好像自己本身是资源源服务器一样，客户端对此无感知。

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024152343468.png" alt="image-20231024152343468" style="zoom: 33%;" />



**隧道**： 对 http通信报文进行盲转发的特殊代理。

对两条连接之间的数据进行盲转发，https就是通过隧道实现的。http连接承载加密的安全套接字层`(ssl,secure sockets layer)流量，这样 ssl 流量就可以直接穿过只允许 web 流量通过防火墙，反正亦然。

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024153519458.png" alt="image-20231024153519458" style="zoom: 50%;" />



**代理服务器在 Web 网站中的可能作用：**

1. **内容缓存**：代理服务器可以缓存来自 Web 服务器的响应数据，当其他用户请求相同的内容时，直接从缓存中提供，减少了 Web 服务器的负担。
2. **访问控制**：代理服务器可以限制哪些 IP 地址可以或不能访问特定的 Web 资源。
3. **负载均衡**：代理服务器可以将进入的请求分配到多个后端服务器，以分散负载。

**网关在 Web 网站中的可能作用：**

1. **API 网关**：在微服务架构中，API 网关作为前端和多个微服务之间的接口，负责请求的路由、组合和转换。
2. **安全网关**：可以作为防火墙的一部分，阻止某些类型的攻击，如 SQL 注入和跨站脚本（XSS）。

假设你有一个电商网站，后端由多个微服务组成：用户服务、订单服务、库存服务等。

- **代理服务器**：当用户浏览商品时，代理服务器从库存服务获取数据并将其缓存。下一个用户查询相同的商品时，代理服务器直接从缓存提供数据，减少了实际的服务请求。
- **API 网关**：当用户下订单时，前端通过 API 网关发送一个请求。网关收到请求后，首先查询用户服务验证用户身份，然后将订单数据路由到订单服务，并且检查库存服务以确认商品可用性。

这样，代理服务器和 API 网关各自扮演了非常重要的角色，优化了性能，提高了安全性，简化了前端与各个微服务之间的交互。



### `dns`域名系统

域名系统 (dns,domain name system) 是 Internet 或其他 Internet 协议（ip） 网络中计算机、服务和其他资源的分层分布式命名系统。它将各种信息与分配给每个关联实体的域名相关联。最重要的是，它将容易记忆的域名转换为数字ip地址，用于定位和识别具有底层网络协议的计算机服务和设备。

**dns的作用**
在dns 出现之前，互联网中某台主机的唯一标识是这台机器的 ip 地址，但是这种方式记起来很麻烦，人们更喜欢便于记忆的名称。为了解决这个问题，人们需要一种从主机名称到 ip 地址转换的服务，域名系统作为将域名和 ip 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。

小提示：dns域名支持中文字符

**dns 服务器的结构**
dns域名的结构是 xxx.xxx.xxx，是分层的。分为顶级域名（一级域名），二级域名，三级域名 . . . . .

顶级域名会根据国家地区，或者组织进行划分,比如cn（代表中国）、edu（代表教育组织）。二级域名就是在顶级域名前面加前缀,比如 leetcode.cn。也正因为如此，dns服务器的结构是树状的。

**域名以及服务器结构**

![image-20231024154234714](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231024154234714.png)

**顶级域名、一级域名**

　　Top-level domains，first-level domains（TLDs），也翻译为国际顶级域名，也成一级域名。

　　.com 供商业机构使用，但无限制最常用
　　.net 原供网络服务供应商使用，现无限制
　　.org 原供不属于其他通用顶级域类别的组织使用，现无限制
　　.edu / .gov / .mil 供美国教育机构/美国政府机关/美国军事机构。因历史遗留问题一般只在美国专用
　　.aero 供航空运输业使用
　　.biz 供商业使用
　　.coop 供联合会（cooperatives）使用
　　.info 供信息性网站使用，但无限制
　　.museum 供博物馆使用
　　.name 供家庭及个人使用
　　.pro 供部分专业使用
　　.asia 供亚洲社区使用
　　.tel 供连接电话网络与因特网的服务使用
　　.post 供邮政服务使用
　　.mail 供邮件网站使用
　　国家顶级域名：cn（中国大陆）、de（德国）、eu（欧盟）、jp（日本）、hk（中国香港）、tw（中国台湾）、uk（英国）、us（美国）



**二级域名**

　　二级域（或称二级域名；英语：Second-level domain；英文缩写：SLD）是互联网DNS等级之中，处于顶级域名之下的域。二级域名是域名的倒数第二个部分，例如在域名example.baidu.com中，二级域名是Baidu。

　　.com 顶级域名/一级域名，更准确的说叫顶级域

　　baidu.com 二级域名，更准确的说叫二级域

　　tieba.baidu.com 三级域名，更准确的说叫三级域

　　detail.tieba.baidu.com 四级域名，更准确的说叫四级域



**子域名**

　　子域名（或子域；英语：Subdomain）是在域名系统等级中，属于更高一层域的域。比如，mail.example.com和calendar.example.com是example.com的两个子域，而example.com则是顶级域.com的子域。凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域名。



**准确理解一级域名**

![img](https://img2018.cnblogs.com/blog/955092/201912/955092-20191203101440732-1723526319.jpg)

　　通常我们把.com成为一级域名，但严格意义上这样讲不太准确，真正的一级域名是由一个合法的字符串+域名后缀组成，所以，guanghe.com这种形式的域名才是一级域名，guanghe是域名主体，.com是域名后缀，我们也可以把.com也称为顶级域。

　　*一级域名又称为顶级域名，比如单独的gunaghe.com如果指向一个ip，这个域名就是一级域名。但需要注意的是，www.guanghe.com这种形式的域名并不是一级域名，它只是一个二级域名，也就是说www只是一个主机名。*

### dns 的原理

以一个例子来了解 dns 的工作原理。

假设一个客户端 A，想要查询 a.leetcode.cn 的 ip 地址，考虑**缓存**的情况。

客户端 A 首先查询本地的 **hosts** 文件，查询是否有网址映射关系，如果没有，进行下一步查找。
查找本地的 dns 解析器缓存，如果没有进行下一步。
根据 tcp/ip 参数查找设置好的首选 dns 服务器 ip 地址，一般叫做本地 dns 服务器，查询本地 dns 服务器。本地 dns 服务器如果没有，它就会进行下一步操作。
本地dns会访问根服务器 ，然后根据后缀名，从根服务器中查找对应的顶级域名服务器的 ip ，然后以此向下查找域名服务器的 ip ，然后查找网址映射关系,直到找到为止。

<img src="https://pic.leetcode.cn/1676185377-UniHCX-image-20230212134234075.png" alt="image-20230212134234075.png" style="zoom:50%;" />

> 客户端 A 向本地域名服务器查询为递归查询，本地域名服务器向根域名服务器查询为迭代查询。
>
> **递归查询（Recursive Query）**
>
> 1. **全权负责**: 在递归查询中，客户端向本地域名服务器（通常是ISP提供的DNS服务器或企业内部的DNS服务器）发出查询请求后，该服务器负责完成整个查询过程。它会一步步从根域名服务器开始，找到负责特定域名的权威服务器，直至获得最终的IP地址。
> 2. **一对一关系**: 客户端只与本地域名服务器进行交互，不需要知道其他服务器的信息。
> 3. **响应时间**: 通常来说，递归查询可能需要更多的时间，因为本地域名服务器需要与多个外部服务器进行通信。
> 4. **缓存**: 为了提高效率，本地域名服务器会缓存查询结果。下次相同的查询来临时，可以直接从缓存中获取答案，而无需再进行完整的递归查询。
>
> **迭代查询（Iterative Query）**
>
> 1. **逐步解析**: 在迭代查询中，本地域名服务器向根域名服务器发出查询后，根服务器会返回一个指向下一级域名服务器的引用。然后本地域名服务器会向这个下一级服务器发出查询，如此反复，直到找到负责特定域名的权威服务器。
> 2. **多对多关系**: 本地域名服务器需要与多个其他域名服务器进行交互。
> 3. **服务器负担**: 由于每个服务器只负责解析自己管理的域名信息，因此相对于递归查询，迭代查询减轻了各个服务器的负担。
> 4. **无缓存**: 在迭代查询过程中，除非本地域名服务器自己决定缓存某些信息，否则通常不会进行缓存。
>
> **总结**
>
> - 递归查询通常用于客户端和本地域名服务器之间的交互，因为客户端希望简单地获取一个答案。
> - 迭代查询通常用于域名系统内部各个服务器之间的交互，以减轻单个服务器的负担并提高整体效率。



### dns 数据传输

dns 的数据传输是采用 tcp 协议还是 udp 协议 ，或者是其他的什么协议 ？

dns 既采用 udp 协议也采用 tcp 协议:

dns 是通过 53 端口进行通信，默认是采用 udp 协议进行数据传输的，除了个别情况，也就是说绝大多数情况是采用 udp 进行传输。
使用 tcp 传输的情况:
当返回的响应超过的 512 字节（ udp 最大只支持 512 字节的数据）。
区域传送：主域名服务器向辅助域名服务器传送变化的那部分数据。
注意: tcp 协议和 tcp 协议是可以同时绑定同一个端口的。
区域传输: dns 服务器中数据不总是一成不变的，域名数量是不断增加，而且一些域名对应着的服务器的也是在变化的，所以其实 dns 服务器中的数据是不断增加的，并且随时流动的，所以可以将区域传输简单理解为 dns 服务器之间进行的数据传输。



### dns 域名服务器名称概念

根域名服务器：最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的ip地址，全球有 13 个根域名服务器。

顶级域名服务器：负责处理所有顶级域名，提供到权威域服务器的映射。

授权(权威)域名服务器：提供主机名到 IP 地址间的映射服务

主域名服务器：一个或多个区域域名解析工作的主要域名服务器，通常也是一个或多个区域的授权域名服务器。

辅助域名服务器：协助主域名服务器提供域名查询服务，在主机很多的情况下，可以有效分担主域名服务器的压力。当主域名服务器故障时，辅助域名服务器能够在数据有效期内继续为主机提供域名解析服务。



## HTTP

### HTTP报文结构

第一部分简略信息，包含请求方法、url 和协议版本；或者协议版本和状态码
第二部分为请求首部 Header 或者响应首部 Header;
第三部分为内容主体

```html
// 第一部分：简略信息
GET https://leetcode.cn/problemset/all/ HTTP/1.1.  
// 第二部分：请求首部或者响应首部
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: leetcode.cn
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx
// --------- 空行 --------------
// 第三部分，内容主体
param1=1&param2=2。
```

### http 请求方法

![image.png](https://pic.leetcode.cn/1676723681-NvPiMa-image.png)

http 请求方法是为了服务器功能实现起来更方便，但不意味着每种特定的方法只能实现某种特定的功能。http 方法设计较为灵活，方法本身虽然有一些规则，但是最重要的还是开发者如何开发设计，正因为如此，不同的浏览器和不同的服务器会有一些限制，但是这和 http 方法关系不大。比如：

- 有些服务器不支持**get** 方法设置 **body**，对于这种服务器，get 方法通常是通过以 **url** 的 **parameters** 或者 Anchor 进行传递数据的

![image-20230212181050545.png](https://pic.leetcode.cn/1676723874-JxlETu-image-20230212181050545.png)

也就是说 get 方法传递数据的大小和 url 的长度直接相关，url 本身并没有对长度进行限制，但是*浏览器会对 url 进行限制*，比如 FireFox 限制 url 的最大长度为 65536 个字符，也就是 64KB的大小，而 Chrome 限制 url 最大长度为 8182个字符，也就是 8 KB 的大小。

- **post** 方法向服务器发送数据是通过 **body** ，post 方法本身对 body 的大小也没有限制，但是不同的服务器处理的能力是不同的，较为强大的服务器可以接收几十 GB 的数据，而一些服务器最多只能接收几十 MB 的数据。

- **get 和 post 的差别**

  get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。

  - get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
  - post 可以进行复杂的加密，get 则不可以
  - get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。
  - get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制

> 注意：http有安全方法的概念，即不改变服务器状态。 get 方法不会改变服务器状态，而 post 会改变服务器的状态，从这个角度来看，get方法更安全。
> **总结：get 方法对于服务器更安全，post 方法对于客户端更安全.**



get 方法具有幂等性，post 方法不具有。

> 幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

post方法有时会发送两个 tcp 数据包，与浏览器有关，使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。

而 GET 方法 Header 和 Data 会一起发送。

> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。
>
> 

### http状态码

![image-20231027225721306](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027225721306.png)

200：成功返回响应
301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。
302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。
400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。
401：没有权限访问，当前用户没有权限访问此资源。
403: 请求被服务器禁止。
404：请求的 url 不存在，一般是 url 出错。
500： 服务器处理请求出现错误。
501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。
504：来自网关或者代理服务器，请求资源服务器时超时。
http状态码目录：https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

> 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
>
> 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
>
> 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
>
> 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
>
> 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
>
> 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
>
> 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
>
> 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
>
> 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
>
> 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
>
> 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
>
> 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
>
> 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
>
> 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
>
> 5xx 状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
>
> 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
>
> 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
>
> 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
>
> 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### http 首部

HTTP（HyperText Transfer Protocol，超文本传输协议）首部（也称为HTTP头或Header）是HTTP消息（请求和响应）中的一部分，用于携带关于消息的元信息。HTTP首部字段用键值对的形式来表示，并且每个首部字段都以一个换行符（CRLF，即\r\n）结束。

HTTP首部分为请求首部和响应首部，但还有一些通用首部和实体首部，它们可以用在请求和响应消息中。

http 主要有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。除此之外，还有一种扩展首部，该种首部还未添加的 http 标准中去。在一些大型互联网公司内部，开发者需要特定的扩展首部来实现特殊的功能。

- 通用首部字段：请求和响应都可以使用的首部，与报文相关的最基本的信息。
- 请求首部字段：仅在请求中使用的首部。
- 响应首部字段：仅在响应中使用的首部。
- 实体首部字段：用于应对实体部分的首部，一般是对实体内容进行说明。

**常用的首部**

通用首部

![image.png](https://pic.leetcode.cn/1676724346-JGUnBZ-image.png)

请求首部

![image.png](https://pic.leetcode.cn/1676724362-SUzXoa-image.png)

响应首部

![image.png](https://pic.leetcode.cn/1676724394-lwmZON-image.png)

实体首部

![image.png](https://pic.leetcode.cn/1676724405-zuVLpB-image.png)


http请求首部目录：https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers

**举例**

一个简单的HTTP请求和响应，包含首部字段，可能如下所示：

**HTTP请求**

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**HTTP响应**

```
HTTP/1.1 200 OK
Date: Wed, 21 Oct 2015 07:28:00 GMT
Server: Apache
Content-Length: 438
Content-Type: text/html
```



###  具体应用

#### 连接管理

**短连接与长连接**
当客户端访问一个包含多媒体资源的 html 页面时，除了请求访问的 html 页面资源，还会请求访问多媒体资源。这个过程中需要发送很多个 http 请求，如果每进行一次 http 通信就要新建一个 tcp 连接，对于客户度和服务器的压力是很大的。
长连接只需要建立一次 tcp 连接就能进行多次 http 通信，短连接每个 http请求就要建立一次 tcp 连接。
从 http/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，首部为 Connection : close；
在 http/1.1 之前默认是短连接的，如果需要使用长连接。首部为 Connection : Keep-Alive。

**流水线**
默认情况下，http 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间，而流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样 http 的速度会快很多，tcp 连接的利用率也会非常高。

在不使用流水线的情况下，每个HTTP请求都要等待前一个请求的响应才能继续。也就是说，客户端发送一个请求到服务器，并等待服务器响应，然后再发送下一个请求。这被称为请求-响应循环。

**传统的非流水线方式：**

1. 客户端发送请求A
2. 客户端等待并接收响应A
3. 客户端发送请求B
4. 客户端等待并接收响应B
5. ...以此类推

这样的方式有几个问题：

1. **延迟**: 每个请求都必须等待前一个请求完成，这导致网络延迟。
2. **带宽不充分利用**: 在等待响应的过程中，TCP连接处于空闲状态。

**使用流水线的方式：**

HTTP流水线技术允许客户端在同一个TCP连接上不断地发送请求，而不用等待之前请求的响应。

1. 客户端连续发送请求A, B, C...
2. 服务器按照收到请求的顺序进行响应。
3. 客户端按照请求发送的顺序接收响应。

**流水线的优点：**

1. **降低延迟**: 可以减少每个请求和响应之间的往返时间。
2. **提高带宽利用率**: 通过充分利用TCP连接，减少连接的空闲时间。

**流水线的缺点：**

1. **头阻塞（Head-of-Line Blocking）**: 如果一个请求处理时间太长，后面的请求也会被延迟，即使这些请求本身能快速处理。
2. **服务器和中间件支持**: 不是所有的服务器和中间件都支持HTTP流水线。
3. **复杂性**: 流水线可能会使网络调试和故障排查变得更复杂。

因为流水线在HTTP/1.1中并不是完全得到广泛支持，所以新一代的HTTP/2协议设计了多路复用（Multiplexing）来更有效地解决这些问题。



#### 无状态协议和cookie

http 是一种不保存状态，即无状态协议。http 协议自身不对请求和响应之间的通信状态进行保存。也就是说 http 协议对于发送过的请求和接受过的请求都不做持久化处理，这样可以更快地处理大量事物，确保协议的可伸缩性。
http 不保存状态，那么服务端是如何知道请求是那个客户端发送过来的呢？解决方案有很多种，我们介绍一下最简单的两种。

- **session 的形式**

客户端第一次发送信息到服务器时，服务器为该客户端创建一个 session 对象，该 session 包含客户端身份信息，同时为该 session 生成一个 sessionId 。

服务端将这个 sessionId 分配给客户端，客户端发送请求时带有此 sessionId ，服务端就可以区分客户端。

- **cookie 的形式**

客户端第一次发送信息到服务器时，服务器根据该客户端信息编码加密生成一个 cookie。

务端将此 cookie 发送给客户端，客户端发送请求时带有此 cookie ，服务端就可以区分客户端。

服务器将 cookie 和 sessionId 发送给客户端时是通过 set-cookie 首部，客户端将两个字断发送给服务器是通过 cookie 首部。发送请求时，cookie 首部可以包含多个服务端的 cookie，服务端接收请求时，取出自己所需的 cookie。

**cookie 首部包含的信息**

客户端禁用 cookie 首部时，如何传递 cookie 信息？

可以将 cookie 信息放到 url 的 params 中或者请求的 body 中，但一般的解决方案是放在 url 的 params 中，通过重写 url 的方式传递。

- **cookie 和 session 两种解决方案的区别**

  session 解决方案需要在服务端存储客户端的数据，分布式服务器需要设置单独且唯一的数据中心，占用资源较大。但是客户端携带的 sessionId 不包含的用户信息，较为安全。

  cookie 的解决方案不需要在服务器存储客户端的数据，占用资源较小，可拓展性较高；请求携带的cookie 携带着用户信息，相对来说，没那么安全 ；从数据量上来看，cookie 一般都比 sessionId 大，传输过程中占用较大资源。

  

> **存储位置**
>
> - **Cookie**：存储在客户端（浏览器）。这意味着每次发送HTTP请求时，浏览器都会自动附加与该站点相关的所有Cookie。
> - **Session**：通常存储在服务器端。客户端存储一个与服务器端Session相关联的`Session ID`，通常这个`Session ID`是存储在Cookie中的。
>
> **存储容量**
>
> - **Cookie**：由于存储在客户端，因此存储空间有限，通常最大为4KB。
> - **Session**：存储在服务器，通常没有存储限制。但是，存储大量数据可能会影响服务器性能。
>
> **存储期限**
>
> - **Cookie**：可以设置过期时间，如果不设置，生命周期则与浏览器会话（Session）同长，即关闭浏览器后消失。
> - **Session**：在没有活动的情况下，Session会在一定时间后过期。这个时间是可以配置的。
>
> **数据类型**
>
> - **Cookie**：仅能存储文本信息。
> - **Session**：可以存储各种类型的数据，如对象和数组。
>
> **速度和效率**
>
> - **Cookie**：由于每次HTTP请求都会带上Cookie，因此可能会影响性能，特别是当Cookie信息较多时。
> - **Session**：由于存储在服务器端，不需要每次都传送，因此相对更高效。
>



### HTTP 和 HTTPS 的基本概念

**HTTP**：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP 原理**：

①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 **TCP** 来完成的，一般 TCP 连接的端口号是**80**。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。



**HTTPS**：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。**SSL 握手协议（SSL Handshake Protocol）**，它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
![img](https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70)

**HTTPS 设计目标**：

(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。

(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。



#### HTTP 与 HTTPS  的区别

1、HTTPS  协议需要到 **CA （Certificate Authority，证书颁发机构）**申请证书，一般免费证书较少，因而需要一定费用。（但是云服务器供应商会免费配置HTTPS  证书）

> **数字证书认证**
> 数字证书认证机构 (CA, Certificate Authority) 是客户端和服务器双方都信任的第三方机构
>
> - 服务器事先向数字证书机构申请数字证书，数字证书机构对数据做数字签名，然后将数据和数字签名打包在一起，做成数字证书，发送给服务端
> - https通信时，服务器把数字证书发给客户端。客户端取得其中的数据和数字签名，使用数字证书机构的公开密钥验证数据和数字签名是否合法
>
> 这里数字证书机构的公开密钥不是通过网络获取，而是事先在浏览器内部植入的。浏览器事先会植入常用认证机构的公开密钥。
>
> 数字证书中数据可以包含很多的信息。比如：服务端的身份信息，可以非对称加密的公开密钥等等
>
> 通过这种方式，即能验证了通信方身份，也可以实现安全加密。

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

- **HTTP**: 使用明文进行传输，信息在传输过程中没有加密。这意味着第三方可以容易地截获和查看数据。

- **HTTPS**: 使用 SSL/TLS 协议对数据进行加密，保证了数据在传输过程中的安全性。这使得第三方即使截获了数据也很难解读。

  > **通过 ssl/tls 报文摘要功能检验报文完整性**
  >
  > http 也提供了 MD5 报文摘要功能，但不是安全的。因为MD5报文摘要的值也是可以被篡改的
  > https 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作；加密 + 摘要检验 + 认证 = 数据完整

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

5、CPU 资源消耗

- **HTTP**: 由于没有加密和解密过程，所以 CPU 资源消耗相对较少。
- **HTTPS**: 加密和解密需要额外的 CPU 资源，从而导致更高的计算成本。





#### HTTPS 相对于 HTTP 的改进

**双向的身份认证**

客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：

- 客户端发起 SSL 握手消息给服务端要求连接。

- 服务端将证书发送给客户端。

- 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

- 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。



注意：

(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是*一对公钥和私钥*。

(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。

(3) 客户端内置的是 **CA 的根证书(Root Certificate)**，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。



**数据传输的机密性**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的**加密算法**。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的**密钥交换算法** ( 一般是**RSA**)，**数据签名摘要算法** ( 一般是SHA或者MD5) ，加密传输数据的**对称加密算法** ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。



**防止重放攻击**

SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。

可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。

重放攻击（Replay Attack）是一种网络攻击类型，其中攻击者拦截并记录了有效的数据传输，然后在稍后的时间里再次发送（或“重放”）该数据，以尝试进行未授权的操作。因为这些数据包在初次传输时是有效的，所以在没有额外安全措施的情况下，接收方可能会认为重放的数据包也是有效和合法的。



**如何进行重放攻击？**

1. **拦截阶段**: 攻击者首先需要能够拦截目标和服务器之间的通信。这通常通过嗅探、中间人攻击或者其他网络侦听技术来完成。
2. **记录阶段**: 攻击者记录拦截到的数据包。
3. **重放阶段**: 攻击者在合适的时机将记录的数据包重新发送给服务器或目标。

**重放攻击的影响**

1. **身份冒充**: 如果拦截的是身份验证信息（如登录令牌或密码），攻击者可能通过重放攻击成功冒充用户。
2. **数据篡改**: 如果拦截的是一个修改数据的操作，重放攻击可能导致数据被重复修改。
3. **信息泄露**: 攻击者可能通过分析拦截的数据包获取敏感信息。

**防御措施**

1. **时间戳**: 在数据包中包含一个时间戳，并在接收数据包时检查它是否在一个合理的时间窗口内。这样，过时的数据包（即可能已经被记录和重放的数据包）就会被拒绝。

2. **序列号**: 使用一个递增的序列号来标记每个数据包。服务器会记录最后一个接收到的有效序列号，并拒绝所有序列号小于或等于该值的数据包。

3. **一次性令牌**: 使用一次性令牌（如 OTP，One-Time Password）进行身份验证。

4. **加密和完整性校验**: 使用像 HTTPS 这样的安全协议，其内部有措施（如消息认证码）来防止重播攻击。

5. **多因素认证**: 使用多种方式进行身份验证，降低单一数据包被重放导致的风险。

   

#### HTTPS 的优点

1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。



#### HTTPS 的缺点（对比优点）

1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。

3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。

5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。



#### HTTPS**连接过程**

HTTPS 的连接过程涉及多个步骤，主要目的是建立一个安全的加密通道，并进行服务器和（可选的）客户端的身份验证。这通常是通过 TLS（传输层安全）或其前身 SSL（安全套接字层）来实现的。以下是 HTTPS 连接的基本流程，分为几个关键步骤：

**1. TCP 握手**

在进行任何 HTTPS 交互之前，客户端（通常是一个Web浏览器）和服务器首先需要建立一个 TCP 连接。这是通过三次握手（SYN, SYN-ACK, ACK）完成的。

**2. 客户端发起 TLS 握手**

一旦 TCP 连接建立，客户端会发起一个 TLS 握手。握手开始时，客户端会发送一个 `ClientHello` 消息，该消息中包含：

- 支持的加密算法列表
- 一个随机生成的客户端随机数（Client Random）
- 其他设置和扩展

**3. 服务器响应**

服务器接收 `ClientHello` 消息后，会选择一组加密算法和其他设置，然后发送一个 `ServerHello` 消息，其中包含：

- 选定的加密算法
- 一个随机生成的服务器随机数（Server Random）
- 服务器的数字证书

**4. 证书验证**

客户端接收到服务器的证书后，会对其进行验证以确认服务器的身份。这通常包括：

- 检查证书是否由受信任的证书颁发机构（CA）签发
- 验证证书是否过期
- 验证证书是否被撤销

**5. 密钥交换**

客户端和服务器使用各自的随机数和一个（在某些密钥交换算法中的）预主密钥（Pre-Master Secret）来生成主密钥（Master Secret）。主密钥将用于加密和解密数据。

客户端生成预主密钥，并使用服务器公钥进行加密，然后发送给服务器。服务器使用其私钥解密获取预主密钥。

**6. 完成握手**

客户端和服务器都发送一个 `Finished` 消息，该消息使用之前生成的主密钥进行加密。

**7. 加密数据传输**

一旦 TLS 握手完成，客户端和服务器就会使用生成的主密钥进行加密和解密数据，从而确保数据传输的安全性。

**8. 连接关闭**

连接完成后，任何一方都可以选择关闭连接。通常，这是通过发送一个 `close_notify` 警告来完成的。这样，双方都能知道连接将安全地关闭，而不是因为某种错误或攻击而突然中断。



#### TCP的三次挥手和四次挥手

**三次握手（Three-Way Handshake）**

三次握手是 TCP 连接建立的过程，涉及三个主要步骤：

1. **SYN（同步序列编号）**: 客户端发送一个 TCP 包，其中设置了 SYN 标志位，以请求建立连接。这个包也包含一个初始的序列号 `x`。
2. **SYN-ACK（同步应答）**: 服务器收到 SYN 包后，回复一个设置了 SYN 和 ACK（确认）标志位的 TCP 包。这个包确认了客户端的 SYN，并提供了服务器自己的初始序列号 `y`。
3. **ACK（应答）**: 客户端收到 SYN-ACK 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 SYN。

完成这三个步骤后，TCP 连接就建立了，数据可以双向传输。

**四次挥手（Four-Way Handshake）**

四次挥手是 TCP 连接终止的过程，涉及四个主要步骤：

1. **FIN（完成）**: 当一方（假设是客户端）准备关闭连接时，它发送一个设置了 FIN 标志位的 TCP 包。
2. **ACK（应答）**: 服务器收到 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认客户端的 FIN。此时，从客户端到服务器的连接关闭，但服务器到客户端的连接仍然打开。
3. **FIN（完成）**: 当服务器准备关闭连接时（可能是立即，也可能是稍后），它发送一个设置了 FIN 标志位的 TCP 包。
4. **ACK（应答）**: 客户端收到服务器的 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 FIN。

完成这四个步骤后，TCP 连接就完全关闭了。

<img src="https://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116161802952-584681349.png" alt="img" style="zoom: 80%;" />

https://www.cnblogs.com/liyuhui-Z/p/7844880.html

### HTTP连接过程

#### 1. DNS 解析

首先，浏览器会对目标服务器的域名进行 DNS（Domain Name System）解析，以获取其 IP 地址。

#### 2. 建立 TCP 连接

DNS 解析完成后，浏览器与服务器的 IP 地址建立一个 TCP 连接。这是通过 TCP 的三次握手过程（SYN, SYN-ACK, ACK）完成的。

#### 3. 发送 HTTP 请求

TCP 连接建立后，浏览器会通过该连接发送一个 HTTP 请求给服务器。HTTP 请求通常包括：

- 请求方法（GET、POST、PUT、DELETE 等）
- 目标 URL
- HTTP 版本
- 请求头（如 `User-Agent`, `Accept-Language` 等）
- 可选的请求体（主要用于 POST 和 PUT 请求）

#### 4. 服务器处理请求

服务器接收到 HTTP 请求后，会根据请求的类型和目标资源进行处理。这可能包括查询数据库、执行服务器端代码等。

#### 5. 发送 HTTP 响应

服务器处理完请求后，会发送一个 HTTP 响应回到客户端。HTTP 响应通常包括：

- HTTP 状态码（如 200 OK，404 Not Found 等）
- 响应头（如 `Content-Type`, `Cache-Control` 等）
- 响应体（返回的实际数据，如 HTML 文档、图像等）

#### 6. 渲染和显示

客户端（通常是浏览器）接收到 HTTP 响应后，会根据响应内容进行相应的处理。例如，如果返回的是一个 HTML 文档，浏览器会解析并渲染它。

#### 7. 关闭 TCP 连接

数据传输完成后，客户端和服务器可以选择关闭 TCP 连接，或者保持它以用于后续的请求和响应（HTTP/1.1 默认行为是保持连接）。关闭连接通常是通过发送 TCP FIN 包来完成的。



### HTTPS数据加密

加密方式有两种：**对称加密和非对称加密**

**对称加密：**加密和解密使用同一密钥。运算速度快，但无法安全地将密钥传输给数据接收方。
**非对称加密：**加密和解密使用不同密钥。

非对称加密的密钥分为公钥和私钥，公开密钥所有人都可以获得，数据发送方获得接收方的公开密钥，通过公开密钥进行加密，接收方收到数据后，通过私有密钥解密，获取数据内容。这种方式更安全一点，但运算速度很慢

https 的数据加密分别利用了这两种加密方式的优点。首先通过**非对称加密**，传输对称加密所需的密钥，然后**使用密钥进行通信加密**。这样既兼顾了安全性，又有了更高的运算速度。这个流程看似完美无瑕，但其实过程中第一步发送方获取的公开密钥可能被篡改。可以通过**数字证书**的方式来解决这个问题。

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231028002821825.png" alt="image-20231028002821825" style="zoom:50%;" />

### websocket

WebSocket 是一种网络通信协议，它提供了全双工（full-duplex）、在单个长连接（TCP）上进行的实时通信能力。这意味着服务器和客户端都能够在任何时候发送数据给对方，不需要像传统的HTTP请求那样每次都建立一个新的连接。

一般的 web 程序是 c/s 架构，也就是说**服务端不能主动给客户端发送数据**。只有当客户端向服务端发送请求时，服务端才可以向客户端返回响应。但是很多场景下都需要服务端直接向客户端发送请求，比如进行服务推送。面对这种情况，一般的处理方案是客户端轮训服务端，客户端不断向服务端发送请求。这种方式的效率是十分低下，并且占用大量的计算资源，即包括客户端资源也包括服务器资源。

websocket 的出现就是为了解决这个问题。websocket，即 web 浏览器与 web 服务器之间全双工通信标准。其中，websocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。

> 通信方式：
>
> 单工通信：单向传输
> 半双工通信：双向交替传输
> 全双工通信：双向同时传输

**websocket 的特征**

- 建立在 tcp 协议之上。
- 与 http 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 http 协议，因此握手时不容易屏蔽，能通过各种 http 代理服务器。
- 数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。
- 没有同源限制，客户端可以与任意服务器通信。



**WebSocket 与 HTTP 的区别**

1. **长连接 vs 短连接**: HTTP连接通常是短连接，即一次请求-响应后连接就关闭了。而WebSocket建立后，除非客户端或服务器明确要求，否则连接会保持打开状态。
2. **全双工 vs 半双工**: HTTP协议是半双工的，即在任何给定的时间点，要么是客户端发送请求到服务器，要么是服务器返回响应到客户端。但WebSocket是全双工的，允许数据在两个方向上同时传输。
3. **更低的延迟**: 因为WebSocket连接是长连接，并且数据传输不需要每次都进行握手，因此相对于HTTP，WebSocket有更低的延迟。
4. **更少的数据开销**: 在WebSocket中，一旦连接建立，数据传输的头信息比HTTP要小得多，这有助于减少数据传输的总量。

**建立 WebSocket 连接**

1. 首先，客户端会发送一个特殊的HTTP请求，通常称为"握手请求"。
2. 服务器解析这个请求，然后返回一个特殊的HTTP响应，以完成握手。
3. 握手完成后，该连接就从HTTP升级为WebSocket连接。

**使用场景**

WebSocket 常用于需要实时功能的web应用程序，例如：

- 聊天应用
- 在线游戏
- 实时股票或新闻更新
- 协同编辑
- 实时通知或提醒



### 不同版本的HTTP

**http 0.9,**
http 于 1990 年问世。那时的 http 并没有作为正式的标准被建立。 现在的 http 其实含有 http1.0 之前版本的意思，因此被称为 http/0.9。

**http 1.0:** http 第一个正式版本。

**http 1.1,** 相比于 http1.0 的新特性。
默认是**长连接**，并且支持**流水线**，支持同时打开多个 TCP 连接，客户端需要使用多个连接才能实现并发和缩短延迟。
支持虚拟主机，新增状态码 100，支持分块传输编码，新增缓存处理指令 max-age。
**不会压缩请求和响应首部，占用不必要的网络流量。**
不支持有效的资源优先级，致使底层 TCP 连接的**利用率低下**。

**http 2.0,** 相比于 http1.1 的新特性。

相比于 http/1.1 的文本（字符串）传送， http/2.0 采用**二进制传送**。客户端和服务器传输数据时把数据分成帧，**帧组成了数据流**，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。

http/2.0 支持**多路复用**。因为流 ID 的存在， 通过同一个 http 请求可以实现多个 http 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 http 请求。

http/2.0 **头部压缩**。http/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 http 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。

http/2.0 支持**服务器推送**。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。

**http 3.0**

http3.0 是在 **quic**(quick udp internet connection) 基础上发展起来的，其底层使用 **udp** 进行数据传输，上层仍然使用 http/2.0。在 udp 与 http/2.0 之间存在一个 quic 层，其中 tls 加密过程在该层进行处理。http/3.0 主要有以下几个特点：

- 使用 **UDP** 作为传输层进行通信。
- 在 UDP 之上的 **QUIC** 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手。
- **建立连接快**，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据。
- 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，**只需要继续发送数据包即可完成连接的建立。**
- 使用 QPACK 进行**头部压缩**，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。



## 网络编程 socket（利用传输层的接口）

套接字 (Socket) 是对网络**中不同主机上的应用进程之间进行通信的接口**，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 tcp 用主机的 ip 地址 + 端口号作为 tcp 连接的端点，这个端点就叫做套接字。套接字（Socket）是一种在应用层和传输层之间进行数据交换的编程界面（API）。它用于不同计算机间的进程通信，实质上是对TCP/IP协议族（尤其是TCP和UDP）的封装。

### 基本概念

1. **端点（Endpoint）**: 套接字代表了网络上一个端点，用以接收和发送数据包。
2. **协议族（Protocol Family）**: 常用的有AF_INET（IPv4）、AF_INET6（IPv6）等。
3. **类型（Type）**: 常见的套接字类型包括流套接字（SOCK_STREAM，通常用于TCP）和数据报套接字（SOCK_DGRAM，通常用于UDP）。

### 常用操作

1. **创建（socket）**: 创建一个新的套接字。
2. **绑定（bind）**: 将套接字绑定到一个特定的地址和端口。
3. **监听（listen）**: 在绑定的地址和端口上监听连接请求（仅限于流套接字）。
4. **接受（accept）**: 接受一个到来的连接请求，返回一个新的套接字来处理该连接（仅限于流套接字）。
5. **连接（connect）**: 尝试与服务器的一个地址和端口建立连接。
6. **发送（send）/接收（recv）**: 在建立的连接上发送和接收数据。
7. **关闭（close）**: 关闭一个套接字，终止其连接。

套接字主要有以下三种类型：

- **流套接字(tcp 套接字）**：流套接字基于 tcp 传输协议，tcp协议发送数据流。主要用于提供面向连接、可靠的数据传输服务。由于 tcp 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。

- **数据报套接字(udp套接字)**：数据报套接字基于 udp 传输协议，udp 协议发送数据报。对应于无连接的 udp 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 udp 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 udp 套接字时，丢包等问题需要在程序中进行处理。

  > 数据报（Datagram）是一种独立的、封装成单一实体的数据包，用于无连接的通信模式。在无连接的协议（如UDP，User Datagram Protocol）中，数据报被发送从一个端点（Source）到另一个端点（Destination）而不需要预先建立连接。
  >
  > **主要特点：**
  >
  > 1. **无连接（Connectionless）**: 数据报的发送和接收是无连接的，意味着每个数据报都是一个独立的信息单位，不依赖其他数据报。
  > 2. **不可靠（Unreliable）**: 数据报协议通常不保证数据报一定会到达目的地，也不保证数据报的有序性。
  > 3. **无状态（Stateless）**: 数据报自身不维护任何与之前或之后的数据报有关的状态信息。
  > 4. **边界保留（Preserving Boundaries）**: 接收方收到的每一个数据报都是一个完整的信息单位，不会与其他数据报合并。
  >
  > **数据报的组成：**
  >
  > 1. **数据载荷（Payload）**: 实际要发送的数据。
  > 2. **元信息（Metadata）**: 包括源和目的地址、端口号、长度等。
  > 3. **校验和（Checksum）**: 用于错误检测。

- **原始套接字**：由于流套接字和数据报套接字只能**读取 tcp 和 udp 协议的数据**，当需要传送非传输层数据包（例如 **Ping** 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立**原始套接字**来发送。

## 其他

### **2.4.1 内容分发网 CDN**

内容分发网络(Content distribution network，CDN)是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 html、css、javascript、音乐、图片、视频等静态资源分发给用户。

CDN主要有以下优点：

- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性。

### **2.4.2 抓包软件原理**

网络数据在网络中传输，无论如何都要经过网络节点，假如需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包

### **2.4.3 常用协议及其端口**

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231028010032382.png" alt="image-20231028010032382" style="zoom: 50%;" />

### TCP（传输控制协议）与 UDP（用户数据报协议）的区别

#### TCP

1. **面向连接**: 在数据传输之前需要先建立连接（三次握手）。
2. **可靠性高**: 提供数据传输的确认机制、错误恢复等。
3. **有序传输**: 数据报文段按照其发送顺序进行接收。
4. **拥塞控制**: 通过流量控制和拥塞控制机制，适应网络状态。
5. **速度较慢**: 由于上述特性，通常比UDP慢。
6. **重量级**: 由于保证可靠性和有序性，所以报头较大，消耗更多的CPU资源。

#### UDP

1. **无连接**: 不需要预先建立连接。

2. **可靠性低**: 不提供数据传输的确认机制。

3. **无序传输**: 数据报文段可能会乱序到达。

4. **无拥塞控制**: 速度快，但在网络拥塞时可能会丢包。

5. **速度较快**: 由于较少的检查和确认，通常比TCP快。

6. **轻量级**: 报头小，消耗较少的CPU资源。

   

#### **应用场景**

**适合使用TCP的场景**

1. **文件传输**: 如FTP, HTTP，需要确保数据的完整性。

2. **电子邮件**: 如SMTP。

3. **远程登录**: 如SSH, Telnet。

4. **数据库操作**: 如MySQL。

5. **流媒体的可靠传输**: 如用于实时但需要可靠传输的WebRTC。

   

**适合使用UDP的场景**

1. **实时应用**: 如VoIP，实时视频会议。

2. **广播和多播应用**: 如IPTV。

3. **快速交互**: 如DNS查询。

4. **在线游戏**: 对实时性要求高，允许少量丢包。

5. **流媒体的不可靠传输**: 如用于实时但可以容忍一定丢包的流媒体应用。

   

**UDP对应的协议**

①DNS：用于域名解析服务，将域名地址转换为IP地址，使用53号端口。

②SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备。由于网络设备过多，无连接的服务体现优势。

③TFTP：简单文件传输协议，该协议在端口69号使用UDP服务。



**TCP对应的协议**

FTP：定义了文件传输协议，使用21号端口。

Telnet：用于远程登录的端口，其使用23号端口，用户可以以自己的身份远程连接到计算机上。

SMTP：邮件传送协议，用于发送邮件。其使用25号端口。

POP3：其与SMTP对应，POP3用于接收邮件。使用了110端口。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议，端口是80号

HTTPs：端口是443号



# 第三部分：传输层

传输层位于应用层和网络层之间，是分层网络体系结构最重要的部分之一。 传输层依赖网络层提供的网络服务，并且向应用层提供传输服务。

本章高频面试题

> 为什么要进行三次握手？两次握手可以吗?
> 为什么要四次挥手？
> CTIME-WAIT 为什么是 2MSL？
> TCP 和 UDP 的区别？
> TCP 是如何保证可靠性的，UDP 为什么是不可靠的 ？
> TCP 报文包含哪些信息 ？
> UDP 包含哪些信息
> 三次握手和四次挥手过程中，网络断开会发生什么？

## 传输层服务