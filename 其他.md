***\*对数据库的操作一般包括连接、打开、使用、关闭等步骤，对于不同类型的数据库，其操作步骤都一致，只是连接数据库方法有所区别，可以使用（）对其进行设计\****

 

模板方法模式

 

***\*共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用（）模拟共享网络设备的设计原理。\****

 

***\*享元模式\****

 

 外观模式（Facade Pattern）是一种设计模式，用于为一个复杂的子系统提供一个统一的接口。这样，子系统更容易使用，因为你只需要与一个统一的接口进行交互，而不是各个子系统的独立接口。

以下是对这些选项的分析：

### A. 对客户端屏蔽了子系统组件

**正确**。外观模式的主要目的就是提供一个统一的接口，以隐藏子系统的复杂性。客户端只需要与外观类交互，而不需要直接与子系统的多个组件交互。

### C. 单个子系统的修改不影响其他子系统

**不一定正确**。这个描述更像是松耦合或模块化设计的特点，而不是外观模式特有的。外观模式主要是对一个特定子系统（或多个密切相关的子系统）提供统一的接口，并不能保证单个子系统的修改不影响其他子系统。

### D. 子系统类变化时，只需要修改外观类即可

**正确**。由于外观模式提供了一个统一的接口，所以如果子系统的内部发生变化，只需要更新这个统一接口（也就是外观类）即可。这样，客户端代码不需要任何修改，从而实现了解耦。



在模拟毛笔的使用过程中提供了大中小3种型号的画笔，够绘制5种不同颜色。我们可以使用（桥接）来模拟实现模拟毛笔的使用。

是的，桥接模式（Bridge Pattern）是一个很好的选择来模拟毛笔的使用过程中的不同组合（大小和颜色）。

桥接模式主要用于将抽象与其实现解耦，使得两者可以独立地变化。在这个场景中，毛笔的大小和颜色可以视为两个独立的维度。

- **抽象（Abstraction）**: 这里可以是一个`Brush`类，拥有绘制（draw）的方法。
- **实现（Implementation）**: 这里可以是颜色和大小，例如`Color`和`Size`。

这样，你可以通过桥接模式将`Brush`类与具体的`Color`和`Size`实现解耦，允许你独立地添加更多的颜色或更改笔刷大小，而不影响其他代码。



![image-20231020104459926](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020104459926.png)

### A. 样式文件的加载会阻塞脚本的执行

**正确**。外部的样式表（如：通过`<link rel="stylesheet" href="style.css">`加载）确实会阻塞后面的JavaScript脚本的执行，除非这些脚本是异步的或被设置为`defer`。

### B. iframe 会阻塞主页面的 load 事件

**正确**。`<iframe>`确实会阻塞主页面的`load`事件。直到iframe以及其中的所有资源都完成加载后，主页面的`load`事件才会触发。

### C. `<audio>`、`<img>` 中的资源下载会阻塞页面解析

**不正确**。通常，这些元素不会阻塞页面的解析。它们会异步地下载。

### D. 页面文档完全加载并解析完毕之后会触发 DOMContentLoaded 事件

**不正确**。实际上，`DOMContentLoaded`事件会在HTML文档被完全加载和解析完毕后触发，但在样式表、图片和子框架完成加载前就会触发。

![image-20231020105554295](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020105554295.png)

### A. 当前域的 cookie 都可以通过 js 在当前域下获取

**不一定正确**。虽然在大多数情况下，JavaScript 可以访问同一域名下设置的 cookie，但如果该 cookie 被标记为 `HttpOnly`，则 JavaScript 将无法访问它。因此，这个说法并不总是正确。

### B. JSONP 是 XMLHttpRequest 中的一种

**错误**。JSONP（JSON with Padding）与 XMLHttpRequest 不是同一回事。JSONP 是一种跨域数据访问的技术，而 XMLHttpRequest 是用于发起 HTTP 或 HTTPS 请求的 API。JSONP 不使用 XMLHttpRequest，而是通过动态创建 `<script>` 标签来实现跨域请求。

### C. 同源策略是浏览器的安全策略

**正确**。同源策略确实是浏览器的一种安全机制，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一种重要的安全措施，用于防止诸如 CSRF（跨站请求伪造）和 XSS（跨站脚本攻击）等安全问题。

### D. localStorage API 不支持设置过期时间

**正确**。与 cookie 不同，HTML5 的 `localStorage` API 本身并不提供设置过期时间的功能。一旦数据存储在 localStorage 中，它将一直存在，除非用户手动清除或者通过代码进行删除。

![image-20231020105847678](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020105847678.png)

### A. requestAnimationFrame(foo) 确保使浏览器在下一次重绘之前调用 foo 方法

**正确**。`requestAnimationFrame(foo)` 将确保在浏览器的下一次重绘之前调用 `foo` 函数。这是一种更高效的方式来进行动画或页面更新，因为它会与浏览器的绘制周期同步。

### B. 在 addEventListener 的处理方法中使用 e.preventDefault() 可以阻止事件冒泡

**错误**。`e.preventDefault()` 用于阻止事件的默认行为，而不是阻止事件冒泡。要阻止事件冒泡，你应该使用 `e.stopPropagation()`。

### C. 把 `<script>` 标签的引入放在文档末尾可以确保脚本下载和执行均在文档解析完成后发生

**正确**，通常情况下。将 `<script>` 标签放在文档的末尾（通常在 `</body>` 标签之前）确实是一种常用的做法，以确保脚本在整个文档解析完成后才执行。这样可以减少页面渲染的阻塞。

### D. 多个 `<script>` 标签使用 defer 属性引入脚本时，可以确保脚本的执行是按照其被引入的顺序的

**正确**。当使用 `defer` 属性时，多个脚本将按照它们在文档中出现的顺序进行执行，而且都会在文档解析完成后，DOMContentLoaded 事件触发之前执行。



![image-20231020111931217](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020111931217.png)

DMA（Direct Memory Access）I/O 控制方式通常用于数据传输速率高和数据量大的设备，因为它可以直接在设备和内存之间进行数据传输，而不需要 CPU 的介入。这样做可以减轻 CPU 的负担，让其有更多的时间来处理其他任务。

选项解析：

A. **打印机**：通常数据传输速率不高，不需要 DMA。

B. **键盘**：用户输入速度慢，不需要 DMA。

C. **鼠标**：与键盘类似，用户输入速度慢，不需要 DMA。

D. **磁盘**：数据传输速度高，数据量大，适合使用 DMA。



![image-20231020115721962](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020115721962.png)

A. **Windows NT Server**：这是一个网络操作系统，主要用于企业级应用。

B. **Unix**：Unix 系统通常用于服务器和网络操作，拥有丰富的网络功能。

C. **DOS**（Disk Operating System）：这是一个用于个人计算机的操作系统，并没有专为网络操作而设计。它缺乏现代网络操作系统所需的多用户、多任务和其他网络功能。

D. **NetWare**：这是 Novell 公司开发的网络操作系统，专门用于文件服务器。



![image-20231020115903235](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020115903235.png)

分段对应的是内存具体存储管理的一种方式，是对具体内存进行管理，段号+基地址，分段尺寸最大为具体内存。在动态链接时先将主程序所对应的目标程序装入内存并启动运行，运行过程中需要调用某段时才将该段内存合并进行链接。 而作业的大小不受内存大小限制，由虚拟存储器解决空间不够问题，允许作业装入的时候只装入一部分，另一部分放在  磁盘  上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。同 时，用户编程的时候也摆脱了一定要编写小于主存容量的作业的限制。

**主要的储存管理方式：**

### 1. 连续内存分配

- **描述**：进程在内存中占用连续的地址空间。

- **优点**：简单，易于管理。

- **缺点**：容易导致内存碎片。

- **应用场景**：早期操作系统，嵌入式系统。

  

### 2. 分页存储管理

- **描述**：物理内存被划分为固定大小的页，进程也被划分为相同大小的页。
- **优点**：减少内存碎片，允许灵活的内存分配。
- **缺点**：增加了页表的管理成本。
- **应用场景**：现代通用操作系统。



- 在分页存储管理中，物理内存和逻辑内存都被分为固定大小的单位，称为“页”。
- 一个进程的页可以非连续地存储在物理内存中。

**主要特点**

1. **内存利用率高**：由于所有的块都是固定大小的，因此减少了内存碎片。
2. **简化内存管理**：页表提供了一种简单的方法来跟踪哪些页被加载到物理内存中。
3. **支持大内存模型**：通过虚拟内存，分页可以使程序认为它有比物理内存更多的可用内存。

**缺点**

1. **页表开销**：维护页表需要额外的内存和计算资源。
2. **不适合某些类型的数据或代码**：因为所有页都是固定大小的，可能不适合需要动态调整大小的数据结构。

**场景应用**

- 现代操作系统，如 Linux，Windows 和 macOS

- 大型和复杂的软件系统

- 虚拟内存系统

  

### 3. 分段存储管理

- #### 描述

  - 分段存储管理中，程序和数据被分为多个逻辑段。每个段有自己的起始地址和长度。
  - 地址空间被划分为不同的逻辑单位，如代码段、数据段和堆栈段。

  #### 主要特点

  1. **灵活性**：由于分段是逻辑上的划分，它允许每个段的大小按需分配。
  2. **易于共享和保护**：不同的段可以有不同的保护级别，也更容易进行资源共享。
  3. **支持高级语言特性**：更容易支持如数组和递归等高级编程语言特性。

  #### 缺点

  1. **内存碎片**：由于段大小不固定，可能会导致内存碎片。
  2. **地址转换复杂**：需要维护一个段表来进行虚拟地址到物理地址的转换，这增加了一些复杂性。

  #### 场景应用

  - 操作系统内核
  - 高级编程语言支持
  - 模块化程序设计

### 4. 混合分段/分页系统

- **描述**：将分段和分页结合起来使用。
- **优点**：结合了分段和分页的优点。
- **缺点**：管理相对复杂。
- **应用场景**：需要灵活和高效内存管理的高性能系统。

### 5. 虚拟内存

- **描述**：允许进程使用的地址空间超过物理内存，通常通过磁盘交换来实现。
- **优点**：增加了系统的灵活性和吞吐量。
- **缺点**：可能导致磁盘I/O性能瓶颈。
- **应用场景**：现代通用操作系统。

### 6. 伙伴系统（Buddy System）

- **描述**：内存被划分为大小为 2 的整数次幂的块。
- **优点**：高效，减少碎片。
- **缺点**：存在一定的内存浪费。
- **应用场景**：内存池管理，嵌入式系统。

### 7. 堆内存管理

- **描述**：由程序在运行时动态分配和释放。
- **优点**：灵活。
- **缺点**：可能导致内存泄漏和碎片。
- **应用场景**：动态数据结构，对象存储。

### 8. 栈内存管理

- **描述**：由编译器自动管理，用于存储函数调用的局部变量。
- **优点**：快速，无需手动管理。
- **缺点**：大小和生命周期受限。
- **应用场景**：函数调用，递归。

**9. 缓存管理**

- **描述**：频繁访问的数据或代码存储在快速但容量小的缓存中。
- **优点**：提高数据访问速度。
- **缺点**：增加了管理复杂性。
- **应用场景**：数据库，Web 服务器。



![image-20231020123409104](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020123409104.png)

保证系统不会发生死锁的最小M值为：**M=N(W-1)+1。** 

在分析这个问题时，死锁的一个关键点是：一个或多个进程因为无法获得它们所需的资源而永久地等待其他进程释放这些资源。

**分析各选项：**

1. **a.M=2, N=2, W=2**: 这里有2个进程，每个进程都需要2个资源，但总共只有2个资源。因此，每个进程都可能拿到一个资源，然后等待另一个资源，造成死锁。
2. **b.M=3, N=2, W=2**: 这里有3个资源和2个需要2个资源的进程。一个进程可能占用2个资源，另一个进程占用1个，然后释放，使得第一个进程可以获取剩下的一个。因此，不会发生死锁。
3. **c.M=3, N=2, W=3**: 这里有3个资源和2个进程，每个进程都需要3个资源。一个进程可能拿到2个资源，另一个进程拿到1个资源，然后都等待剩下的资源，造成死锁。
4. **d.M=5, N=3, W=2**: 这里有5个资源和3个需要2个资源的进程。理论上，所有3个进程都可以同时拿到它们所需的2个资源。因此，不会发生死锁。
5. **e.M=6, N=3, W=3**: 这里有6个资源和3个需要3个资源的进程。理论上，两个进程可以各自占用3个资源，而第三个进程等待。不会发生死锁。



![image-20231020123729873](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020123729873.png)

在这个问题中，我们需要考虑以下几个方面：

1. 磁盘块大小为1KB，即1024字节。
2. 直接索引指针有10个。
3. 一级和二级索引指针各1个。
4. 每个索引指针占4字节。

首先，考虑直接索引指针。这里有10个直接索引指针，所以前10KB（10240字节）可以通过直接索引来访问。即0~10239字节。

**对于偏移量1234：**

1234字节处于前10KB范围内（0-10239），所以只需访问1个磁盘块。

**对于偏移量307400：**

- 直接索引覆盖到10240字节。
- 一级索引：1KB/4字节 = 256，256个磁盘块可以通过一级索引来访问，即256KB（从10240字节到266240字节）。
- 剩下的需要通过二级索引。

307400字节 > 266240字节，所以需要使用二级索引。

二级索引覆盖：(1KB/4字节) * (1KB/4字节) = 256 * 256 = 65536个磁盘块，即65536KB。

访问磁盘块的数量：

1. 一次访问用于读取一级索引。
2. 一次访问用于读取二级索引。
3. 一次访问用于获取实际的磁盘块。

总共需要3次磁盘访问。

因此，对于1234和307400字节的偏移量，需访问的磁盘块个数分别是1和3。



![image-20231020124408586](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020124408586.png)

在Linux中，进程的主要状态包括：

1. 可运行状态（**Runnable**）：进程正在运行或在就绪队列中等待运行。
2. 阻塍状态（**Blocked**）：进程正在等待某种条件的发生（例如I/O操作完成）。
3. 僵死状态（**Zombie**）：进程已完成执行，但尚未被父进程清除。



进程的主要状态通常包括以下几种：

1. **新建（New）**: 进程正在创建，但尚未添加到可执行进程队列中。
2. **可运行（Runnable）或就绪（Ready）**: 进程已准备好运行并等待CPU时间。它已有所有必要的资源，除了CPU之外，一旦获得CPU时间，就会开始执行。
3. **运行（Running）**: 进程正在CPU上执行。在单核CPU上一次只能有一个进程在运行，而在多核系统中，多个进程可以同时运行。
4. **阻塞（Blocked）或等待（Waiting）**: 进程在等待某个事件发生或等待某种资源可用。例如，进程可能正在等待用户输入、磁盘I/O完成或某种系统资源变得可用。
5. **挂起（Suspended）**: 进程被挂起，通常是因为它要么是由用户手动挂起的，要么是因为系统资源不足。挂起的进程不能执行，但仍保留在内存中。
6. **终止（Terminated）或退出（Exited）**: 进程已完成执行或被显式地终止。
7. **僵死（Zombie）**: 进程已终止，但进程描述符仍在存在，因为父进程尚未读取子进程的退出状态。



![image-20231020124545854](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020124545854.png)

**Pipe (管道)**

1. **用途**: 主要用于有父子关系或者直接血缘关系的进程间的通信。
2. **特点**: 数据流是单向的，即从一个进程写入，另一个进程读出。
3. **缺点**: 只能在有直接关系的进程之间使用，并且通信是单向的。

**Named Pipe (命名管道, FIFO)**

1. **用途**: 类似于管道，但可以用于没有直接关系的进程间。
2. **特点**: 使用文件系统中的一个特殊文件作为数据传输的中介。
3. **缺点**: 通信仍然是单向的，但可以通过创建两个命名管道来实现双向通信。

**Semaphore (信号量)**

1. **用途**: 用于控制多个进程访问共享资源的顺序。
2. **特点**: 提供了一个计数器，该计数器用于追踪共享资源的使用状态。
3. **缺点**: 使用不当可能导致死锁。

**Message Queue (消息队列)**

1. **用途**: 用于不相关或者分布式进程之间的通信。
2. **特点**: 消息按照队列进行管理，可以实现复杂的消息优先级和查询功能。
3. **缺点**: 可能需要额外的同步和排队逻辑。

**Signal (信号)**

1. **用途**: 主要用于进程控制和状态通知。
2. **特点**: 异步，用于通知一个进程某个事件的发生。
3. **缺点**: 不适合大量数据的传输。

**Shared Memory (共享内存)**

1. **用途**: 多个进程共享一块内存区域。
2. **特点**: 非常高效，因为数据不需要在进程之间复制。
3. **缺点**: 需要额外的同步机制，如信号量。

**Socket** **(套接字)**

1. **用途**: 用于不同机器之间的进程通信，也可用于同一台机器上。
2. **特点**: 支持多种协议（TCP, UDP等）和数据格式。
3. **缺点**: 相对其他机制更为复杂，可能会有更高的延迟。



**线程间通信机制**

线程间通信（Inter-Thread Communication）由于所有线程共享相同的地址空间，因此相对于进程间通信来说，线程间通信通常更加简单和高效。以下是一些常见的线程间通信机制：

**1. 共享变量**

- **用途**: 最简单的方式，所有线程都可以访问这些变量。
- **特点**: 速度快，操作简单。
- **缺点**: 需要手动进行同步操作，以防止数据竞态。

**2. 互斥锁（Mutex）**

- **用途**: 用于控制对共享资源的访问。
- **特点**: 确保同一时刻只有一个线程能访问特定资源。
- **缺点**: 可能导致死锁，且可能有性能开销。

**3. 读-写锁（Read-Write Lock）**

- **用途**: 允许多个线程进行读操作，但写操作是互斥的。
- **特点**: 提高了读取操作的并发性。
- **缺点**: 相对复杂，需要更多的控制逻辑。

**4. 条件变量（Condition Variable）**

- **用途**: 允许线程在满足特定条件时被唤醒。
- **特点**: 非常灵活，可用于实现复杂的同步逻辑。
- **缺点**: 使用不当可能导致死锁或者性能问题。

**5. 信号量（Semaphore）**

- **用途**: 控制对资源或者任务队列的访问。
- **特点**: 可以用于实现生产者-消费者模型等。
- **缺点**: 同样可能导致死锁，且可能有性能开销。

**6. 屏障（Barrier）**

- **用途**: 同步一组线程，使它们在继续执行之前都达到一个点。
- **特点**: 确保所有线程都准备好进行下一步操作。
- **缺点**: 使用不当可能导致程序挂起。

**7. 线程局部存储（Thread-Local Storage, TLS）**

- **用途**: 存储每个线程的局部数据。
- **特点**: 避免了使用全局变量，简化了线程间数据的传递。
- **缺点**: 过度使用可能导致资源浪费和管理复杂性增加。

**8. 消息队列**

- **用途**: 用于传递消息或任务。
- **特点**: 可以实现复杂的流程控制。
- **缺点**: 需要额外的数据结构和同步。



![image-20231020125121427](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125121427.png)

在PC机的“Pentium 4/1.8G”或“Celeron/1.7G”中的“G”通常是指"GHz"，也就是吉赫兹（GigaHertz）。

吉赫兹是频率的单位，用于描述处理器周期的速度。在这个上下文中，1.8G和1.7G意味着处理器的时钟频率是1.8吉赫兹和1.7吉赫兹，分别对应Pentium 4和Celeron处理器。

简单地说，这个数字通常用于衡量CPU的运算速度。



![image-20231020125256466](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125256466.png)

逻辑文件通常有两种形式：流式文件（Stream-Oriented Files）和记录式文件（Record-Oriented Files）。

**流式文件：**

- **特点**: 数据存储为一连串的字节，没有固定的结构或界限。
- **用途**: 通常用于文本文件或者二进制文件，比如图像、音频等。

**记录式文件：**

- **特点**: 数据按照特定的结构或格式（通常为记录）进行组织。
- **用途**: 数据库文件、电子表格等。

现在来回答题目中的陈述：

- **源程序文件**: 一般为文本文件，文本文件通常被视为流式文件。因为它们由一连串的字节组成，没有固定的结构或界限。
- **学生选课文件**: 这种文件可能包含学生信息、课程信息等，更有可能是按照某种结构或记录来组织的，例如CSV或数据库表。



![image-20231020125421293](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125421293.png)

在磁盘阵列（RAID）中，RAID 10（也称为RAID 1+0）和RAID 50（也称为RAID 5+0）是两种常见的配置方式。我们来一步步地分析这两种RAID配置下的可用存储容量。

**RAID 10 (1+0)**

- **配置**: RAID 10 是一个由 RAID 1 和 RAID 0 组成的嵌套阵列。在这种配置中，首先创建镜像对（RAID 1），然后对这些镜像对进行条带化（RAID 0）。
- **磁盘数**: 在 RAID 10 配置中，至少需要4块磁盘。问题中给出的是8块600G磁盘。
- **可用容量**: 在 RAID 10 中，每一个镜像对（2块磁盘）中只有一块磁盘的容量是可用的（因为另一块是镜像）。所以，总的可用容量是 `8 / 2 * 600G = 2400G`。

**RAID 50 (5+0)**

- **配置**: RAID 50 是一个由 RAID 5 和 RAID 0 组成的嵌套阵列。在这种配置中，首先创建 RAID 5 阵列，然后对这些 RAID 5 阵列进行条带化（RAID 0）。
- **磁盘数**: 在最简单的 RAID 50 配置中，至少需要6块磁盘（每个 RAID 5 阵列至少3块，然后至少需要两个这样的阵列）。问题中给出的是8块600G磁盘。
- **可用容量**: 在一个 RAID 5 阵列中，一个磁盘的容量用于奇偶校验。假设我们有两个 RAID 5 阵列，每个包含4个磁盘，那么每个阵列中会有3个磁盘的容量是可用的。总的可用容量是 `2 * (3 * 600G) = 3600G`。

综上，8块600G磁盘分别作RAID 10和RAID 50时，整个虚拟盘的可用容量分别是2400G和3600G。



**RAID（冗余独立磁盘阵列，Redundant Array of Independent Disks）**是一种用于将多个硬盘驱动器组合成一个单一的逻辑单元的数据存储虚拟化技术。其主要目的是提高数据可靠性、容错能力和/或提高数据访问性能。

以下是几种常见的RAID级别：

### RAID 0（条带化）

- **组成**：至少需要2个磁盘。
- **性能**：提供最高的读写性能，但没有冗余。
- **可用容量**：所有磁盘容量的总和。

### RAID 1（镜像）

- **组成**：需要偶数数量的磁盘。
- **性能**：读取性能良好，写入性能可能较差。
- **可用容量**：单个磁盘的容量（其他磁盘用于镜像）。

### RAID 5（带奇偶校验的条带化）

- **组成**：至少需要3个磁盘。
- **性能**：读取性能良好，写入性能一般。
- **可用容量**：（N-1）个磁盘的容量。

### RAID 6（双奇偶校验）

- **组成**：至少需要4个磁盘。
- **性能**：读取性能良好，写入性能较差。
- **可用容量**：（N-2）个磁盘的容量。

### RAID 10（或1+0，镜像+条带化）

- **组成**：需要偶数数量的磁盘，最少4个。
- **性能**：读写性能都很优秀。
- **可用容量**：总容量的一半。

### RAID 50（或5+0，RAID 5 + 条带化）

- **组成**：通常需要6个或更多的磁盘。
- **性能**：读写性能都很优秀。
- **可用容量**：大约是（N-2）个磁盘的容量，但这取决于子阵列的配置。

### 相关设备和技术

- **硬件RAID**：使用专门的硬件控制器进行RAID运算。
- **软件RAID**：使用操作系统内的软件进行RAID运算。

RAID可以在多种环境中使用，包括服务器、网络附加存储（NAS）设备和存储区域网络（SAN）。



![image-20231020125959987](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125959987.png)

**临界资源（Critical Resource）**是在并发编程中，多个线程或进程不能同时访问或修改的资源。这些资源通常包括共享变量、数据结构、外部设备，或者是一些用于维护程序逻辑的系统资源。因为多个线程或进程访问这些资源可能导致数据的不一致或者是其他的未定义行为，所以需要特殊的机制来同步和协调对这些资源的访问。

例如，在操作系统中，文件、打印机、数据库记录等都可以是临界资源。在多线程程序中，共享变量或数据结构也可能成为临界资源。

为了管理对临界资源的访问，通常使用以下同步机制：

1. **互斥锁（Mutex）**：确保一次只有一个线程或进程可以访问临界资源。
2. **信号量（Semaphore）**：允许有限数量的线程或进程同时访问临界资源。
3. **读写锁（Read-Write Locks）**：允许多个读操作同时进行，但写操作是独占的。
4. **条件变量（Condition Variables）**：用于等待某个特定条件成立才访问临界资源。
5. **自旋锁（Spinlock）**：当资源被占用时，线程会不断检查是否可以获得资源，而不是进入休眠。
6. **死锁检测与预防**：避免多个线程或进程相互等待对方释放资源，导致整个系统停滞。
7. **优先级调度和反向优先级继承**：用于解决优先级反转问题，即低优先级的线程占用了高优先级线程所需的临界资源。
8. **事务和数据库锁**：在数据库环境中用于确保数据的一致性。

对临界资源的访问需要仔细设计和高度警觉，以避免出现竞态条件、死锁或其他同步问题。



**在 CD 光盘上标记有“ CD-RW ”字样，“ RW ”标记表明该光盘是（）。**

在CD光盘上标记有“CD-RW”字样时，“RW”标记表明该光盘是可重写（Rewritable）的。这意味着你不仅可以将数据写入这种类型的光盘，还可以擦除和重新写入数据。这与CD-R（只读记录）光盘不同，CD-R光盘只允许你一次性地写入数据，之后就不能再进行修改或删除。

CD-RW光盘常用于数据备份、临时存储和文件传输等。但由于它们通常具有相对较低的读/写速度和较高的成本，以及由于USB闪存驱动器和网络存储越来越普及，CD-RW的使用已经相对减少。



![image-20231020130141974](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130141974.png)

在程序运行时，磁盘与主机之间的数据传送通常是通过DMA（Direct Memory Access，直接内存访问）方式进行的，即选项B。

解释如下：

A. 中断方式：这种方式是CPU负责从磁盘读取数据，并将其放入内存中。每次读取或写入一个数据块后，CPU会收到一个中断，通知它数据已准备好或已成功写入。这种方式会占用大量CPU时间。

B. DMA方式：在这种方式下，专门的DMA控制器负责将数据从磁盘传输到内存（或反之），而CPU则可以继续执行其他任务。当整个传输完成后，DMA控制器会发出一个中断来通知CPU。这种方式更为高效，因为它不会占用大量的CPU资源。

C. 陷阱：这是一种特殊的软件中断，通常用于操作系统内核和用户程序之间的交互，而不是用于数据传输。

D. 程序直接控制：这是一种非常低级的数据传输方式，需要程序直接控制硬件进行数据传输，通常不用于磁盘和主机之间的数据交换。





**死锁发生的条件**


产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



![image-20231020130438467](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130438467.png)

CPU不直接访问的存储器通常是外部存储器，例如硬盘、SSD、光盘、磁带等。这些类型的存储器需要通过I/O接口和相应的驱动程序来进行数据的读写操作。

解释如下：

1. 主存（RAM）：CPU可以直接访问主存（RAM）以获取指令和数据。
2. 缓存：在现代计算机体系结构中，CPU内部通常有多级缓存（L1, L2, L3等），这些也是CPU可以直接访问的。
3. 寄存器：这些是CPU内部的小容量存储单元，用于临时存储数据和指令，CPU可以非常快速地访问它们。
4. 外部存储器：如硬盘、SSD、光盘、USB驱动器等，这些是CPU不能直接访问的，需要通过操作系统和I/O子系统来访问。
5. 网络存储：如NAS（网络附加存储）、SAN（存储区域网络）等，这些也是CPU不能直接访问的。

因此，CPU不直接访问的存储器主要是外部存储器。



![image-20231020130535179](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130535179.png)

在Windows操作系统中，文件名不能包含以下字符：\ / : * ? " < > |。

![image-20231020131604190](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020131604190.png)

A. Linux

- 多用户和多任务：Linux 是一个支持多用户和多任务的操作系统。
- GPL（GNU General Public License）：Linux 操作系统是基于 GPL 许可的，这意味着你可以自由地使用、修改和重新分发代码。

其他选项的考察：

- B. Windows Server：虽然这是一个多用户、多任务的操作系统，但它不是基于 GPL 许可的。
- C. Windows XP：这是一个面向单用户的桌面操作系统，并且也不是 GPL 许可的。
- D. OS/2：这是一个旧的操作系统，也不是基于 GPL 许可的，而且现在已经很少使用。



![image-20231020131815684](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020131815684.png)

1. **先来先服务（FCFS, First-Come, First-Served）**: 这是最简单的调度算法，但它可能会导致“饥饿”问题，即长作业占据 CPU 导致短作业等待时间过长。

2. **轮转（Round Robin, RR）**: 这种调度算法适用于时间片很小的系统，并且每个作业都能很快地得到处理。但是它并没有特别偏向于短作业或长作业。

3. **最高响应比优先（HRRN）**: 这种调度算法考虑了作业等待时间和服务时间，从而计算出一个响应比。作业的响应比越高，作业就越优先被调度。这样就既照顾了短作业（因为它们的服务时间短），也照顾了等待时间长的作业（因为它们的等待时间长，响应比会增加）。

   高响应比优先算法既有利于短作业，长作业在经过长时间等待之后，优先级得到提高，最终也将获得CPU调度执行，不会被饿死。故而，有利于短作业，长作业也不会长期得不到执行。

4. **均衡调度**: 这不是一个标准的作业调度算法名称，它更多的是一个目标或者概念，即尽量使得系统资源得到均衡的利用。



![image-20231020131940801](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020131940801.png)

1. **切换上下文（Context Switching）**: 分派程序负责保存当前正在运行进程的状态，以便稍后可以再次加载和执行。这一步被称为上下文切换。
2. **切换到用户模式（Switch to User Mode）**: 分派程序在上下文切换之后，通常会将 CPU 从内核模式切换到用户模式，以便执行用户进程。
3. **重启进程（Restart Process）**: 分派程序也负责设置好所有必要的寄存器，以便进程可以从上次停止的地方重新开始执行。
4. **进程调度（Process Scheduling）**: 这通常是长程调度程序（也称为作业调度程序）或短程调度程序（也称为 CPU 调度程序）的职责，而不是分派程序的任务。分派程序负责在调度决策做出之后，将 CPU 分配给选定的进程。



**在计算机中，组成一个字节的二进制位位数是（ 8）**

![image-20231021005407172](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021005407172.png)

A. 耗时的操作使用线程，提高程序响应

- 这是正确的。线程可以并行地执行任务，这样一来，即使一个操作耗时，它也不会阻塞整个程序的执行。这有助于提高程序的响应性。

B. 耗内存的操作使用线程，提高内存利用率

- 这是错误的。使用线程并不会自动提高内存利用率。实际上，创建更多的线程可能会增加内存消耗，因为每个线程都有自己的堆栈和一些线程特定的数据。如果操作本身就是耗内存的，使用线程可能会使问题更糟。

C. 多CPU的系统使用线程，提高CPU利用率

- 这是正确的。在多核（多CPU）系统中，多线程可以实现真正的并行执行，从而提高CPU的利用率。

D. 并行操作使用线程，如c/s架构中服务端程序为每个客户端请求创建一个线程来响应

- 这也是正确的。在客户端/服务器（C/S）架构中，服务端通常为每个客户端请求创建一个线程，以便并行地处理多个请求。

  

![image-20231021140626728](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021140626728.png)

**多级页表（也叫多级页目录或分级页表）**主要是为了解决单级页表在处理大型地址空间时所面临的一些限制。具体来说，当一个进程有一个非常大的虚拟地址空间时，单级页表可能会非常大，即使进程只使用了其中的一小部分。

A. 它减少了读取或写入内存的访问时间。

- 这个说法通常是不正确的。多级页表通常会增加地址转换的时间，因为你需要访问多个页表来找到物理地址。

B. 它有助于减少实现进程的虚拟地址空间所需的页表大小。

- 这是正确的。多级页表可以更灵活地管理内存，减少整个页表的大小。这是因为你不再需要为整个虚拟地址空间分配一个巨大的连续的页表，而是可以用多个小页表来动态地表示使用中的地址范围。

C. 它是翻译后备缓冲区所必需的。

- 这是不正确的。Translation Lookaside Buffer（TLB，翻译后备缓冲区）是一个硬件缓存，用于存储最近使用的虚拟地址到物理地址的映射，以减少访问页表所需的时间。它与是否使用多级页表没有直接关系。

D. 它有助于减少页面替换算法中的页面错误数量。

- 这也是不正确的。多级页表的主要优势在于内存管理的灵活性和页表大小的减小，而不是在页面错误或页面替换算法的效率方面。



![image-20231021141114231](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021141114231.png)

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021141323098.png" alt="image-20231021141323098" style="zoom:67%;" />

![image-20231021141503715](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021141503715.png)

在分页存储管理系统中，操作系统把物理内存划分为固定大小的块，称为"页帧"，并且把每个进程的虚拟地址空间也划分为同样大小的"页"。操作系统维护一个页表来跟踪虚拟页和物理页帧之间的映射。

现在考虑把页面大小增加一倍的情况。这样做有以下几个影响：

1. **更少的页表项**：因为每个页面现在更大，所以需要更少的页表项来映射同样大小的地址空间。
2. **更大的内存块**：更大的页面意味着每次访问内存时能够加载更多的数据，这可能减少缺页中断的次数。这是因为如果一个程序的内存访问是局部性的（即近期访问过的地址可能会再次被访问），一个大的页面可能包含多个即将被访问的地址。
3. **内存浪费**：更大的页面也意味着更高的内存浪费，因为最后一个页面可能只部分被用到，但仍需要分配一个完整的页面。

关于是否缺页中断次数会减少50%这一点，这很难做出一般性的结论。实际影响取决于多种因素，包括程序的内存访问模式、可用物理内存的大小，以及操作系统的页面替换算法等。因此，无法肯定地说缺页中断次数一定会减少50%。



![image-20231021141606737](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021141606737.png)

1. **多道批处理（Multiprogramming Batch Systems）**：在这种系统中，多个作业（程序）被装入内存并且依次执行。但该系统并没有设计为在一定时间内响应用户请求。
2. **单道批处理（Uniprogramming Batch Systems）**：只有一个程序在内存中执行。同样，这种系统也没有设计为及时响应用户请求。
3. **分时系统（Time-Sharing Systems）**：多个用户可以通过终端与系统交互，系统会分时地处理每个用户的请求。虽然分时系统比批处理系统更倾向于及时响应，但它们并不保证在一定时间内完成。
4. **实时系统（Real-Time Systems）**：这种系统是设计用来在一定时间内对用户请求给出响应的。实时系统通常用于控制外部环境的应用，需要及时处理输入数据并给出输出以满足实时约束。



一进程刚获得3个主存块的使用权，若该进程访问页面的次序是{1,2,3,4,1,2,5,1,2,3,4,5}。当采用先进先出调度算法时，**发生缺页次数是( 9 )次**

在**先进先出（FIFO）页面替换算法**中，当发生缺页（页面不在物理内存中）时，操作系统会替换最早进入物理内存的页面。

初始情况下，进程获得了3个主存块，因此最多可以存储3个页面。

让我们逐步考察进程访问页面的次序：{1,2,3,4,1,2,5,1,2,3,4,5}。

1. **1**: 首次访问，缺页，加载到内存。状态：[1, _, _]（下划线表示空块）。
2. **2**: 缺页，加载到内存。状态：[1, 2, _]。
3. **3**: 缺页，加载到内存。状态：[1, 2, 3]。
4. **4**: 缺页，替换页面1（最早进入的）。状态：[4, 2, 3]。
5. **1**: 缺页，替换页面2。状态：[4, 1, 3]。
6. **2**: 缺页，替换页面3。状态：[4, 1, 2]。
7. **5**: 缺页，替换页面4。状态：[5, 1, 2]。
8. **1**: 页面1已在内存中，无缺页。
9. **2**: 页面2已在内存中，无缺页。
10. **3**: 缺页，替换页面5。状态：[3, 1, 2]。
11. **4**: 缺页，替换页面3。状态：[4, 1, 2]。
12. **5**: 缺页，替换页面4。状态：[5, 1, 2]。

总共，有9次缺页中断。

因此，当采用先进先出调度算法时，发生缺页次数是9次。

![image-20231021142542027](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021142542027.png)

对一个进程来说,一个重要的指标是它执行所需要的时间. 

从进程提交到进程完成的时间间隔为周转时间.也就是等待进入内存的时间,在就绪队列中等待的时间,在 CPU中执行的时间和I/O操作的时间的总和. 

![image-20231021142904069](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021142904069.png)

**卷积码**是一种差错控制编码，是一种有记忆的纠错码，编码规则是将k个信息比特编码形成n个比特，编码后的n个码元不但与当前输入的k个信息有关，仍与之前的L-1组的信息有关。 

**循环校验码(CRC码)**，是数据通信领域中最常用的一种**差错校验码**，其特征是信息字段和校验字段的长度可以任意选定。接收端收到的信息按发送端形成循冗余码同样的算法进行校验，如果发现错误，**则通知发送端重发。** 

**海明码**在传输的消息流中插入验证码，当计算机存储或移动数据时，可能会产生数据位错误，以**侦测并更正单一比特错误。** 

**奇偶校验(Parity Check)**是一种**校验代码传输正确性的方法**。根据被传输的一组二进制代码的数位中"1"的个数是奇数或偶数来进行校验，采用奇数的称为奇校验，反之，称为偶校验。能够检测出信息传输过程中的部分误码(奇数位误码能检出，偶数位误码不能检出)，同时，它不能纠错。在发现错误后，只能要求重发。

![image-20231021143059476](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021143059476.png)

**预防死锁有3种方法：**

**1.采用资源的静态预分配策略，破坏“部分分配”条件；**

**2.允许进程剥夺使用其他进程占有的资源破坏“不可剥夺”条件；**

**3.采用资源有序分配法，破坏“环路”条件** 



在操作系统中，死锁是由四个必要条件（又称**Coffman**条件）组成的：

1. **互斥（Mutual Exclusion）**: 资源不能被多个进程同时使用。
2. **占有并等待（Hold and Wait）**: 进程已经占有了至少一个资源，但又申请新的资源，而新资源被其他进程占有。
3. **不可剥夺（No Preemption）**: 已经分配给进程的资源在未使用完之前不能被剥夺，只能由占有该资源的进程自行释放。
4. **环路等待（Circular Wait）**: 存在一个进程资源的环形链，形如P0等待P1占用的资源，P1等待P2占用的资源，......，Pn等待P0占用的资源。

采用资源的有序分配法解决死锁问题的原理是破坏了**“环路等待（Circular Wait）”条件**。在有序分配法中，所有资源都是有序编号的，每个进程需要按照这一编号顺序申请资源。这样就可以避免出现环路等待的情况。

因此，正确答案是：

C. 环路



### 预防和解决死锁的方法

1. **预防死锁**：
   - **破坏互斥条件**: 这通常是不可能的，因为大多数资源（如打印机，CPU，内存空间等）都是不可共享的。
   - **破坏占有并等待条件**: 要求进程一开始就申请所有需要的资源。
   - **破坏不可剥夺条件**: 如果进程正在等待其他资源，系统可以剥夺它已经拥有的资源，使其回退。
   - **破坏环路等待条件**: 资源编号，并要求进程按编号顺序申请资源。
2. **解决死锁**：
   - **死锁检测与恢复**: 运行系统检测死锁，一旦检测到，就终止或回滚一些进程以破坏死锁。
   - **资源预分配**: 在作业开始前，预分配所有必需的资源。如果不能满足要求，作业就不会开始。
   - **进程回退**: 将进程状态回退到某一安全点，以便重新分配资源。
   - **杀死进程**: 最极端的方法是直接终止涉及死锁的进程。



![image-20231021143447185](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021143447185.png)

在单处理器计算机系统中，处理器（CPU）在任何给定时刻只能执行一个任务。然而，某些操作可以看似并行地进行，这主要是通过时间分片和上下文切换实现的。具体到各个选项：

1. **处理机操作和通道操作是并行的（A）**: 在一些计算机体系结构中，确实存在这样的可能性。例如，在I/O通道或DMA（Direct Memory Access）控制器的支持下，CPU可以在处理其他任务的同时进行I/O操作。
2. **程序与程序（B）**: 在单处理器系统中，多个程序看似是并行运行的，但实际上是通过快速上下文切换实现的，因此不是真正的并行操作。
3. **主程序与子程序（C）**: 主程序和子程序通常是由同一个处理器按照调用顺序执行的，因此也不是并行的。
4. **用户程序与操作系统程序（D）**: 操作系统可以通过中断和上下文切换在用户程序和内核代码之间快速切换，但在单处理器系统中，这两者不会真正并行执行。

在这些选项中，只有"处理机操作和通道操作是并行的（A）"最接近真正的并行操作，因为CPU可以继续执行其他任务，而I/O操作（例如，通过DMA或I/O通道）可以与之同时进行。

![image-20231021143621199](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021143621199.png)

![image-20231021144154226](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021144154226.png)

显示当前目录所在的位置的命令是 `pwd`（Print Working Directory）。该命令用于在终端中显示用户当前所在的目录路径。

各选项的作用：

- **ls (A)**：列出当前目录下的文件和文件夹，但不会显示当前目录所在的位置。
- **ls -R (B)**：递归地列出当前目录以及所有子目录下的文件和文件夹，但同样不会显示当前目录所在的位置。
- **pwd (C)**：打印（显示）当前工作目录的全路径名，这正是题目所问的。
- **ls -F (D)**：列出当前目录下的文件和文件夹，并在每个条目后添加一个用于指示该条目类型的字符（如 `/` 表示目录，`*` 表示可执行文件等）。



![image-20231021144615594](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021144615594.png)

处于运行状态的操作系统程序通常应放在主存（RAM）中。这是因为CPU直接从主存中获取和执行指令。将操作系统程序放在主存中能够确保快速的访问和执行。以下是对各选项的解析：

- **寄存器中（A）**: 寄存器是非常有限的并且位于CPU内部，用于存放少量但经常访问的数据和指令。因其数量和容量的限制，通常不会用来存储整个操作系统程序。
- **主存中（B）**: 主存（通常是RAM）是用于存储当前运行的程序和数据的内存。它由CPU直接访问，因此访问速度快。操作系统程序处于运行状态时，通常会被加载到主存中。
- **辅存中（C）**: 辅存（如硬盘驱动器或SSD）用于长期存储数据和程序，包括操作系统本身。但当操作系统或其他程序需要运行时，它们会被加载到主存中。



![image-20231021145930298](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021145930298.png)

### 实时调度算法（A）

实时调度算法是为了满足实时系统的需要而设计的。这些算法通常有严格的时间限制和优先级规定，但它们不一定总是关注平均响应时间。因此，实时调度算法不一定是平均响应时间最优的。

### 短任务优先算法（B）

短任务优先算法（Shortest Job First, SJF）或短进程优先算法（Shortest Process Next, SPN）是一种调度算法，其中CPU被分配给预计运行时间最短的进程。这种算法在非抢占模式下通常能够实现最优的平均响应时间，因为它首先处理那些能最快完成的任务。

### 时间片轮转算法（C）

时间片轮转算法（Round Robin, RR）是一种抢占式调度算法，其中每个进程被分配一个固定大小的时间片或量子。当一个进程的时间片用完时，它被放回就绪队列，而CPU则分配给下一个进程。这种算法适用于时间共享系统，但它不是非抢占的，也不一定能实现最优的平均响应时间。

### 先来先服务算法（D）

先来先服务（First-Come, First-Served, FCFS）算法是最简单的调度算法，其中第一个到达的进程首先获得CPU。这种方法易于理解和实现，但可能导致“饥饿”问题，即长任务可能会阻止短任务快速完成，从而增加平均响应时间。



![image-20231021150651468](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021150651468.png)



![image-20231021150726014](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021150726014.png)

**物理地址=内存块号*块长+页内地址  ；**

在页式存储管理系统中，逻辑地址由页号和页内偏移量组成。题目中指出，逻辑地址为0，这意味着页号为0，页内偏移量也为0。

根据给出的页表，页号0对应的块号（物理页号）为2。

若页的大小为4KB（4096字节），则每个块的大小也是4KB。

物理地址由块号和块内偏移量组成。因为逻辑地址为0，所以页内偏移量（也是块内偏移量）为0。

物理地址 = 块号 × 块的大小 + 块内偏移量 = 2 × 4096 + 0 = 8192 + 0 = 8192

所以，地址转换机构将逻辑地址0转换成物理地址为8192。



![image-20231021150935430](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021150935430.png)

- **静态资源分配法（A）**：在进程开始执行之前，就分配其所需的所有资源，这样就能消除“占有并等待”和“环路等待”条件。然而，这种方法会导致资源利用率低。
- **动态资源分配法（B）**：这不是一种有效的死锁预防机制，因为在动态分配的过程中仍然可能会发生死锁。
- **资源顺序分配法（C）**：所有资源都按某种全局顺序进行编号，进程必须按编号顺序请求资源。这种方式破坏了“环路等待”条件。
- **非剥夺控制法（D）**：这其实不是死锁预防的方法，因为在非剥夺条件下更容易发生死锁。
- **剥夺控制法（E）**：如果一个进程持有一些资源但无法获得其他所需资源，则它必须释放已占有的资源，以便其他进程可以使用。这破坏了“不可剥夺”条件。

### 静态资源分配法是什么？

静态资源分配法意味着在进程开始执行之前，就为其分配所有必需的资源。一旦这些资源被分配，进程就会持续占用它们，直至完成执行。这消除了死锁产生的“占有并等待”和“环路等待”条件，因为没有进程会在运行时请求更多资源。但这种方法的缺点是资源利用率很低，并可能导致资源浪费。

### 资源顺序分配法是什么？

资源顺序分配法要求系统中的所有资源按照某种全局顺序进行编号或排序。当一个进程需要多个资源时，它必须按照这个顺序请求资源。通过这种方式，系统避免了环形等待的可能性，从而预防了死锁。这是因为环形等待条件需要一个环形的资源请求序列，而按照全局顺序请求资源则不可能形成这样的环。



![image-20231021151559265](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021151559265.png)

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021151635342.png" alt="image-20231021151635342" style="zoom:50%;" />



![image-20231021151913505](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021151913505.png)



计算机硬件系统主要包括控制器、运算器、存储器、输入设备、输出设备、接口和总线等。

常见的输入设备有鼠标、键盘、扫描仪、条形码阅读器、触摸屏、手写笔、麦克风、摄像头和数码相机等。

常见的输出设备包括显示器、打印机、绘图仪、音响、耳机、视频投影仪等。因此答案选择 B 。



- **A：光盘驱动器属于主机，而光盘属于外设** 光盘驱动器通常被视为一个外设，因为它不是计算机主机板上的一部分。光盘是存储介质，通常也被认为是外设的一部分。

- **B：摄像头属于输入设备，而投影仪属于输出设备** 这个描述是正确的。摄像头用于捕获视频，是一个输入设备。投影仪用于显示图像或视频，是一个输出设备。

- **C：U盘即可以用作外存，也可以用作内存** U盘通常用作外部存储设备（或称为辅助存储）。它不能直接用作内存（即RAM），虽然某些操作系统允许你使用U盘作为"就绪提升"或虚拟内存，但这并不意味着它变成了内存。

- **D：硬盘是辅助存储器，不属于外设** 硬盘通常是辅助存储器（或称为外存），但它也是一个外设，除非它是集成在主板上的（这种情况非常罕见）。

  

![image-20231021152549150](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021152549150.png)

 系统观点——计算机资源的管理者 

  用户观点——用户使用计算机的界面 

  软件观点——程序和数据结构的集合



![image-20231021160336035](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021160336035.png)

1. **磁盘空间大小（A）**: 虽然磁盘空间可以用作交换空间或页面文件来扩展虚拟内存，但它不是决定因素。理论上，磁盘空间可以是非常大的。
2. **物理内存大小（B）**: 虚拟存储技术就是为了解决物理内存大小不足的问题而出现的。物理内存大小限制了可立即访问的数据量，但不限制虚拟存储的容量。
3. **数据存放的实际地址（C）**: 这通常不是限制因素，因为虚拟存储系统会负责管理数据在物理存储介质（如RAM、磁盘等）上的实际位置。
4. **计算机地址位数（D）**: 这通常是最关键的限制因素。例如，在32位系统中，地址空间最大为4GB，这限制了虚拟存储的最大容量。对于64位系统，这个限制要大得多，理论上可以达到18.4 million TB，从而使得其他因素（如磁盘空间或物理内存）相对来说影响较小。

![image-20231021160531022](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231021160531022.png)

首先，解决问题中的选项：当计算机提供了箐态（系统态）和目态（用户态）时，输入/输出指令（D）必须在管态（也就是系统态）下执行。

### 系统态（箐态）、用户态（目态）和管态：

#### 系统态（也称为内核态、特权态或管态）：

- 在这个状态下，CPU可以执行所有类型的指令，包括系统调用、I/O 操作和硬件访问等。
- 操作系统核心通常在系统态下运行。
- 系统态下有权访问受保护的系统资源。

#### 用户态：

- 在这个状态下，执行的代码受到一些限制，不能直接访问硬件或执行某些特权指令。
- 应用程序通常在用户态下运行。
- 如果用户态的代码需要进行如 I/O 操作、内存访问等特权操作，它需要通过系统调用来请求内核在系统态下为其执行这些操作。

#### 管态：

- 这个术语通常是系统态的另一种称呼，含义与系统态相同。

在多态的操作系统中，用户态和系统态是为了安全和有效管理系统资源而设立的。用户态下的程序有限制，不能直接执行可能会影响系统安全和稳定性的操作。这样的设计可以防止恶意或错误的用户级程序对系统造成损害。

因此，一些特权操作，如输入/输出指令，通常只能在系统态下执行。



在计算机系统中，系统态（或内核态、特权态）和用户态是两种不同的CPU运行模式，各自有不同的功能和权限。

### 系统态（内核态）：

1. **访问硬件资源**：如磁盘、内存、网络接口卡等。
2. **系统调用执行**：执行一些特权级高的操作，如进程创建和销毁、文件操作、I/O控制等。
3. **中断处理**：响应硬件中断和软件中断。
4. **调度任务**：进行进程或线程的调度。
5. **内存管理**：例如，页表的维护，虚拟内存到物理内存的映射。
6. **资源分配**：为进程或任务分配必要的系统资源。
7. **安全控制**：执行与安全性有关的操作，比如设置或修改访问权限。

### 用户态：

1. **应用执行**：运行用户程序，如文本编辑器、游戏、Web浏览器等。
2. **数据计算**：进行数学运算、文本处理等。
3. **网络访问**：通过系统调用来实现，如HTTP请求。
4. **文件操作**：虽然文件的打开、关闭、读、写等需要系统调用，但这些操作通常由运行在用户态的应用程序发起。
5. **简单I/O操作**：一些不涉及硬件直接访问的I/O操作也可以在用户态完成。
6. **IPC（进程间通信）**：通过系统调用，用户态的程序可以进行进程间的数据传输。
7. **调用API和库函数**：执行预先定义好的功能，这些API和库函数最终可能会转换为一系列系统调用。

总体而言，用户态主要用于运行应用程序并执行非特权操作，而当需要执行特权操作时，会通过系统调用切换到系统态。这种机制保证了操作系统的稳定性和安全性。在系统态下，操作系统可以全面控制硬件和执行关键的系统操作，而在用户态下，应用程序则在一个相对受限的环境中运行，以减少对系统整体稳定性或安全性的潜在影响。