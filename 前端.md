# HTML

- HTML 指的是超文本标记语言: **H**yper**T**ext **M**arkup **L**anguage
- HTML 不是一种编程语言，而是一种**标记**语言
- 标记语言是一套**标记标签** (markup tag)
- HTML 使用标记标签来**描述**网页
- HTML 文档包含了HTML **标签**及**文本**内容
- HTML文档也叫做 **web 页面**

### HTML 标签

HTML 标记标签通常被称为 HTML 标签 (HTML tag)。

- HTML 标签是由*尖括号*包围的关键词，比如 <html>
- HTML 标签通常是*成对出现*的，比如 <b> 和 </b>
- 标签对中的第一个标签是*开始标签*，第二个标签是*结束标签*
- 开始和结束标签也被称为*开放标签*和*闭合标签*

### 基础的HTML页面元素-网页结构

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027132644213.png" alt="image-20231027132644213" style="zoom:67%;" />

<img src="https://www.runoob.com/wp-content/uploads/2013/06/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="img" style="zoom: 50%;" />

在构成一个基础的HTML页面中，有几个必要或者说基础的元素，这些元素构成了HTML页面的骨架。下面是这些基础元素的简要概述：

#### DOCTYPE

`<!DOCTYPE html>`

这不是一个HTML标签，但它告诉浏览器你正在使用的是HTML5。这应该是你HTML文件的第一行。

```
<!DOCTYPE html>
```

`<!DOCTYPE>`（Document Type Declaration）是一种用于 HTML 文档中的指令，它告诉浏览器该文档使用哪种 HTML 规范（或“文档类型”）编写。这有助于浏览器准确地解析和渲染文档。它通常放置在 HTML 文档的第一行，位于 `<html>` 标签之前。

**作用和意义**

1. **标准模式与怪异模式**：`<!DOCTYPE>` 的存在或缺失，以及它的具体类型，会影响浏览器是以“标准模式”（Standards Mode）还是“怪异模式”（Quirks Mode）来渲染页面。标准模式更接近 W3C 的规范，而怪异模式会兼容一些过时的布局规则。
2. **版本指示**：在早期的 HTML 和 XHTML 版本中，`<!DOCTYPE>` 用于指定文档符合哪个 HTML/XHTML 规范。例如，HTML 4.01、XHTML 1.0 等。
3. **解析准确性**：正确的 `<!DOCTYPE>` 有助于防止浏览器对标记进行错误的解析。

**常见类型**

- **HTML5**：在现代网页中最常见，简单并推荐使用。

  ```
  <!DOCTYPE html>
  ```

- **HTML 4.01 Strict、Transitional 和 Frameset**

  ```
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
  ```

- **XHTML**：虽然现在用得少，但在一些旧项目中可能还会见到。

  ```
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  ```

doctype 声明是不区分大小写的。



#### `<html>`

这个元素是所有其他HTML元素的容器。它通常包含两个子元素：`<head>` 和 `<body>`。

```
<html>
  <!-- head and body go here -->
</html>
```

`<head>`

这个元素包含了关于文档的元数据（metadata），这些信息不会显示在页面内容中。常见的子元素有 `<title>`、`<meta>`、`<link>`、`<script>` 等。

```
<head>
  <title>Page Title</title>
</head>
```

`<title>`

这个元素定义了浏览器窗口的标题或者页面在搜索引擎结果中的标题。它是 `<head>` 区域的一个重要组成部分。

```

<title>This is the page title</title>
```

`<meta>`

元数据标签用于提供有关页面的各种信息，如字符集、作者、描述等。

```
<meta charset="UTF-8">
<meta name="description" content="This is a description">
```

`<body>`

这个元素包含了所有要显示给用户的内容，包括文本、图像、视频、游戏、可播放轨迹、等等。

```
<body>
  <!-- your content goes here -->
</body>
```



**其他可选但常用的元素**

虽然下面的元素不是严格“必要”的，但它们经常出现在实际页面中：

- `<header>`：用于包含页面或区域的标题和其他信息。

- `<footer>`：用于包含页面或区域的页脚信息。

- `<nav>`：用于包含页面导航链接。

- `<main>`：用于包含页面的主要内容。

  

**完整的最小示例**

一个包含所有这些基础元素的最小HTML页面可能看起来像这样：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Page Title</title>
  </head>
  <body>
    <!-- your content goes here -->
  </body>
</html>
```



### 行内元素（Inline Elements）和块级元素（Block-level Elements）



#### 块级元素（Block-level Elements）

**特点：**

1. **占据整行**: 块级元素在页面上占据新的一行，前后会有换行符。
2. **宽度默认为父元素的100%**: 除非你设置了它们的宽度。
3. **高度自动**: 默认情况下，高度是由它们包含的内容来决定的。
4. **可嵌套**: 可以嵌套行内元素和其他块级元素。
5. **外边距和内边距（Margin 和 Padding）**: 可以设置上下左右的外边距和内边距。

**常见的块级元素：**

- `<div>`
- `<h1>, <h2>, ..., <h6>`
- `<p>`
- `<ul>, <ol>, <li>`
- `<form>`
- `<header>, <footer>, <section>, <article>`
- `<table>`

#### 行内元素（Inline Elements）

**特点：**

1. **不独占一行**: 它们可以与其他行内元素或文本在同一行内显示。
2. **宽度和高度**: 由内容决定，不能手动设置。
3. **无法嵌套块级元素**: 通常只能嵌套文本或其他行内元素。
4. **外边距和内边距**: 只能设置左右的外边距和内边距，上下的无效。

**常见的行内元素：**

- `<span>`

- `<a>`

- `<img>`（注意：虽然是行内元素，但 `<img>` 的宽度和高度是可以设置的）

- `<button>`

- `<input>`

- `<label>`

- `<strong>, <em>, <b>, <i>`

  

**可以通过 CSS 进行转换**

通过设置`display`属性为`inline`或`block`，你可以改变元素的类型。

```
/* 把 div 转为行内元素 */
div {
  display: inline;
}

/* 把 span 转为块级元素 */
span {
  display: block;
}
```

#### 空元素



空元素（Empty Elements）是HTML中一类特殊的元素，它们没有内容和闭合标签。这意味着它们由单一的标签组成，该标签中可能包含属性，但没有开始和结束之间的文本或其他元素。这类元素也被称为自闭合元素（Self-closing Elements）。

**常见的空元素：**

- `<img>`：用于嵌入图像。
- `<br>`：插入一个换行。
- `<hr>`：创建一个水平线。
- `<input>`：用于表单的输入字段。
- `<meta>`：提供有关网页的元信息。
- `<link>`：用于链接外部资源，通常用于链接CSS文件。
- `<area>`：在图像映射中定义一个区域。
- `<base>`：定义页面中所有相对URL的基础URL。
- `<col>`：定义`<colgroup>`元素内的一列属性。
- `<source>`：用于`<video>`和`<audio>`元素，以提供媒体资源。
- `<wbr>`：建议浏览器在此位置添加换行（如果需要）。
- `<command>`：表示用户可以调用的命令。
- `<keygen>`：用于生成一个密钥对控件（现已废弃）。
- `<param>`：为`<object>`元素定义参数。

**语法注意点：**

在HTML5中，空元素的标签不需要尾随的斜线（`/`），尽管在XHTML或更严格的XML结构中可能需要这样做。

```
<!-- HTML5中有效的空元素标记 -->
<img src="image.jpg" alt="An image">
<br>
<hr>

<!-- XHTML中，可能需要添加尾随的斜线 -->
<img src="image.jpg" alt="An image" />
<br />
<hr />
```



### HTML 属性

- HTML 元素可以设置**属性**
- 属性可以在元素中添加**附加信息**
- 属性一般描述于**开始标签**
- 属性总是以名称/值对的形式出现，**比如：name="value"**。



#### 常见的全局属性（Global Attributes）

全局属性是可以应用于所有 HTML 元素的属性。

- `class`: 用于为元素指定一个或多个类名，通常用于 CSS 样式或 JavaScript。
- `id`: 用于为元素指定一个唯一的标识符。
- `style`: 用于内联 CSS 样式。
- `title`: 用于给元素添加额外的信息，通常会在鼠标悬停时显示。
- `data-*`: 自定义数据属性，用于存储额外的信息。
- `lang`: 用于定义元素的语言。
- `dir`: 用于定义文本方向，如 `"ltr"`（从左到右）或 `"rtl"`（从右到左）。

#### 特定元素的属性

某些属性仅适用于特定的 HTML 元素。

`<a>` 元素

- `href`: 超链接引用，定义链接的目标 URL。
- `target`: 定义如何打开链接，比如 `_blank` 会在新窗口中打开。

`<img>` 元素

- `src`: 图像源 URL。
- `alt`: 替换文本，用于在图像无法显示时提供信息。
- `width` 和 `height`: 定义图像的尺寸。

`<table>` 元素

- `rowspan`: 定义单元格在垂直方向上跨越的行数。
- `colspan`: 定义单元格在水平方向上跨越的列数。

`<form>` 元素

- `action`: 提交表单数据到该 URL。
- `method`: 定义数据提交的 HTTP 方法（`GET` 或 `POST`）。

`<input>` 元素

- `type`: 定义输入字段的类型（如 `text`, `password`, `checkbox` 等）。

- `name`: 定义输入字段的名称。

- `value`: 定义输入字段的初始值。

- `placeholder`: 定义输入字段的占位符文本。

  > **文本类型**
  >
  > - `text`: 普通的单行文本输入。
  > - `password`: 用于密码，输入的文本会被遮住。
  > - `search`: 用于搜索字段。
  > - `tel`: 用于输入电话号码。
  >
  > **数字类型**
  >
  > - `number`: 用于输入数字，浏览器通常会提供一个微调控件（spinner control）。
  > - `range`: 用于输入一个范围内的数字，通常呈现为滑块。
  >
  > **日期和时间类型**
  >
  > - `date`: 用于选择日期，通常会显示一个日期选择控件。
  > - `time`: 用于选择时间。
  > - `datetime-local`: 用于选择日期和时间，没有时区信息。
  > - `month`: 用于选择月份和年份。
  > - `week`: 用于选择周和年份。
  >
  > **文件**
  >
  > - `file`: 用于文件上传。
  >
  > **选择**
  >
  > - `checkbox`: 复选框。
  > - `radio`: 单选按钮。
  > - `color`: 颜色选择器。
  >
  > **特殊类型**
  >
  > - `email`: 用于电子邮件地址，浏览器可能会进行格式验证。
  > - `url`: 用于网址，浏览器可能会进行格式验证。
  >
  > **按钮**
  >
  > - `button`: 一般的按钮，没有默认行为。
  > - `submit`: 提交按钮，会提交表单。
  > - `reset`: 重置按钮，会重置表单字段到初始值。
  >
  > **隐藏类型**
  >
  > - `hidden`: 用于存储不需要显示给用户的数据。
  >
  > **图像**
  >
  > - `image`: 定义图像形式的提交按钮。

`<ol>` 和 `<ul>` 元素

- `type`: 定义列表项（`<li>`）标记的类型。
- `start`: 定义有序列表（`<ol>`）的起始数字。



### 文本格式化

```
<em>强调文本</em><br>
<strong>加粗文本</strong><br>
<dfn>定义项目</dfn><br>
<code>一段电脑代码 print("Hello World")</code><br>
<samp>计算机样本</samp><br>
<kbd>键盘输入</kbd><br>
<var>变量</var>
```

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027135456858.png" alt="image-20231027135456858" style="zoom:67%;" />

### 链接

HTML 使用超级链接与网络上的另一个文档相连。

HTML中的链接是一种用于在不同网页之间导航的元素。

链接通常用于将一个网页与另一个网页或资源（如文档、图像、音频文件等）相关联。

链接允许用户在浏览网页时单击文本或图像来跳转到其他位置，从而实现网页之间的互联。

### href、src区别

在HTML（HyperText Markup Language）中，`href` 和 `src` 是两个用于建立链接的常用属性，但它们有几个关键区别。

#### `href` (HyperText Reference)

- **用途**：`href` 属性用于在HTML元素（通常是`<a>`，`<link>`，或`<base>`标签）中定义一个链接的目标URL。

  ```
  <a href="https://www.example.com">Visit Example.com</a>
  ```

- **行为**：`href` 创建的是一个引用或者连接到其他资源的链接，但不会嵌入内容。

- **适用元素**：主要用于 `<a>`、`<link>`、`<base>` 等标签。

- **关联资源**：用于关联文档、样式表、网址等。

#### `src` (Source)

- **用途**：`src` 属性用于嵌入外部资源，通常是图像、视频、脚本等。

  ```
  <img src="image.jpg" alt="An example image">
  ```

- **行为**：与`href` 不同，`src` 用于嵌入内容，这意味着外部资源会成为文档的一部分。

- **适用元素**：主要用于 `<img>`、`<script>`、`<iframe>`、`<audio>`、`<video>` 等标签。

- **关联资源**：用于嵌入图像、脚本、视频、音频等。

#### **区别**

1. **用途不同**：`href` 用于建立到其他页面或资源的链接，而 `src` 用于嵌入内容。
2. **行为不同**：`href` 只是建立一个到其他页面或文件的链接，而不会将其作为当前页面的一部分。而 `src` 实际上会将外部资源嵌入到当前文档中。
3. **适用元素不同**：`href` 主要用于 `a`, `link`, `base` 等元素，而 `src` 主要用于 `img`, `script`, `iframe` 等。
4. **浏览器处理方式不同**：使用 `href` 的时候，浏览器会识别该资源为当前文档的一部分，但不会阻止文档的加载；而使用 `src` 的时候，浏览器会暂停文档的加载，直到外部资源被加载和执行（例如脚本）。

### link，@import

**`<link>` 标签**

1. **HTML 层面引入**: `<link>` 是一个 HTML 标签，因此它是在 **HTML** 文件中定义的。

   ```
   
   <link rel="stylesheet" type="text/css" href="styles.css">
   ```

2. **更高的加载优先级**: 由于 `<link>` 是 HTML 的一部分，**浏览器会在解析 HTML 文档的同时立即下载并应用样式。**

3. **支持多种媒体类型**: 你可以通过 `media` 属性指定媒体查询，以确定何时使用该样式表。

   ```
   
   <link rel="stylesheet" type="text/css" href="print.css" media="print">
   ```

4. **DOM 可访问**: 由于 `<link>` 是 DOM 的一部分，你可以用 JavaScript 动态改变它的属性。

5. **并行下载**: 多个 `<link>` 标签的样式文件可以并行下载，不会阻塞页面渲染。

   

**`@import` 规则**

1. **CSS 层面引入**: `@import` 是在 **CSS** 文件中使用的，因此必须放在 CSS 文件或 `<style>` 标签中。

   ```
   
   @import url('styles.css');
   ```

2. **较低的加载优先级**: 由于 `@import` 是 CSS 的一部分，**浏览器必须首先加载并解析外部 CSS 文件，然后才会下载 `@import` 引入的文件。**

3. **支持媒体类型**: 跟 `<link>` 类似，你也可以在 `@import` 语句中指定媒体查询。

   ```
   
   @import url('print.css') print;
   ```

4. **不易于动态修改**: 虽然技术上可能，但用 JavaScript 动态改变 `@import` 规则相对更复杂。

5. **可能的串行下载**: 依赖于浏览器和网络状况，`@import` 引入的文件可能会串行下载，这可能会导致页面渲染的延迟。

**总结**

- `<link>` 更适用于生产环境，因为它允许并行下载，加载更快，而且更容易与 JavaScript 互动。
- `@import` 可能更适用于测试或开发环境，或者当你想将多个样式表组合成一个时。







### 版本区别

| 版本      | 发布年份 | 主要特点与功能                                               |
| --------- | -------- | ------------------------------------------------------------ |
| HTML 2.0  | 1995     | - 基础的 HTML 结构和标签<br>- 包括标题、段落、列表和链接等基本元素 |
| HTML 3.2  | 1997     | - 脚本支持（JavaScript）<br>- 样式表（CSS）<br>- 增加了表格和对齐选项 |
| HTML 4.0  | 1997     | - 更多的 CSS 支持<br>- 丰富的表单控制<br>- 文档元数据和链接关系的元素 |
| HTML 4.01 | 1999     | - HTML 4.0 的修订版<br>- 解决了一些错误和进行了微小的更新    |
| XHTML 1.0 | 2000     | - 以 XML 格式编写<br>- 更严格的语法要求（如标签必须小写、必须关闭等） |
| XHTML 1.1 | 2001     | - 基于 XHTML 1.0 的改进<br>- 模块化结构                      |
| HTML5     | 2014     | - 语义化元素（如 `<header>`、`<footer>` 等）<br>- 多媒体支持（`<audio>`、`<video>`）<br>- 新的 API |
| HTML 5.1  | 2016     | - 细化和扩展了 HTML5 的特性<br>- 添加了新的布局和表单选项    |
| HTML 5.2  | 2017     | - 增加和修改了 HTML5.1 的特性<br>- 引入了新的 API 和安全特性 |



### iframe

'<iframe> '是一个 HTML 标签，用于在当前 HTML 文档中嵌入另一个 HTML 页面。这个内嵌的 HTML 页面有自己独立的 DOM、CSS 和 JavaScript 上下文环境。<iframe> 在许多应用场景中都非常有用，例如嵌入第三方应用、视频、地图或其他多媒体内容。.

**基础语法**

基础的 `<iframe>` 元素大致如下：

```

<iframe src="https://example.com" width="600" height="400"></iframe>
```

- `src`: 指定要嵌入的页面的 URL。
- `width` 和 `height`: 指定 `<iframe>` 的宽度和高度。

**主要属性**

除了 `src`、`width` 和 `height` 外，`<iframe>` 还有其他一些重要的属性：

- `sandbox`: 用于增加安全性，可以限制内嵌页面的一些行为。
- `frameborder`: 指定是否显示边框（在 HTML5 中，建议使用 CSS 来设置这个选项）。
- `scrolling`: 指定是否显示滚动条。
- `name`: `<iframe>` 的名称，用于脚本和链接。

**安全性和限制**

虽然 `<iframe>` 很有用，但也存在一些安全风险，例如点击劫持（Clickjacking）。因此，许多现代浏览器都提供了一些安全性措施：

- 同源策略（Same-Origin Policy）：默认情况下，嵌入的内容不能访问父页面的 DOM。
- `X-Frame-Options` HTTP 头：网站可以使用这个选项来阻止其内容被嵌入到 `<iframe>` 中。

**应用场景**

1. **嵌入第三方应用**: 如社交媒体插件或支付网关。
2. **多媒体内容**: 例如 YouTube 视频。
3. **网站内导航**: 在一个页面内展示另一个子页面。
4. **广告**: 嵌入外部广告内容。



### 页面的加载和渲染过程

![image-20231019131744151](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231019131744151.png)



## 异步编程

### async

`defer` 和 `async` 都是与异步编程和并发有关的概念。

`defer`

1. **JavaScript 中的 `defer`**: 在 HTML 和 JavaScript 中，`defer` 是一个属性，通常与 `<script>` 标签一起使用。它告诉浏览器先解析完文档再执行脚本。

   ```
   <script defer src="script.js"></script>
   ```

`async`

1. **JavaScript 的 `async/await`**: 在 JavaScript 中，`async` 用来声明一个函数是异步的，意味着它返回一个 `Promise`。`await` 关键字用于等待这个 `Promise` 完成。

   ```
   async function fetchData() {
       const response = await fetch('https://api.example.com/data');
       const data = await response.json();
       return data;
   }
   ```

   在这个例子中，`fetchData` 函数是一个异步函数，内部有两个 `await` 表达式用于等待异步操作完成。

2. **Python 的 `async/await`**: Python 的 `asyncio` 库也使用 `async` 和 `await` 关键字，与 JavaScript 的用法类似但适用于 Python 的异步编程模型。

   ```
   import asyncio
   
   async def main():
       await asyncio.sleep(1)
       print("Hello, World!")
   
   asyncio.run(main())
   ```

3. **其他语言**: 在其他编程语言中，`async` 关键字或者类似的概念也可能存在，通常用于声明一个函数或操作是异步的。

总结，`defer` 主要用于确保某些操作在函数退出时执行，用于资源管理和清理。而 `async` 主要用于异步编程，使得你能够更容易地编写非阻塞代码。





### 同源策略

同源策略（Same-Origin Policy）是一种在网页脚本计算中实施的安全措施，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

两个URL要被认为是“**同源**”，必须满足以下三个条件：

1. **协议相同**：例如，都是HTTP或都是HTTPS。
2. **域名相同**：例如，都是www.example.com。
3. **端口相同**：例如，都是80端口或都是443端口。

只有当这三个条件都满足时，两个URL才被认为是“同源”。



**解决同源问题（Same-Origin Policy issues）**

1. **服务器端解决方案**

**CORS（跨源资源共享）**：最直接的解决方案是在服务器端设置HTTP头部，以允许特定的跨源请求。

```

Access-Control-Allow-Origin: *
```

或者只允许特定域：

```

Access-Control-Allow-Origin: https://www.example.com
```

**代理服务器**：使用一个后端服务器作为代理，转发来自前端的请求到目标服务器，并返回响应。因为前端和代理服务器是同源的，所以这样可以绕过同源限制。



2. **客户端解决方案**

**Document.domain**：当两个页面有相同的主域（但不同子域）时，可以通过设置 `document.domain = "example.com"` 来实现它们之间的通信。

**Window.postMessage**：这是一个用于安全跨源通信的HTML5 API。源可以发送消息，并在接收端对消息和源进行验证。

**WebSocket**：WebSocket协议不受同源策略的限制，因此可以用于跨域通信。但服务器必须支持WebSocket连接。



### `window` 对象

`window` 对象在浏览器环境中是一个非常重要和常用的对象。它代表了浏览器窗口，并包含了许多用于与浏览器窗口和其内部的文档互动的属性和方法。

**基础知识**

- `window` 对象是JavaScript在浏览器环境中的全局对象。这意味着在浏览器环境中，全局变量和函数都是 `window` 对象的属性和方法。
- `window` 对象同时也是文档对象模型（DOM）的入口点，你可以通过 `window.document` 访问到 `document` 对象。

**重要的属性和方法**

1. **DOM 操作**：`window.document` 允许你访问和操作DOM。
2. **定时器**：`setTimeout()` 和 `setInterval()` 用于执行延迟和定时操作。
3. **浏览器信息**：`navigator` 和 `location` 对象提供了关于浏览器和当前URL的信息。
4. **窗口控制**：`open()`, `close()`, `moveTo()`, `resizeTo()` 等方法用于控制浏览器窗口。
5. **会话和本地存储**：`localStorage` 和 `sessionStorage` 属性用于在浏览器中存储键值对。
6. **跨文档通信**：`postMessage()` 方法用于安全地实现跨源通信。

**示例**

1. 获取窗口尺寸

   ```js
   const width = window.innerWidth;
   const height = window.innerHeight;
   ```

2. 操作 DOM

   ```js
   const title = window.document.title;
   window.document.body.appendChild(someElement);
   ```

3. 使用定时器

   ```js
   window.setTimeout(function() {
     console.log("Hello, world!");
   }, 3000);
   ```





### 常见图片格式

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027132952563.png" alt="image-20231027132952563" style="zoom:50%;" />



# CSS



# JavaScript



### null、NaN 和 undefined

#### `null`

- **语义**：`null` 表示“没有值”或“空”。当你想明确地表示某个变量没有值时，可以使用 `null`。

- **用途**：经常用于初始化变量，表示该变量尚未引用任何对象或值。也常用于对象属性或数组中表示空的槽。

- **类型**：虽然 `typeof null` 会返回 `"object"`，但这其实是JavaScript中的一个历史错误。

  ```
  let a = null;
  typeof a; // "object"（历史错误）
  ```

使用 instanceof：null instanceof Object 返回 false。

#### `NaN` (Not-a-Number)

- **语义**：`NaN` 用于表示一个不能表示为合法数字的值。通常是在数学运算失败时出现，如将字符串减去数字。

- **用途**：用于表示数学运算的错误结果而不是抛出异常。JavaScript提供了 `isNaN()` 函数来检查一个值是否是 `NaN`。

- **类型**：它是一个特殊的 `Number` 类型。

  ```
  let a = "text" / 3;
  isNaN(a); // true
  typeof a; // "number"
  ```

- **特殊性**：`NaN` 是唯一一个不等于自己的值。

  ```
  
  NaN === NaN; // false
  ```

- 使用 `instanceof`：`NaN instanceof Number` 返回 `false`，因为 `NaN` 是 `Number` 类型的一个特殊值，但它不是 `Number` 对象的实例。

#### `undefined`

- **语义**：当一个变量被声明但没有被赋值时，其默认值为 `undefined`。它表示“未定义”或“不存在”。

- **用途**：常用于检查变量是否已赋值或对象属性或数组元素是否存在。

- **类型**：`typeof undefined` 会返回 `"undefined"`。

  ```
  let a;
  typeof a; // "undefined"
  ```

- 使用 `instanceof`：由于 `undefined` 不是一个对象，所以 `undefined instanceof AnyConstructor` 总是返回 `false`。

- **与 `null` 的区别**：`null` 是一个表示“无”的对象，`undefined` 表示一个**变量没有被初始化**。

**比较**

- `null == undefined` 返回 `true`，因为 `==` 运算符会进行类型转换。
- `null === undefined` 返回 `false`，因为 `===` 运算符（全等运算符）要求类型和值都相同。

```
null == undefined  // true
null === undefined // false
```



### ===，==

**JavaScript**

- `==`：**宽松相等运算符**。这意味着它在比较时会进行**类型转换**。例如，字符串 `'5'` 和数字 `5` 会被认为是相等的。

  ```
  '5' == 5  // true
  null == undefined  // true
  ```

- `===`：**严格相等运算符**。这意味着不进行任何类型转换，所以类型和值都必须相等。

  ```
  '5' === 5  // false
  null === undefined  // false
  ```

**Java**

- `==`：在Java中，这个操作符用于**基本数据类型（如 `int`、`char` 等）的值比较和引用类型（如对象）的引用比较**。对于对象，`==` 比较的是两个引用**是否指向内存中的同一个对象实例**。

  ```
  int a = 5;
  int b = 5;
  a == b  // true
  
  String str1 = new String("hello");
  String str2 = new String("hello");
  str1 == str2  // false
  ```

- `equals()`：Java中通常使用 `equals()` 方法来比较**两个对象的内容是否相等**。这是一个可以在任何对象上调用的方法，并且可以根据需要重写。

  ```
  
  str1.equals(str2)  // true, assuming equals() is properly overridden
  ```

  

**Python**

- `==`：在Python中，这个操作符用于**比较两个对象的值是否相等**。不同类型的对象也可以被认为是相等的，只要它们的值是相等的（这取决于该类型如何实现 `__eq__()` 方法）。

  ```
  5 == 5  // true
  '5' == 5  // false
  ```

- `is`：Python中的 `is` 运算符用于比较两个对象是**否是同一个对象**（即比较它们的内存地址）。这类似于Java中的 `==` 运算符在对象上的行为。

  ```
  a = [1, 2, 3]
  b = [1, 2, 3]
  a == b  // true
  a is b  // false
  ```

总结一下，不同语言中的 `==` 和 `===`（或类似的操作符和方法）有各自的行为和用途。在JavaScript中，`==` 和 `===` 主要是用来进行值的比较，其中 `===` 是严格相等运算符，需要类型也相同。在Java中，`==` 可用于基本数据类型的值比较和对象引用的比较，而 `equals()` 用于比较对象的内容。在Python中，`==` 用于值比较，`is` 用于引用比较。



### 类型转换

JavaScript是一种**弱类型语言**

#### 隐式类型转换（Coercion）

当运算符在操作不同类型的变量时，JavaScript会自动转换其中一个类型，以完成操作。这就是所谓的隐式类型转换。

- **字符串拼接**：当你尝试拼接字符串和非字符串时，非字符串会被转换为其字符串表示形式。

  ```
  
  "Hello, " + 42  // "Hello, 42"
  ```

- **数学运算**：在加减乘除等运算中，非数字通常会被转换为数字。

  ```
  "5" - 1  // 4
  "5" + 1  // "51" (注意：加法运算符会触发字符串拼接)
  ```

- **比较运算**：使用 `==` 运算符进行比较时，JavaScript会尝试转换操作数的类型。

  ```
  
  "5" == 5  // true
  ```

- **逻辑运算**：在逻辑表达式（如 `if` 语句）中，某些值会被转换为其布尔表示形式。

  ```
  
  if ("string") { /* 这个块会执行，因为非空字符串为真 */ }
  ```



#### 显式类型转换

除了隐式类型转换外，你也可以明确地转换变量的类型。

- **使用 `String()`，`Number()` 和 `Boolean()` 函数**

  ```
  String(42)  // "42"
  Number("42")  // 42
  Boolean(0)  // false
  ```

- **使用 `parseInt()` 和 `parseFloat()`**

  ```
  parseInt("42px")  // 42
  parseFloat("42.2em")  // 42.2
  ```

- **使用一元 `+` 和 `-` 运算符进行数值转换**

  ```
  +"42"  // 42
  -"42"  // -42
  ```

- **使用 `!!` 运算符进行布尔转换**

  ```
  !!42  // true
  !!0  // false
  ```

- **使用 `.toString()` 方法转为字符串**

  ```
  
  (42).toString()  // "42"
  ```



**特殊情况**

- `null` 和 `undefined` 在数学运算和比较运算中有特殊的转换规则。

  ```
  null + 1  // 1
  undefined + 1  // NaN
  ```

- `NaN`（Not-a-Number）是一个特殊的数值，**任何涉及 `NaN` 的数学运算都将返回 `NaN`。**

  ```
  NaN + 1  // NaN
  ```

- 对象、数组和函数在转换时会有特殊的行为。

  ```
  [1, 2, 3] + 4  // "1,2,34"
  ```



### 事件（Events）

在JavaScript中，事件是浏览器或用户自身执行的某种动作，如点击、加载、鼠标移动等。你可以使用 `addEventListener` 方法来监听一个特定元素上的事件，并指定当该事件触发时运行的函数。

```
document.getElementById("myBtn").addEventListener("click", function() {
  alert("Button clicked!");
});
```

#### 事件传播的三个阶段

事件在DOM（Document Object Model）中的传播通常分为三个主要阶段：**捕获阶段（Capturing Phase）、目标阶段（Target Phase）和冒泡阶段（Bubbling Phase**）。

**1. 捕获阶段（Capturing Phase）**

- **开始点**：事件传播的捕获阶段从最顶层的父元素（通常是`document`对象）开始。

- **传播方向**：事件会沿着DOM树由上而下地传播，直到达到触发该事件的元素。

- **用途**：捕获阶段较少用于实际的事件处理，但在需要在事件到达目标元素之前进行某种预处理时可能会用到。

- **如何监听**：在使用`addEventListener`方法添加事件监听器时，可以设置第三个参数为`true`，表示在捕获阶段触发。

  ```
  element.addEventListener("click", function() {
    console.log("Capturing phase");
  }, true);
  ```

**2. 目标阶段（Target Phase）**

- **焦点**：当事件传播到达实际触发该事件的元素时，它处于目标阶段。

- **特点**：这一阶段是捕获阶段和冒泡阶段之间的临界点。

- **用途**：这一阶段通常用于具体的事件处理逻辑。

- **如何监听**：`addEventListener`默认就是在目标阶段触发的。

  ```
  element.addEventListener("click", function() {
    console.log("Target phase");
  });
  ```

**3. 冒泡阶段（Bubbling Phase）**

- **开始点**：事件从触发该事件的元素开始。

- **传播方向**：事件会由下而上，逐级向外传播，直到最顶层的父元素。

- **用途**：冒泡阶段通常用于事件委托，可以在一个共同的父元素上设置一个事件监听器，用于处理多个子元素的事件。

- **如何监听**：在使用`addEventListener`方法添加事件监听器时，可以设置第三个参数为`false`或者省略该参数，表示在冒泡阶段触发。

  ```
  element.addEventListener("click", function() {
    console.log("Bubbling phase");
  }, false);
  ```



**冒泡机制（Event Bubbling）**

冒泡机制是DOM（文档对象模型）事件传播的一种方式。当一个元素上的事件被触发时，该事件不仅仅会作用于这个元素，还会“冒泡”到这个元素的父元素，再到父元素的父元素，依此类推，直到达到`document`对象。这样做的一个主要好处是，你可以在一个共同的父元素上设置一个事件监听器，用于处理多个子元素的事件，这被称为事件委托。

```
<div id="parent">
  <button id="child">Click me!</button>
</div>

document.getElementById("parent").addEventListener("click", function() {
  alert("Parent Div Clicked!");
});

document.getElementById("child").addEventListener("click", function() {
  alert("Button Clicked!");
});
```

在这个例子中，如果你点击了按钮（即 "Button Clicked!"），你也会看到 "Parent Div Clicked!" 的弹窗。这是因为事件从按钮开始，然后冒泡到其父元素，也就是`div`元素。

