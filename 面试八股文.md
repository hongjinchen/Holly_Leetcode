





# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）**: 单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

   在单例模式的实现中，通常会：

   1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
   2. 创建一个私有静态成员变量，用于保存单一实例。
   3. 提供一个公共静态方法来获取这个唯一的实例。

2. **工厂方法模式（Factory Method）**: 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个接口用于创建对象，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

   工厂方法模式主要包括以下几个组件：

   1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
   2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
   3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
   4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

   如何实现

   1. **定义一个返回对象（Product）的工厂接口（Creator）**。
   2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
   3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

   ```python
   from abc import ABC, abstractmethod
   
   # Product 类
   class Button(ABC):
   
       @abstractmethod
       def click(self):
           pass
   
   # ConcreteProduct 类
   class WindowsButton(Button):
       
       def click(self):
           print("Windows button clicked")
   
   class LinuxButton(Button):
       
       def click(self):
           print("Linux button clicked")
   
   # Creator 类
   class ButtonFactory(ABC):
       
       @abstractmethod
       def create_button(self):
           pass
   
   # ConcreteCreator 类
   class WindowsButtonFactory(ButtonFactory):
       
       def create_button(self):
           return WindowsButton()
   
   class LinuxButtonFactory(ButtonFactory):
       
       def create_button(self):
           return LinuxButton()
   
   # 客户端代码
   def button_client_code(factory):
       button = factory.create_button()
       button.click()
   
   # 使用
   windows_factory = WindowsButtonFactory()
   button_client_code(windows_factory)
   
   linux_factory = LinuxButtonFactory()
   button_client_code(linux_factory)
   
   ```

   

3. **抽象工厂模式（Abstract Factory）**: 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

   **结构和组件**

   1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

   2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

   3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

   4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

      

      1. **定义抽象产品的接口（AbstractProduct）**。

      2. **创建实现该接口的具体产品（ConcreteProduct）**。

      3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

      4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

      5. **使用具体工厂和抽象工厂来创建产品实例**。

         

      ```python
      from abc import ABC, abstractmethod
      
      # 抽象产品
      class Button(ABC):
          @abstractmethod
          def click(self):
              pass
      
      class Checkbox(ABC):
          @abstractmethod
          def check(self):
              pass
      
      # 具体产品
      class WindowsButton(Button):
          def click(self):
              print("Windows Button clicked")
      
      class WindowsCheckbox(Checkbox):
          def check(self):
              print("Windows Checkbox checked")
      
      class LinuxButton(Button):
          def click(self):
              print("Linux Button clicked")
      
      class LinuxCheckbox(Checkbox):
          def check(self):
              print("Linux Checkbox checked")
      
      # 抽象工厂
      class GUIFactory(ABC):
          @abstractmethod
          def create_button(self):
              pass
      
          @abstractmethod
          def create_checkbox(self):
              pass
      
      # 具体工厂
      class WindowsGUIFactory(GUIFactory):
          def create_button(self):
              return WindowsButton()
      
          def create_checkbox(self):
              return WindowsCheckbox()
      
      class LinuxGUIFactory(GUIFactory):
          def create_button(self):
              return LinuxButton()
      
          def create_checkbox(self):
              return LinuxCheckbox()
      
      # 客户端代码
      def client_code(factory):
          button = factory.create_button()
          checkbox = factory.create_checkbox()
          
          button.click()
          checkbox.check()
      
      # 使用
      windows_factory = WindowsGUIFactory()
      client_code(windows_factory)
      
      linux_factory = LinuxGUIFactory()
      client_code(linux_factory)
      
      ```

      

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

### 结构型模式（Structural Patterns）

1. **适配器模式（Adapter）**: 允许不兼容的接口可以一起工作。
2. **装饰器模式（Decorator）**: 在不改变对象本身的基础上，动态地添加额外的功能。
3. **组合模式（Composite）**: 将对象组合成树形结构以表示“部分-整体”的层次结构。

### 行为型模式（Behavioral Patterns）

1. **观察者模式（Observer）**: 当一个对象的状态发生变化时，其依赖者都会得到通知。
2. **策略模式（Strategy）**: 定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。
3. **命令模式（Command）**: 将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。



# Git

### 初始化和配置

1. **`git init`**：在当前目录下初始化一个新的 Git 仓库。
2. **`git config`**: 用于设置 Git 配置信息。

### 克隆和远程操作

1. **`git clone [url]`**：克隆（复制）一个远程仓库到本地。
2. **`git remote`**: 用于管理远程仓库。
3. **`git fetch`**: 获取远程仓库的最新版本，但不合并。
4. **`git pull`**: 获取并合并远程仓库的最新版本。

### 文件和状态操作

1. **`git status`**: 显示工作目录和暂存区的状态。
2. **`git add [file]`**: 将文件添加到暂存区。
3. **`git rm [file]`**: 从版本控制中移除文件。

### 提交和历史

1. **`git commit`**: 提交暂存区的文件。
2. **`git log`**: 查看提交历史。
3. **`git revert`**: 回滚到之前的提交。

### 分支和标签

1. **`git branch`**: 列出、创建或删除分支。
2. **`git checkout [branch]`**: 切换到指定分支。
3. **`git merge [branch]`**: 将指定分支合并到当前分支。
4. **`git tag`**: 用于操作标签。

### 其他

1. **`git stash`**: 临时保存当前的修改。
2. **`git reset`**: 重置当前分支到某个状态。
3. **`git diff`**: 查看文件差异。





## 美团面试真题

### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）





### 如果需要访问多个域名，那么可以如何节省网络消耗？

**DNS预解析（DNS Prefetch）**

预解析可以预先进行DNS查询，减少实际请求时的DNS解析时间。

```
<link rel="dns-prefetch" href="//example.com">
```

**预连接（Preconnect）**

预连接不仅会预解析DNS，还会预先进行TCP握手和TLS协商。

```
<link rel="preconnect" href="https://example.com">
```

**数据压缩**

使用Gzip或Brotli等压缩算法可以减少传输的数据量。

**使用HTTP/2或HTTP/3**

这些新版本的HTTP协议提供了多路复用、头部压缩等特性，可以减少网络消耗。

**使用持久连接（Keep-Alive）**

通过复用TCP连接，你可以减少TCP握手所需的时间和带宽。

**优化资源**

- **合并文件**：将多个小的CSS或JavaScript文件合并为一个大文件，以减少HTTP请求的数量。
- **异步加载**：对于非关键资源，可以使用异步加载来减少初始页面加载所需的时间。
- **懒加载**：对于例如图片这样的大资源，使用懒加载可以延迟加载直到用户实际需要。

**缓存**

充分利用浏览器缓存和服务器缓存可以减少重复请求，从而减少网络消耗。

**限制重定向**

尽量减少或避免使用重定向，因为每次重定向都会消耗额外的网络资源。



### 对测试开发的理解以及他们日常会做什么工作

测试开发（Test Development 或 Test Automation Development）是软件测试的一个子领域，专注于通过编程来自动化测试过程。测试开发不仅涉及编写自动化测试脚本，还包括设计和维护自动化测试框架、与开发团队紧密合作以提高软件质量，以及参与持续集成（CI）和持续交付（CD）流程。下面详细地介绍一下测试开发的一些核心职责和他们日常可能会做的工作。

**核心职责**

1. **自动化测试脚本编写**：使用编程语言（如 Python、Java 等）和自动化测试工具（如 Selenium、Appium、Junit 等）来编写测试脚本。
2. **测试框架设计与维护**：设计和建立自动化测试框架，以便更容易、更快捷地编写和运行测试脚本。
3. **测试用例设计**：与需求分析师、产品经理和开发人员合作，理解新功能或改动，然后设计相应的测试用例。
4. **持续集成与持续交付（CI/CD）**：将自动化测试脚本融入CI/CD管道，确保每次代码更改都能自动触发相关测试。
5. **代码审查与质量保证**：参与代码审查，以确保测试代码质量；同时也关注产品代码，帮助开发人员提高代码质量。
6. **性能测试**：使用工具如 JMeter 进行性能、压力和负载测试。
7. **文档编写与维护**：编写测试报告和文档，以记录测试计划、测试用例和测试结果。

**日常工作流程**

1. **需求分析**：在一个迭代或开发周期开始时，与团队成员一起了解即将开发或修改的功能。
2. **测试计划与用例设计**：根据需求分析结果，制定测试计划并设计测试用例。
3. **环境准备**：设置和维护测试环境，包括数据准备、服务器配置等。
4. **编写与调试测试代码**：按照测试用例编写自动化测试脚本，并进行调试。
5. **执行测试**：运行测试脚本，手动或自动地执行测试用例。
6. **结果分析与报告**：分析测试结果，找出问题并编写测试报告。
7. **缺陷跟踪与修复**：与开发人员一起跟踪和修复在测试中发现的缺陷。
8. **代码提交与CI/CD**：将测试代码提交到版本控制系统，并确保它被纳入CI/CD流程。
9. **回归测试与维护**：在软件发布后，进行回归测试以确保新添加或修改的代码没有引入新的问题。



### 为什么选择测试开发

自我追求部分

能力匹配部分



1. 技术层面

**全面的技术观点:** 测试开发不仅涉及到测试，还需**理解软件的开发过程**，这为**深入了解整个系统**提供了机会。

**自动化与编程**: 现代测试开发大量依赖自动化，这也意味着有很多编程工作，对于喜欢编程的人来说是个好选择。

2. 问题解决

侦查与调查: **良好的测试能够发现隐藏的问题**，这需要扎实的问题解决能力。

质量保证: 你的工作直接**影响产品质量**，这是个相当有成就感的工作。

6. 学习与成长

- 不断学习: 软件工具和方法论不断更新，需要持续学习。
- 多元化的挑战: **测试开发会接触到多种类型的项目和问题**，这有助于个人成长



### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。





### OSI七层协议

OSI（Open Systems Interconnection）模型是一个概念框架，用于标准化网络协议的不同功能层。该模型将网络协议分为七个不同的层次，以促进不同协议和设备间的互操作性。下面是各层的概述：

1. **物理层（Physical Layer）**: 这一层主要处理与物理媒体相关的细节，比如电缆、交换机、网卡等。主要任务是数据比特流（bits）的传输。
2. **数据链路层（Data Link Layer）**: 在物理层之上，数据链路层负责创建一个可靠的链路连接，主要负责 MAC（Media Access Control） 地址和帧的封装与解封装。
3. **网络层（Network Layer）**: 这一层负责数据包的路由和传输，即如何从源到目的地。**IP 协议**就工作在这一层。
4. **传输层（Transport Layer）**: 主要负责端到端（End-to-End）的数据传输和流量控制。**TCP 和 UDP 协议**就工作在这一层。
5. **会话层（Session Layer）**: 该层负责在数据传输中设置和维护会话。
6. **表示层（Presentation Layer）**: 主要负责数据格式的转换或加密。例如，将 EBCDIC 编码转换为 ASCII 编码。
7. **应用层（Application Layer）**: 这一层负责处理特定的应用程序细节。常见的应用层协议包括 **HTTP、FTP、SMTP** 等。

**TCP 和 HTTP 分别属于哪一层？**

- **TCP（Transmission Control Protocol）**: 通常被认为是传输层的一部分。它负责提供可靠、顺序的点对点通信。

- **HTTP（HyperText Transfer Protocol）**: 是应用层的一部分。它定义了客户端和服务器之间如何传送超文本数据。

  

### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。



### Python八股文

#### python的回收机制

Python 使用一种称为引用计数的内存管理机制，以及一个垃圾回收器来清理不再使用的对象。下面我将详细地解释这两个方面。

**引用计数（Reference Counting）**

在 Python 中，每个对象都有一个与之关联的引用计数。当创建一个对象并将其分配给一个变量时，这个对象的引用计数就变为1。如果这个对象被其他变量引用，其引用计数会相应增加。每当一个对象的引用被删除或离开其作用域，引用计数就会减1。当引用计数达到0时，内存就会被释放。

```
pythonCopy code# 创建一个对象（引用计数为 1）
a = [1, 2, 3]

# 引用同一对象（引用计数增加到 2）
b = a

# 解除一个引用（引用计数减少到 1）
del a

# 解除另一个引用（引用计数减少到 0，对象被删除）
del b
```

**垃圾回收（Garbage Collection）**

引用计数有一些局限性，尤其是不能处理引用循环。垃圾回收机制可以检测到这样的循环，并将其打破。

```
pythonCopy code# 创建引用循环
a = {}
b = {}
a['b'] = b
b['a'] = a

# 此时即使 del a 和 del b，a 和 b 仍然存在引用循环，不会被销毁
```

Python 的垃圾回收机制主要基于“代”（Generations）的概念。所有新创建的对象开始时都位于第一代（youngest generation）。如果第一代的对象经过一次垃圾回收仍然存在，则被移动到第二代。同理，第二代对象经过垃圾回收后仍然存在的话，则被移动到第三代。

Python 默认开启垃圾回收机制，但你也可以手动控制它：

- `gc.collect()`：手动运行垃圾回收。
- `gc.set_threshold()`：设置垃圾回收触发的阈值。
- `gc.get_stats()`：获取垃圾回收统计信息。

**综合**

Python 的内存管理机制综合了引用计数和垃圾回收，以达到高效和准确的内存回收。这使得在大多数情况下，开发者可以不必担心内存泄漏，而可以集中精力去解决更有意义的问题。

希望这个详细的解释能帮助你更好地理解 Python 的内存回收机制。



#### **解释型和编译型语言的区别**

- 编译型语言：把做好的源程序全部编译成**二进制**的可运行程序。然后，可直接运行这个程序。如：C，C++ ；
- 解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！如：Python。

####  **简述下 Python 中的字符串、列表、元组和字典**

字符串（**str**）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。
列表（**list**）：列表是有序的集合，可以向其中添加或删除元素。
元组（**tuple**）：元组也是有序集合，元组中的数无法修改。即元组是不可变的。
字典（**dict**）：字典是无序的集合，是由键值对（key-value）组成的。
集合（**set**）：是一组 key 的集合，每个元素都是唯一，不重复且无序的。



#### **字符串常见操作**

1. 切片：`'luobodazahui'[1:3]``

2. ``join`：可以用来连接字符串，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。`'-'.join(['luo', 'bo', 'da', 'za', 'hui'])`

3. `String.replace(old,new,count)`：将字符串中的 `old`字符替换为 `New`字符，`count`为替换的个数 `'luobodazahui-haha'.replace('haha', 'good')`

4. split：切割字符串，得到一个列表

   ```
   >>> mystr5 = 'luobo,dazahui good'
   
   >>> print(mystr5.split())  # 默认以空格分割
   ['luobo,dazahui', 'good']
   
   >>> print(mystr5.split('h'))  # 以h分割
   ['luobo,daza', 'ui good']
   
   >>> print(mystr5.split(','))  # 以逗号分割
   ['luobo', 'dazahui good']
   ```

   

**列表常见操作**

1. 切片，同字符串

2. `append`和 `extend`向列表中添加元素

   ```
   >>> mylist1 = [1, 2]
   >>> mylist2 = [3, 4]
   >>> mylist3 = [1, 2]
   
   >>> mylist1.append(mylist2)
   >>> print(mylist1)
   [1, 2, [3, 4]]
   
   >>> mylist3.extend(mylist2)
   >>> print(mylist3)
   [1, 2, 3, 4]
   ```

   

3. 删除元素

    `del`:根据下标进行删除

   `pop`：删除最后一个元素

   `remove`：根据元素的值进行删除

   ```
   >>> mylist4 = ['a', 'b', 'c', 'd']
   
   >>> del mylist4[0]
   >>> print(mylist4)
   ['b', 'c', 'd']
   
   >>> mylist4.pop()
   >>> print(mylist4)
   ['b', 'c']
   
   >>> mylist4.remove('c')
   >>> print(mylist4)
   ['b']
   ```

   

1. 元素排序 `sort`：是将`list`按特定顺序重新排列，默认为由小到大，参数 `reverse=True`可改为倒序，由大到小。

```
>>> mylist5 = [1, 5, 2, 3, 4]
>>> mylist5.sort()
>>> print(mylist5)
[1, 2, 3, 4, 5]
>>> mylist5.reverse()
>>> print(mylist5)
[5, 4, 3, 2, 1]
```

1. `reverse`：是将`list`逆置。

   

**字典常见操作**

1. 清空字典 `dict.clear()`

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> dict1.clear()
   >>> dict1
   {}
   ```

2. 指定删除：使用 `pop`方法来指定删除字典中的**某一项**（随机的）。

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> d1 = dict1.pop('key1')
   >>> dict1
   {'key2': 2}
   >>> d1
   1
   ```

3. 遍历字典

   ```
   >>> dict2 = {'key1':1, 'key2':2}
   >>> mykey = [key for key in dict2]  # ['key1', 'key2']
   >>> mykey
   ['key1', 'key2']
   >>> myvalue = [value for value in dict2.values()]
   >>> myvalue
   [1, 2]
   >>> key_value = [(k, v) for k, v in dict2.items()]
   >>> key_value
   [('key1', 1), ('key2', 2)]
   ```

4. `fromkeys`用于创建一个新字典，以序列中元素做字典的键，`value`为字典所有键对应的初始值。

```
>>> keys = ['zhangfei', 'guanyu', 'liubei', 'zhaoyun']
>>> dict.fromkeys(keys, 0)
{'zhangfei': 0, 'guanyu': 0, 'liubei': 0, 'zhaoyun': 0}
```



**一行代码实现数值交换**

```
>>> a, b = 1, 2
>>> a, b = b, a
>>> print(a, b)
```



**is 和 == 的区别**

`==`是比较操作符，只是判断对象的**值**（value）是否一致，而 `is` 则判断的是对象之间的身份（**内存地址**）是否一致。对象的身份，可以通过 `id()` 方法来查看。

```
>>> c = d = [1, 2]
>>> e = [1, 2]

>>> print(c is d)
True

>>> print(c == d)
True

>>> print(c is e)
False

>>> print(c == e)
True
```

只有 `id`一致时，`is`比较才会返回 `True`，而当 `value`一致时，`==` 比较就会返回 `True`。



`*arg` 和 `**kwarg` 作用

允许我们在调用函数的时候传入多个实参

```
>>> def test(*arg, **kwarg):
...     if arg:
...         print("arg:", arg)
...     if kwarg:
...         print("kearg:", kwarg)
...
>>> test('ni', 'hao', key='world')
arg: ('ni', 'hao')
kearg: {'key': 'world'}
```



**[lambda x:i*x for i in range(4)]**

```
>>> def num():
...     return [lambda x:i*x for i in range(4)]
...
>>> [m(1) for m in num()]
[3, 3, 3, 3]
```

https://blog.csdn.net/qq_37085158/article/details/126821933



#### python浅拷贝（Shallow Copy）

1. 使用切片操作（只适用于列表和其他序列类型）。

   ```
   original_list = [1, [2, 3], 4]
   copied_list = original_list[:]
   ```

2. 使用 `copy` 模块的 `copy()` 函数。

   ```
   import copy
   copied_object = copy.copy(original_object)
   ```

3. 对于字典，可以使用 `dict.copy()` 方法。

   ```
   original_dict = {'a': 1, 'b': [2, 3]}
   copied_dict = original_dict.copy()
   ```

4. 对于集合，可以使用 `set.copy()` 方法。

   ```
   original_set = {1, 2, 3}
   copied_set = original_set.copy()
   ```



#### python深拷贝（Deep Copy）

深拷贝会复制对象以及其包含的所有嵌套对象。这意味着，生成的新对象是原始对象的完全独立副本。

1. 使用 模块的  函数。

   ```
   deepcopy()
   ```

   ```
   import copy
   deep_copied_object = copy.deepcopy(original_object)
   ```

#### 深拷贝示例

```
import copy

original_list = [1, [2, 3], 4]
deep_copied_list = copy.deepcopy(original_list)

# 修改原始列表
original_list[0] = 0
original_list[1][0] = 0

# 输出两个列表
print("Original:", original_list)  # Output: [0, [0, 3], 4]
print("Deep Copied:", deep_copied_list)  # Output: [1, [2, 3], 4]
```



### JAVA八股文

#### **Java的回收机制（Garbage Collection）**

Java 使用垃圾回收机制自动管理内存，主要目标是识别并回收不再使用的对象。Java中的垃圾收集器通常是后台运行的，它自动地查找不再被引用的对象并释放其占用的内存。

**引用计数（Reference Counting）**



#### **java多态**

多态（Polymorphism）是面向对象编程中的一个重要概念，**它允许你使用一个接口来表示多种数据类型**。在 Java 中，多态主要通过**接口、继承和方法重载来实现**。下面我会详细解释这个概念。

**主要类型：**

1. **编译时多态（静态多态）**：主要是通过方法重载实现的。
2. **运行时多态（动态多态）**：主要是通过继承和接口实现的。

**编译时多态**

方法重载是一种编译时多态。同一个类中可以有多个同名但参数列表不同的方法。

```
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```

**运行时多态**

1. **继承**：子类继承父类，子类对象可以赋值给父类引用。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal makes a sound");
       }
   }
   
   class Dog extends Animal {
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   
   Animal myAnimal = new Dog();  // Dog 对象存储在 Animal 类型的变量中
   myAnimal.makeSound();  // 输出 "Dog barks"
   ```

2. **接口**：一个类可以实现多个接口，接口的实例可以指向实现该接口的任何类的对象。

   ```
   interface Drawable {
       void draw();
   }
   
   class Circle implements Drawable {
       public void draw() {
           System.out.println("Drawing a circle");
       }
   }
   
   Drawable d = new Circle();
   d.draw();
   ```

**优点：**

1. **代码可重用**：你可以编写能以多种方式工作的代码。
2. **可扩展性**：你可以添加新的类型，而不必修改现有的代码。
3. **维护性**：代码结构更清晰，更易于管理和维护。

**注意事项：**

1. 运行时多态在 Java 中是通过虚拟方法表（Virtual Method Table）来实现的，这会带来一定的性能开销。
2. 需要正确地使用方法覆盖（Override）和重载（Overload）。

多态是面向对象编程的四大基本特性之一（封装、继承、多态和抽象）。正确地使用多态可以使代码更灵活、可扩展和易于维护。



#### Java继承

在 Java 中，继承是一种允许我们重用代码和建立类之间关系的机制。通过继承，一个类（称为子类或派生类）可以获得另一个类（称为父类或基类）的字段（变量）和方法。下面详细介绍 Java 中继承的各个方面。

**基础语法**

要创建一个子类，您可以使用 `extends` 关键字：

```
public class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

public class Dog extends Animal {
    // Dog 类继承了 Animal 类
}
```

在这个例子中，`Dog` 类继承了 `Animal` 类，因此 `Dog` 类具有 `Animal` 类的所有非私有属性和方法。您可以创建一个 `Dog` 对象并调用 `makeSound` 方法，即使 `Dog` 类自己并没有定义这个方法：

```
Dog myDog = new Dog();
myDog.makeSound();  // 输出 "Some generic animal sound"
```



**方法覆盖（Method Overriding）**

子类可以提供父类已有方法的特定实现。这被称为方法覆盖。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof woof");
    }
}
```

现在，如果您创建一个 `Dog` 对象并调用 `makeSound` 方法，将输出 "Woof woof"，而不是 "Some generic animal sound"。



**调用父类的方法和构造函数**

子类可以使用 `super` 关键字来调用父类的方法和构造函数。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();
        System.out.println("Woof woof");
    }
}
```



**访问修饰符和继承**

- `private` 成员不会被继承。
- `public` 和 `protected` 成员会被继承，并且在子类中是可访问的。
- 默认（package-private）成员会被继承，但只在同一个包中的子类中是可访问的。



**final 关键字**

如果一个类用 `final` 关键字标记，那么它不能被继承。

```
public final class ImmutableClass {
    // 代码
}
```

同样地，`final` 方法不能在子类中被覆盖。



**Object 类**

在 Java 中，所有类都是 `Object` 类的子类（直接或间接）。这意味着每个 Java 对象都有 `Object` 类的方法，如 `toString()`, `equals()`, `hashCode()` 等。



**抽象类和接口**

- **抽象类**: 定义了一些方法但没有完全实现的类。这些类通常包含抽象方法（没有实现的方法），子类必须提供实现。
- **接口**: 是一种完全抽象的类，它只定义（而不实现）方法。Java 支持多接口继承。



#### Java多线程的实现

在Java中，多线程主要可以通过以下几种方式实现：

**1. 继承 `Thread` 类**

你可以创建一个新类，继承自 `Thread` 类，并重写 `run()` 方法。然后通过创建该类的实例并调用其 `start()` 方法来创建并启动新线程。

```
class MyThread extends Thread {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

**2. 实现 `Runnable` 接口**

你也可以通过实现 `Runnable` 接口来创建多线程。这种方法更为灵活，因为Java不支持多重继承，所以实现接口是一种更好的选择。

```
class MyRunnable implements Runnable {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
```

**3. 使用 `Executor` 框架**

Java的 `java.util.concurrent` 包提供了更高级的多线程支持，包括线程池。

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        executorService.execute(new MyRunnable());
        
        executorService.shutdown();
    }
}
```

**4. 使用 `Callable` 和 `Future`**

如果你需要获取线程执行完毕后的结果，可以使用 `Callable` 接口和 `Future` 类。

```
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Main {
    public static void main(String[] args) throws Exception {
        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "Hello, world!";
            }
        });

        new Thread(futureTask).start();
        
        String result = futureTask.get();
        System.out.println(result);
    }
}
```

注意事项：

1. **线程安全**：当多个线程共享资源时，需要注意线程安全问题。可以使用`synchronized`关键字或其他并发工具类进行同步。
2. **死锁**：避免多个线程相互等待资源，导致程序卡住。
3. **线程间通信**：`wait()`, `notify()`, `notifyAll()` 等方法可用于线程间的基本通信。

多线程编程通常涉及更多复杂的概念，例如线程局部存储、线程优先级、守护线程等。但上述几种方法是最基本和最常用的多线程实现方式。



#### 覆盖（Override）和重载（Overload）

`覆盖（Override）` 和 `重载（Overload）` 是 Java 中两个非常重要的概念，它们在形式和目的上有明显的不同。下面详细解释它们之间的主要区别。

**覆盖（Override）**

1. **定义**: 子类提供了一个与父类方法签名（方法名和参数类型）完全相同的方法。

2. **目的**: 为了改变继承自父类的同名方法的行为。

3. **修饰符**: 必须与父类方法的修饰符相同或更为宽松。例如，如果父类方法是 `protected`，则子类覆盖的方法可以是 `protected` 或 `public`。

4. **返回类型**: 必须与父类方法的返回类型相同或是其子类型。

5. **抛出异常**: 子类覆盖的方法所抛出的异常应该是被父类抛出异常的子集。

6. **运行时行为**: Java 使用运行时多态性来选择要执行的方法版本，即它执行的是对象实际类的方法版本。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal sound");
       }
   }
   
   class Dog extends Animal {
       @Override  // 这个注解是可选的，但有助于编译器检查
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   ```



**重载（Overload）**

1. **定义**: 在同一个类中定义一个与已有方法名相同但参数列表不同的方法。

2. **目的**: 让同一个方法可以有不同类型或数量的参数。

3. **修饰符**: 可以与已有的重载方法有不同的访问修饰符。

4. **返回类型**: 可以与已有的重载方法有不同的返回类型。

5. **抛出异常**: 可以与已有的重载方法有不同的异常抛出列表。

6. **编译时行为**: Java 使用编译时多态性来解析应该调用哪个方法。

   ```
   public class Calculator {
       public int add(int a, int b) {
           return a + b;
       }
   
       public double add(double a, double b) {
           return a + b;
       }
   }
   ```



**主要区别总结**

|                 | 覆盖（Override）           | 重载（Overload）         |
| --------------- | -------------------------- | ------------------------ |
| 方法签名        | 必须与父类相同             | 必须与同类中其他方法不同 |
| 返回类型        | 与父类相同或是其子类型     | 可以不同                 |
| 修饰符          | 不能比父类更严格           | 可以不同                 |
| 所在类          | 子类                       | 同一个类                 |
| 抛出的异常      | 只能是父类异常的子集或相同 | 可以不同                 |
| 运行/编译时行为 | 运行时多态                 | 编译时多态               |

这两个概念在 Java 中是非常基础和重要的，正确理解和使用它们可以使代码更为灵活和可维护。



#### 守护线程和非守护线程

守护线程（Daemon Thread）和非守护线程（Non-daemon Thread）是编程中多线程概念的一部分，特别是在Java和Python这样的编程语言中比较常见。这两种线程的主要区别在于程序是否等待它们执行完成。

**守护线程（Daemon Thread）**

1. **生命周期**：守护线程是一种在后台运行的线程，主要用于执行那些不应阻止程序退出的任务。
2. **程序退出**：一旦程序中所有的非守护线程都结束了，守护线程将被自动终止，即使它们没有完成执行。
3. **用例**：常见的例子包括垃圾回收、日志服务等。

**非守护线程（Non-daemon Thread）**

1. **生命周期**：非守护线程是程序的主要工作线程，用于执行核心任务。
2. **程序退出**：程序会等待所有的非守护线程执行完毕才会退出。
3. **用例**：主程序逻辑、用户交互等。



### 动态分配与静态分配

#### 动态分配

动态分配（Dynamic Allocation）是一种在程序运行时（而非编译时）分配内存空间的方法。这与静态分配相对，静态分配是在程序编译时就确定了内存的大小。动态分配的主要优点是它允许程序更灵活地使用内存，适应不同的数据规模和运行环境。

**为什么需要动态分配？**

在很多情况下，你可能无法预先知道需要多少内存。例如：

1. 当你从文件或网络中读取数据时，数据的大小可能是不确定的。
2. 当你实现数据结构（如链表、树、图等）时，元素的数量可能会动态变化。

在这些情况下，动态分配允许你根据需要分配或释放内存，使得内存使用更为高效。

**如何进行动态分配？**

不同的编程语言提供了不同的机制来进行动态内存分配。

1. C/C++

   : 使用 

   ```
   malloc()
   ```

   , 

   ```
   calloc()
   ```

   , 

   ```
   realloc()
   ```

    和 

   ```
   free()
   ```

    等函数进行内存的动态分配和释放。

   ```
   cCopy codeint *arr = (int*) malloc(10 * sizeof(int)); // 分配一个大小为 10 的整数数组
   free(arr); // 释放内存
   ```

2. Java

   : 使用 

   ```
   new
   ```

    关键字进行对象的动态分配。

   ```
   javaCopy code
   int[] arr = new int[10]; // 分配一个大小为 10 的整数数组
   ```

3. Python

   : 动态分配是自动进行的，你只需创建新的对象即可。

   ```
   pythonCopy code
   arr = [None] * 10  # 分配一个大小为 10 的列表
   ```

4. JavaScript

   : 同样自动进行，通常通过字面量或构造函数来创建对象。

   ```
   javascriptCopy code
   const arr = new Array(10);  // 分配一个大小为 10 的数组
   ```

**内存管理和泄漏**

动态分配的内存必须谨慎管理。在一些低级语言（如 C/C++）中，你需要手动释放不再使用的内存，否则会导致内存泄漏。而在一些高级语言（如 Java、Python）中，垃圾回收机制会自动释放不再使用的内存。

#### 静态分配

静态分配是在编译时分配内存的一种方式。这意味着当程序被编译时，内存的大小和位置就已经确定了，无法在程序运行时改变。下面是几个静态分配的例子：

**C/C++ 中的静态数组**

```
cCopy code
int arr[10]; // 分配一个大小为 10 的整数数组，其大小在编译时确定。
```

**Java 中的基础数据类型**

```
javaCopy code
int a; // 在栈上分配一个整数变量，大小和位置在编译时确定。
```

**Python 中的不可变数据类型**

虽然 Python 主要依赖动态分配，但不可变数据类型（如元组和字符串）一旦创建就不能更改，因此可以看作是静态分配的一种。

```
pythonCopy code
t = (1, 2, 3)  # 元组一旦创建，其大小和内容就不能更改。
```

**全局和静态变量**

全局变量和静态变量（在 C/C++ 中使用 `static` 关键字定义）也是静态分配的例子。它们在程序的生命周期内一直存在，不会被动态地创建或销毁。

```
cCopy code
static int x;  // 静态变量，其生命周期在整个程序执行期间。
```

**常量**

常量是在编译时就确定其值的变量，因此它们也是静态分配的。

```
javaCopy code
final int MAX_VALUE = 100;  // 常量，其值在编译时就确定。
```

**结构体和类的静态成员（C++）**

在 C++ 中，类或结构体的静态成员变量也是静态分配的。

```
c++Copy codeclass MyClass {
public:
    static int staticVar;  // 静态成员变量，其生命周期在整个程序执行期间。
};
```