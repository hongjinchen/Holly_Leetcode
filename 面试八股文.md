

# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

## 创建型模式（Creational Patterns）

### **单例模式（Singleton）**

单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

在单例模式的实现中，通常会：

1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
2. 创建一个**私有静态成员变量**，用于保存**单一实例**。
3. 提供一个**公共静态方法**来获取这个**唯一的实例**。



使用单例模式的理由主要有：

- 控制资源的使用，通过确保只有一个实例减少内存开销，如配置管理器、线程池等。
- 避免对资源的多重占用，例如一个文件的多重写操作，可能会导致数据冲突。
- 有时用于全局访问点，整个应用环境中只有一个全局实例。

单例模式在Java中的一个基本实现示例如下：

```
public class Singleton {
    // 私有静态变量，存储唯一实例
    private static Singleton instance;

    // 私有构造方法，防止外部直接使用new来创建对象
    private Singleton() {}

    // 公有静态方法，返回唯一实例
    public static Singleton getInstance() {
        if (instance == null) {
            // 如果实例不存在，就创建一个
            instance = new Singleton();
        }
        return instance;
    }
}
```

这是单例模式的懒汉式实现，它是延迟加载的，只有在实际需要时才创建实例。另一种常见的是饿汉式实现，它在类加载时就创建实例。

需要注意的是，上述懒汉式实现在多线程环境下可能不安全，如果多个线程同时进入`if (instance == null)` 判断，那么可能会创建多个实例。为了避免这种情况，可以将`getInstance()` 方法同步，或者使用其他技术来确保线程安全。



### **工厂方法模式（Factory Method）**

工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它**提供了一个接口用于创建对象**，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

工厂方法模式主要包括以下几个组件：

1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

如何实现

1. **定义一个返回对象（Product）的工厂接口（Creator）**。
2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

```python
from abc import ABC, abstractmethod

# Product 类
class Button(ABC):

    @abstractmethod
    def click(self):
        pass

# ConcreteProduct 类
class WindowsButton(Button):
    
    def click(self):
        print("Windows button clicked")

class LinuxButton(Button):
    
    def click(self):
        print("Linux button clicked")

# Creator 类
class ButtonFactory(ABC):
    
    @abstractmethod
    def create_button(self):
        pass

# ConcreteCreator 类
class WindowsButtonFactory(ButtonFactory):
    
    def create_button(self):
        return WindowsButton()

class LinuxButtonFactory(ButtonFactory):
    
    def create_button(self):
        return LinuxButton()

# 客户端代码
def button_client_code(factory):
    button = factory.create_button()
    button.click()

# 使用
windows_factory = WindowsButtonFactory()
button_client_code(windows_factory)

linux_factory = LinuxButtonFactory()
button_client_code(linux_factory)

```



Java集合框架（Java Collections Framework）的设计允许用户使用多种方式来创建和管理集合，而具体的实现细节（如数据如何存储、如何进行元素搜索等）则隐藏在这些实现类中。这样，用户可以根据自己的需求选择最合适的集合类型，而不用关心其背后的实现。

例如，当你需要一个 `List` 类型的集合时，你只需选择实现了 `List` 接口的一个类，如 `ArrayList` 或 `LinkedList`，来具体实现你的需求。Java的 `Collections` 工具类则提供了静态工厂方法来创建这些集合的实例，这进一步抽象了对象的创建过程，使得选择具体实现类的决策更加灵活。

这里有一个Java中使用`List`接口创建不同类型列表的例子：

```java
List<String> arrayList = new ArrayList<>();
List<String> linkedList = new LinkedList<>();
```

在这个例子中，`List` 是一个工厂接口，而 `ArrayList` 和 `LinkedList` 是具体的产品。你可以在代码中任何需要 `List` 行为的地方使用这些产品，而不需要关心它们的内部实现，从而实现了代码的松耦合和高可替换性。

所以，Java集合框架中的这些接口和它们的实现类反映了设计模式中的抽象工厂模式和工厂方法模式的原则。



### **抽象工厂模式（Abstract Factory）**

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，**用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类**。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

**结构和组件**

1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

   

   1. **定义抽象产品的接口（AbstractProduct）**。

   2. **创建实现该接口的具体产品（ConcreteProduct）**。

   3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

   4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

   5. **使用具体工厂和抽象工厂来创建产品实例**。

      

   ```python
   from abc import ABC, abstractmethod
   
   # 抽象产品
   class Button(ABC):
       @abstractmethod
       def click(self):
           pass
   
   class Checkbox(ABC):
       @abstractmethod
       def check(self):
           pass
   
   # 具体产品
   class WindowsButton(Button):
       def click(self):
           print("Windows Button clicked")
   
   class WindowsCheckbox(Checkbox):
       def check(self):
           print("Windows Checkbox checked")
   
   class LinuxButton(Button):
       def click(self):
           print("Linux Button clicked")
   
   class LinuxCheckbox(Checkbox):
       def check(self):
           print("Linux Checkbox checked")
   
   # 抽象工厂
   class GUIFactory(ABC):
       @abstractmethod
       def create_button(self):
           pass
   
       @abstractmethod
       def create_checkbox(self):
           pass
   
   # 具体工厂
   class WindowsGUIFactory(GUIFactory):
       def create_button(self):
           return WindowsButton()
   
       def create_checkbox(self):
           return WindowsCheckbox()
   
   class LinuxGUIFactory(GUIFactory):
       def create_button(self):
           return LinuxButton()
   
       def create_checkbox(self):
           return LinuxCheckbox()
   
   # 客户端代码
   def client_code(factory):
       button = factory.create_button()
       checkbox = factory.create_checkbox()
       
       button.click()
       checkbox.check()
   
   # 使用
   windows_factory = WindowsGUIFactory()
   client_code(windows_factory)
   
   linux_factory = LinuxGUIFactory()
   client_code(linux_factory)
   
   ```

   

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

抽象工厂模式是一种创建型设计模式，它提供了一个创建一系列相关或依赖对象的接口，而无需指定它们具体的类。在Java和Python中，抽象工厂模式通常用于创建一组具有共同主题的对象，但在不同主题之间进行切换时无需修改客户代码。



**Java中的抽象工厂模式实例：**

Java中的数据库连接池通常使用抽象工厂模式。例如，`javax.sql.DataSource` 是一个数据源的抽象工厂接口，它可以用来获取数据库连接。根据不同的数据库（如MySQL、Oracle、PostgreSQL），可以有不同的实现，但使用者不需要关心具体的实现细节。

`DBConnectionFactory` 是一个抽象工厂接口，`MySQLConnectionFactory` 和 `OracleConnectionFactory` 是具体的工厂实现。客户端代码仅依赖于 `DBConnectionFactory` 接口，**使得切换不同的数据库连接实现变得非常简单。**



**Python中的抽象工厂模式实例：**

在Python中，一个GUI工具库可能使用抽象工厂模式来提供跨平台的窗口和控件创建。这里是一个简单的例子：

```python
# 抽象产品
class Button:
    def paint(self):
        pass

# 具体产品
class WindowsButton(Button):
    def paint(self):
        print("Render a button in a Windows style")

class MacOSButton(Button):
    def paint(self):
        print("Render a button in a MacOS style")

# 抽象工厂
class GUIFactory:
    def create_button(self):
        pass

# 具体工厂
class WindowsFactory(GUIFactory):
    def create_button(self):
        return WindowsButton()

class MacOSFactory(GUIFactory):
    def create_button(self):
        return MacOSButton()

# 客户端代码
def client_code(factory: GUIFactory):
    button = factory.create_button()
    button.paint()

# 使用
if __name__ == "__main__":
    os_name = "Windows"  # This could be an environment variable
    factory = WindowsFactory() if os_name == "Windows" else MacOSFactory()
    client_code(factory)
```

在这个Python示例中，`GUIFactory` 是一个抽象工厂类，`WindowsFactory` 和 `MacOSFactory` 是具体工厂的实现。客户端代码（`client_code` 函数）只依赖于 `GUIFactory` 抽象类，因此可以轻松地在 `Windows` 和 `MacOS` 控件之间切换而不需改动客户端代码。

在这两个例子中，抽象工厂模式允许系统独立于如何创建、组合和表示产品。这使得系统在不同环境中配置产品族，而对客户端代码的影响最小化。



## 结构型模式（Structural Patterns）

### **适配器模式（Adapter）**

**适配器模式（Adapter Pattern）是一种结构型设计模式，它允许不兼容的接口之间能够相互合作。这种模式涉及到一个单独的类，该类负责加入独立的或不兼容的接口功能。**

**假设你有两个类，它们的接口不兼容，一个无法直接调用另一个的方法。适配器模式就是创建一个新类，它与一个或多个这样的具有不兼容接口的类协同工作，通过在内部包装这些类，来提供一个统一的接口。**

适配器模式通常有两种实现方式：
- **对象适配器模式**：使用组合来连接到适配器的接口。
- **类适配器模式**：使用多重继承来适配一个或多个适配者。



**Java中的适配器模式示例：**

假设你有一个`MediaPlayer`接口，它有一个`play()`方法，你还有一个`AdvancedMediaPlayer`接口，具有不同的`playVlc()`和`playMp4()`方法。现在，如果你想要让`MediaPlayer`的实现能够使用`AdvancedMediaPlayer`的功能，你可以创建一个适配器类。

```java
// 目标接口
public interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 适配者接口
public interface AdvancedMediaPlayer { 
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// 适配者接口的具体实现
public class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file. Name: "+ fileName);        
    }

    @Override
    public void playMp4(String fileName) {
        // do nothing
    }
}

public class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // do nothing
    }

    @Override
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file. Name: "+ fileName);
    }
}

// 适配器
public class MediaAdapter implements MediaPlayer {

    AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String audioType){
        if(audioType.equalsIgnoreCase("vlc") ){
            advancedMusicPlayer = new VlcPlayer();            
        } else if (audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer = new Mp4Player();
        }    
    }

    @Override
    public void play(String audioType, String fileName) {
        if(audioType.equalsIgnoreCase("vlc")){
            advancedMusicPlayer.playVlc(fileName);
        }else if(audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 客户端
public class AudioPlayer implements MediaPlayer {
    MediaAdapter mediaAdapter; 

    @Override
    public void play(String audioType, String fileName) {

        // 内置支持播放mp3音乐文件
        if(audioType.equalsIgnoreCase("mp3")){
            System.out.println("Playing mp3 file. Name: " + fileName);            
        } 
        // mediaAdapter 提供了播放其他文件格式的支持
        else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")){
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        }
        else{
            System.out.println("Invalid media. " + audioType + " format not supported");
        }
    }   
}

public class AdapterPatternDemo {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();

        audioPlayer.play("mp3", "beyond the horizon.mp3");
        audioPlayer.play("mp4", "alone.mp4");
        audioPlayer.play("vlc", "far far away.vlc");
        audioPlayer.play("avi", "mind me.avi");
    }
}
```

在上面的代码中，`MediaAdapter`是适配器，它实现了`MediaPlayer`接口并使用组合方式引用了`AdvancedMediaPlayer`对象。`AudioPlayer`是客户端类，它通过`MediaPlayer`接口与`MediaAdapter`进行交互。



**Python中的适配器模式示例：**

在Python中，我们可以使用特殊方法`__getattr__`来实现

一个简单的适配器：

```python
class Target:
    def request(self):
        return "Target: The default target's behavior."

class Adaptee:
    def specific_request(self):
        return ".eetpadA eht fo roivaheb laicepS"

class Adapter(Target, Adaptee):
    def request(self):
        return f"Adapter: (TRANSLATED) {self.specific_request()[::-1]}"

def client_code(target):
    print(target.request(), end="")

if __name__ == "__main__":
    print("Client: I can work just fine with the Target objects:")
    target = Target()
    client_code(target)
    print("\n")

    adaptee = Adaptee()
    print("Client: The Adaptee class has a weird interface. "
          "See, I don't understand it:")
    print(f"Adaptee: {adaptee.specific_request()}", end="\n\n")

    print("Client: But I can work with it via the Adapter:")
    adapter = Adapter()
    client_code(adapter)
```

在这个例子中，`Adaptee` 是一个具有特殊请求方法的类，其接口与`Target`类的接口不兼容。`Adapter` 类通过继承`Target` 并引用`Adaptee` 的一个实例，来使两个不兼容的接口能够一起工作。

在这两种语言中，适配器模式都是用来解决接口不兼容的问题，它允许原本不可能一起工作的类可以在一起工作。



### **装饰器模式（Decorator）**

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你动态地将行为添加到对象上，而无需修改其实现的类。这种模式通过创建一个包装器（一个装饰器对象）来包裹原始对象，并在保持原始对象类方法签名不变的前提下，提供额外的功能。

装饰器模式的关键优点是它遵循开闭原则，即软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。使用装饰器模式可以在不修改现有对象的情况下，通过添加新的装饰器类来增强对象的行为。

### 
装饰器模式通常涉及以下角色：
1. **组件（Component）**：定义一个对象接口，可以给这些对象动态添加职责。
2. **具体组件（ConcreteComponent）**：定义了一个具体的对象，也可以给这个对象添加一些职责。
3. **装饰（Decorator）**：持有一个组件对象的引用，并定义一个与组件接口一致的接口。
4. **具体装饰（ConcreteDecorator）**：向组件添加职责。



**Python中的装饰器模式示例**

在Python中，装饰器模式可以通过使用闭包和装饰器语法糖来实现，这里是一个简单的例子：

```python
from functools import wraps

# 组件
class Coffee:
    def get_cost(self):
        return 1

    def get_ingredients(self

):
        return "Coffee"

# 装饰器
def milk(coffee_class):
    @wraps(coffee_class)
    def wrapper(*args, **kwargs):
        c = coffee_class(*args, **kwargs)
        c.get_cost = lambda: c.get_cost() + 0.5
        c.get_ingredients = lambda: c.get_ingredients() + ", Milk"
        return c
    return wrapper

def sugar(coffee_class):
    @wraps(coffee_class)
    def wrapper(*args, **kwargs):
        c = coffee_class(*args, **kwargs)
        c.get_cost = lambda: c.get_cost() + 0.5
        c.get_ingredients = lambda: c.get_ingredients() + ", Sugar"
        return c
    return wrapper

# 使用装饰器
@milk
@sugar
class SomeCoffee(Coffee):
    pass

if __name__ == '__main__':
    coffee = SomeCoffee()
    print("Cost: " + str(coffee.get_cost()) + "; Ingredients: " + coffee.get_ingredients())
```

在这个Python代码中，我们使用了装饰器函数（`milk` 和 `sugar`）来装饰 `Coffee` 类，为其动态地增加额外的行为。

在这两种语言中，装饰器模式提供了一个非常灵活的方式来遵循单一职责原则，通过将职责分配到小的、独立的类中，而不是在一个复杂的类结构中管理它们。这种模式在GUI库、流处理、业务逻辑等许多场景中都很有用。



### **组合模式（Composite）**

**组合模式（Composite Pattern）是一种结构型设计模式，用于表示具有树形结构的对象组合。这种模式允许客户以一致的方式处理单个对象和对象组合。**

组合模式通常用于创建一个层次结构，例如图形用户界面中的控件集合，文件系统中的目录和文件，或任何需要表示对象的部分-整体层次结构的场所。



- **角色和职责：**

组合模式主要包括以下几个角色：

1. **抽象组件（Component）**：
   这是一个抽象接口，声明了叶节点和容器节点共有的操作。它可以是一个抽象类或者接口。

2. **叶节点（Leaf）**：
   叶节点是组合的基本单元，表示没有子节点的对象。它实现或继承了`Component`接口。

3. **复合组件（Composite）**：
   一个容器节点，可以有子节点，子节点可以是其他`Composite`或`Leaf`对象。复合组件同样实现或继承`Component`接口。

4. **客户端（Client）**：
   通过`Component`接口与组合结构中的对象进行交互。
   
   

- **优点和应用场景**：

组合模式的优点包括：

- **统一性**：客户端代码可以统一对待单个对象和组合对象，无需关心处理的是单个对象还是整个组合结构。
- **灵活性**：轻松地添加新类型的组件，因为客户端代码与具体类的实现解耦。
- **简洁性**：客户端代码更加简洁，因为树形结构中的任何组件都可以一致对待。

组合模式适用于以下场景：

- 当你希望客户代码可以忽略组合对象与单个对象的差异时。

- 当你希望构建对象的部分-整体层次结构时。

  

- **Java示例：**

下面是使用组合模式的一个简单Java示例：

```java
// 抽象组件
public interface Component {
    void operation();
}

// 叶子组件
public class Leaf implements Component {
    private String name;

    public Leaf(String name) {
        this.name = name;
    }

    @Override
    public void operation() {
        System.out.println("Leaf " + name + " is operated on.");
    }
}

// 复合组件
public class Composite implements Component {
    private List<Component> children = new ArrayList<>();

    public void add(Component component) {
        children.add(component);
    }

    public void remove(Component component) {
        children.remove(component);
    }

    @Override
    public void operation() {
        for (Component child : children) {
            child.operation();
        }
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Composite root = new Composite();
        root.add(new Leaf("Leaf 1"));
        root.add(new Leaf("Leaf 2"));

        Composite sub = new Composite();
        sub.add(new Leaf("Leaf 3"));
        root.add(sub);

        root.operation();
    }
}
```

在上述例子中，`Composite` 类有一个包含`Component`对象的列表。它的`operation()`方法会遍历所有子对象，并调用它们的`operation()`方法，不论这些子对象是`Leaf`还是`Composite`。客户端代码（`Client`类）可以一致地对待`Leaf`和`Composite`对象。



## 行为型模式（Behavioral Patterns）

### **观察者模式（Observer）**

当一个对象的状态发生变化时，其依赖者都会得到通知。



### **策略模式（Strategy）**

定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。



### **命令模式（Command）**

将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。





# 美团面试真题

### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）





### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。



### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。



# 中移物联

**引领物联网技术创新，赋能千行百业，共创万物互联的美好生活。**



**"拼搏、工匠、创新"** 这个**企业文化概念**可以从几个方面来理解：

1. **拼搏（Striving）**：这一部分强调的是**努力和奋斗的精神**。在企业文化中，拼搏通常意味着员工需要保持高度的热情和动力，不断地追求目标和成就。这种文化鼓励积极进取，**面对困难和挑战时不轻易放弃**。
2. **工匠（Craftsmanship）**：工匠精神代表着**对工作的热爱、对品质的追求以及精益求精的态度**。在这样的企业文化中，**员工被鼓励像工匠一样对待他们的工作，注重细节，追求卓越，不断提高自己的技能和工作质量。**
3. **创新（Innovation）**：创新是企业持续发展的关键。这部分文化强调**开放思维、探索新方法、开发新产品或改进现有产品。**在这种文化中，鼓励员工思考如何打破常规，寻求更有效、更高效的解决方案。



**中移物联网简介**

中移物联网有限公司是中国移动通信集团有限公司的全资子公司，是中国移动在物联网领域的主责企业。公司定位为物联网核心能力的锻造者、物联网专业市场的领导者、全网物联网业务的支撑者、科技型企业改革的示范者。

中移物联网有限公司积极践行中国移动集团发展战略部署，以“做出新规模”、“锻造新能力”、“开创新机制”、“谋划新布局”为目标，围绕“四新”开新局，不断推动产业数字化、数字产业化。

公司聚焦物联网业务能力建设与市场拓展，重点围绕物联网基础通用能力、视频物联网（VIoT）、智能物联网（AIoT）、产业物联网（IIoT）打造物联网核心技术和产品，支撑全网物联网业务发展。

数字经济赋能千行百业，5G融合**驱动万物互联**。中移物联网有限公司将把握数智化转型机遇，携手各界合作伙伴，共同开启**数字经济**发展新篇章！



**Web开发工程师需要具备的能力**

作为一什名Web开发工程师，除了具备专业的技术素质，还需要一系列的软技能和其他能力来提升自己的职业素养。以下是一些重要的非技术性能力：

1. **沟通技能**：这是非常重要的，因为你需要与团队成员、客户、利益相关者沟通需求、解决方案和进展。

2. **团队合作**：Web开发通常是团队工作。合作能力、适应团队工作流程和文化、以及有效地协同工作非常关键。

3. **解决问题的能力**：在开发过程中遇到问题是常有的事。能够有效地识别、分析和解决问题是必需的技能。

4. **学习能力**：技术领域不断发展，持续学习新技术和工具是必不可少的。

5. **时间管理和自我组织**：有效管理时间，合理安排任务和截止日期，能够提高工作效率。

6. **适应能力和灵活性**：能够适应快速变化的技术环境和项目需求的调整。

7. **注意细节**：在编码和设计中，对细节的关注可以减少错误和提高产品质量。

8. **创造力和创新思维**：创新的解决方案可以帮助解决复杂的问题，并提高工作的效率和质量。

9. **用户体验理解**：了解用户需求和体验，能够开发出更符合用户需求的产品。

10. **项目管理技能**：能夠管理项目流程、资源分配和风险评估。



**假如作为测试组长，怎么评价团队中的组员的工作好坏？**

1. **技术能力**：
   - 评估成员在测试设计、测试用例的编写、缺陷跟踪、自动化测试等方面的技术能力。
   - 观察他们是否能有效地使用测试工具和技术。
2. **问题解决能力**：
   - 观察成员在遇到测试中的问题时是如何分析和解决问题的。
   - 评价他们的创新思维和解决问题的能力。
3. **细节关注**：
   - 测试工作中对细节的关注非常重要。评估成员是否能准确无误地执行测试用例，是否能发现和记录软件中的微妙缺陷。
4. **沟通和协作能力**：
   - 观察成员如何与团队其他成员以及跨部门团队（如开发、产品管理）沟通交流。
   - 评估他们在团队中的合作程度以及在解决冲突中的能力。
5. **效率和生产力**：
   - 评估成员完成任务的速度和质量，以及他们管理时间和优先级的能力。
   - 观察他们对工作流程的适应性和对提高工作效率的贡献。
6. **自我改善和学习能力**：
   - 评估成员是否主动学习新技术、新工具和测试方法。
   - 观察他们是否能从错误中学习并改进自己的工作。
7. **主动性和责任感**：
   - 评估成员是否能主动承担责任，对自己的工作负责。
   - 观察他们是否能在不需要过多指导的情况下独立完成任务。
8. **质量意识**：
   - 评估成员在测试工作中对于保证软件质量的重视程度。
   - 观察他们是否能识别并提出改进产品质量的建议。



**对于前端开发人员，如何去评价团队中的组员的工作好坏？**

1. **技术能力和专业知识**：

   - 评估团队成员在HTML、CSS、JavaScript等前端技术方面的熟练程度。
   - 了解他们是否能有效使用前端框架和工具（如React, Vue, Angular等）。
   - 观察他们对于响应式设计、浏览器兼容性等方面的处理能力。

2. **代码质量和维护性**：

   - 检查代码是否干净、整洁、易于理解和维护。
   - 评价他们遵循最佳实践和代码规范的能力。

3. **性能优化**：

   - 评估他们在前端性能优化方面的知识和实践，比如减少页面加载时间、优化资源使用等。

4. **用户体验和设计感知**：

   - 观察他们在设计实现过程中对用户体验的关注程度。
   - 评估他们将设计稿转换为实际界面时的准确性和对细节的关注。

5. **问题解决能力**：

   - 了解他们面对问题时的解决方法和创造性思维。
   - 观察他们在遇到难题时是否能持续寻找解决方案。

6. **沟通和团队合作**：

   - 评估他们与团队成员（包括开发者、设计师、产品经理等）的沟通效果。
   - 观察他们在团队协作中的参与度和贡献。

7. **学习和适应能力**：

   - 观察他们对新技术、新工具的学习速度和适应性。
   - 评价他们对行业趋势的关注程度和持续学习的态度。

8. **时间管理和工作效率**：

   - 评估他们按时完成任务的能力。
   - 观察他们在工作中的效率和对时间的管理。

9. **创新和主动性**：

   - 评价他们在工作中是否能提出新想法，是否能主动寻找改善工作流程和产品的方法。

10. **项目管理和责任感**：

    - 观察他们在项目管理中的参与度和责任感。

    - 了解他们在处理多任务和紧急情况时的能力。

      

**减少页面加载时间**

1. **优化图片和媒体文件**：
   - 压缩图片和视频文件，减少它们的大小。
   - 使用正确的文件格式，例如，对于图像使用JPEG（更小的文件）或PNG（更高的质量）。
   - 使用响应式图片（`<picture>` 标签或 `srcset` 属性），以根据不同的设备尺寸加载不同大小的图片。
2. **最小化和合并文件**：
   - 将CSS和JavaScript文件最小化（删除多余的空格、注释等），减少文件大小。
   - 合并多个CSS和JavaScript文件，减少HTTP请求的数量。
3. **使用浏览器缓存**：
   - 设置合适的缓存策略，使得返回访问者可以加载页面上已经缓存的资源。
4. **使用内容分发网络（CDN）**：
   - 将内容放在不同地理位置的服务器上，减少数据传输的延迟。
5. **优化CSS和JavaScript**：
   - 确保关键的CSS是内联的，而不是外部加载的，以减少阻塞渲染的资源。
   - 将JavaScript脚本放在页面底部，以防止JS阻塞DOM的构建。
6. **减少HTTP请求**：
   - 通过合并文件、使用CSS精灵图、减少外部脚本等方法减少HTTP请求的数量。
7. **使用异步或延迟加载**：
   - 对于非关键JavaScript和CSS使用异步（`async`）或延迟（`defer`）加载。
8. **优化Web字体**：
   - 减少使用的字体变体数量。
   - 使用现代格式的字体文件（如WOFF2）。
9. **优化服务器响应时间**：
   - 使用高效的服务器和网络资源。
   - 优化数据库查询。
   - 使用缓存策略来减少重复的数据处理。

1. **移动优先的设计**：
   - 针对移动设备优化页面，因为它们通常比台式机有更慢的网络连接。
2. **监控和分析**：
   - 使用工具如Google PageSpeed Insights、Lighthouse或WebPageTest等，来监控网页性能，并根据建议进行优化。





**Umi Model全局管理Hook实现导航栏消息浮点**

**Umi框架**

Umi是一个可插拔的企业级React应用框架，它提供了丰富的开发特性和工程实践。Umi主要专注于提升开发效率，支持诸如路由配置、插件系统、代码分割等功能。

**Model全局管理**

在Umi中，Model通常用于管理应用的状态（state）。全局管理意味着这个状态可以跨多个组件共享和访问。Umi使用dva（基于redux和redux-saga）作为状态管理工具，允许你在全局Model中定义状态、改变状态的reducers和处理异步逻辑的effects。

**Hook**

Hook是React 16.8引入的一个新特性，它允许你在不编写类组件的情况下使用state和其他React特性。在Umi项目中，你可以使用自定义Hook来封装一些逻辑，使其在组件之间可复用。

**实现导航栏消息浮点**

现在，我们要使用上述工具来实现导航栏上的消息浮点功能。这个功能大概可以这样实现：

1. **创建一个全局Model**：
   - 在这个**Model**中，你可以**定义一个状态来存储消息的数量。**
   - 可以**定义effects来处理异步逻辑，例如从服务器获取新消息。**
2. **使用Hook订阅和更新状态**：
   - 在导航栏组件中，你可以使用**React Hook（如`useEffect`和`useState`）来订阅全局Model中的消息数量状态。**
   - 当状态更新时，组件将重新渲染以显示新的消息数量。
3. **实现消息浮点**：
   - 在导航栏组件中，根据Model中的消息数量显示一个消息图标和数量指示。
   - 可以添加交互逻辑，如点击消息图标展示详细消息列表。



# 网易

- #### **两个人分别捡100个球，每人只能捡1～5个，如果捡到第100个球就获胜，那么最开始要捡几个**

这是一个关于策略和数学问题的游戏。为了确保胜利，你需要确保在最后一轮中可以捡到第100个球。游戏的关键在于控制游戏的进程，使得当轮到对方捡球时，剩余的球数使得对方无法一次捡完，同时保证你下一轮能够一次捡完。

为了达到这个目的，你需要保证在对方捡球之前，剩余球的数量是6的倍数（因为无论对方怎样选择1到5个球，你都可以通过选择1到5个球，使得每轮后剩余球数依然是6的倍数）。例如，如果剩余球数为6，无论对方捡1、2、3、4还是5个球，你都可以通过捡剩下的球赢得比赛。

因此，策略是这样的：

1. 在游戏开始时，你需要捡球，使得剩余的球数为6的倍数。由于总共有100个球，你应该捡取4个球（因为 \(100 - 4 = 96\)，是6的倍数）。

2. 之后的每一轮，无论对方捡了多少个球（n个，其中1 ≤ n ≤ 5），**你都捡取6-n个球，以确保剩余球数始终是6的倍数。**

这样，当轮到对方捡球时，球数将始终不足以一次捡完，而在你的下一轮你将能够捡完剩余的球，从而获胜。所以，最开始你应该捡4个球。



- #### **5名海盗如何分配100枚金币**

这个问题是一个著名的逻辑和数学问题，通常称为“海盗分金币”问题。假设有5名海盗，他们需要分配100枚金币。海盗们有一套自己的规则：

1. 他们按照等级高低排列，等级最高的海盗（称为海盗A）首先提出分配方案。
2. 所有海盗（包括提出方案的海盗）进行投票，决定是否接受这个方案。
3. 如果至少半数（包括一半）的海盗投赞成票，方案就会被接受，金币就会按照这个方案分配。
4. 如果方案被否决，提出方案的海盗将被扔进海里，剩下的海盗继续按照同样的规则分配金币。

每个海盗的目标是尽可能多地拿到金币，其次是生存（即不被扔进海里）。海盗们都非常聪明，能够预测其他海盗的决策。

**分析和解答**

1. **只剩下海盗E**：
   - 如果只剩下海盗E，他会拿走全部的100枚金币，因为没有其他海盗投票。
2. **剩下海盗D和E**：
   - 这时海盗D知道，只要他给自己100枚金币，海盗E无论如何都会得不到金币，所以会投赞成票。所以，海盗D会提议给自己100枚，给E 0枚。
3. **剩下海盗C、D和E**：
   - 海盗C知道，只要给海盗E 1枚金币，海盗E就会投赞成票（因为E知道如果C被扔进海里，他在下一轮会什么都得不到）。所以，海盗C会提议给自己99枚，给E 1枚，给D 0枚。
4. **剩下海盗B、C、D和E**：
   - 海盗B知道，只要给海盗D 1枚金币，D就会投赞成票（因为D知道如果B被扔进海里，他在下一轮会什么都得不到）。所以，海盗B会提议给自己99枚，给D 1枚，给C和E各0枚。
5. **所有五名海盗都在**：
   - 海盗A知道，只要给海盗C和E各1枚金币，他们就会投赞成票（因为他们知道如果A被扔进海里，他们在下一轮会什么都得不到或者得到更少）。所以，海盗A会提议给自己98枚，给C和E各1枚，给B和D各0枚。

根据这个逻辑，最终的分配方案是：海盗A得到98枚金币，海盗C和E各得到1枚金币，海盗B和D什么也得不到。这个解答展示了理性的、基于自身利益最大化的决策过程。



- #### 两个一模一样的鸡蛋，100层的高楼，在某一层鸡蛋掉下去刚好不会岁，多一层就会碎的那种，问最少需要测试多少次找到那一个楼层。

这是一个经典的数学问题，通常被称为“鸡蛋掉落”问题。在这个问题中，你有两个完全相同的鸡蛋，需要找出一个楼层，低于它鸡蛋不会碎，高于或等于它鸡蛋会碎。目标是找到这个楼层，同时尽量减少测试次数。

这个问题的解决方案涉及到最优化测试步骤的策略。最直接的方法是从第一层开始逐层向上测试，但这在最坏的情况下可能需要100次测试。为了更高效地解决这个问题，可以采用一种平衡的方法，即第一个鸡蛋用来确定一个相对较大的间隔范围，第二个鸡蛋用来在这个范围内精确测试。

一种有效的策略是：
1. 使用第一个鸡蛋，从某个间隔（比如说10层）开始测试。例如，先在第10层、20层、30层...测试。
2. 当第一个鸡蛋在某个点（比如40层）碎了，那么你知道临界楼层位于31层到39层之间。
3. 接下来使用第二个鸡蛋，在31层开始逐层向上测试，直到找到鸡蛋碎的那一层。

在最坏的情况下，这种策略的测试次数是固定的。例如，如果每次增加10层，那么最坏情况下的测试次数是19次（第一个鸡蛋测试10次，第二个鸡蛋测试9次）。

然而，可以通过优化间隔来减少最坏情况下的测试次数。理想情况下，第一个鸡蛋碎掉时，剩余的测试次数应该等于之前的测试步数。通过数学计算，可以得出最优的测试间隔是楼层数的平方根。对于100层楼来说，最优间隔是10（100的平方根接近10）。因此，在最坏的情况下，测试次数是14次（10次加上4次）。这是在只有两个鸡蛋的情况下找到临界楼层的最优策略。



- #### 两数之和

这个问题是一个常见的编程问题，通常被称为“**两数之和**”问题。它的目标是在给定的数组中找到两个数，使它们的和等于一个特定的目标值，并返回这两个数的索引。解决这个问题的一种高效方法是使用哈希表。

以下是解决这个问题的算法步骤：

1. **初始化一个哈希表**：用于存储已经遍历过的数组元素及其索引。

2. **遍历数组**：对于每个元素，计算 **`目标值 - 当前元素值`** 的结果，这个结果就是我们需要在数组其他部分找到的数。

3. **检查哈希表**：查看哈希表中是否已经存在这个差值。如果存在，那么当前元素和哈希表中存储的元素就是我们要找的两个数。

4. **更新哈希表**：如果哈希表中不存在这个差值，将当前元素及其索引添加到哈希表中。

5. **返回结果**：一旦找到符合条件的两个数，返回它们的索引。

下面是这个算法的Python实现示例：

```python
def two_sum(nums, target):
    hash_table = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_table:
            return [hash_table[complement], i]
        hash_table[num] = i
    return []
```

这个函数接收一个数组 `nums` 和一个目标值 `target`，并返回一个包含两个索引的列表，这两个索引对应的数组元素之和等于目标值。如果不存在这样的两个元素，则返回一个空列表。



- #### 找出字符串中字母只出现过一次的位置

要找出一个字符串中只出现过一次的字母以及它们的位置，可以使用一个字典（或哈希表）来跟踪每个字符出现的次数，然后再次遍历字符串以找出那些只出现一次的字符的位置。以下是实现这个功能的Python代码示例：

```python
def unique_char_positions(s):
    # 统计每个字符出现的次数
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    # 找出只出现一次的字符的位置
    unique_positions = []
    for i, char in enumerate(s):
        if char_count[char] == 1:
            unique_positions.append(i)

    return unique_positions
```

这个函数 `unique_char_positions` 接收一个字符串 `s` 作为输入，返回一个列表，其中包含了在字符串 `s` 中只出现一次的字符的索引。字符的位置是从0开始计数的。如果字符串中没有任何字符只出现一次，这个列表将是空的。



- #### 以O（n）的时间复杂度输出数组中不重复的数字长度并在原有的数组上进行操作

要以 O(n) 时间复杂度找出数组中不重复数字的长度，并且在原数组上操作，我们可以使用哈希表来跟踪每个元素是否已经出现过。然而，如果要在原数组上操作并且保持不重复元素的顺序，我们可以使用“快慢指针”技巧。

以下是这个算法的步骤：

1. **使用两个指针**：一个快指针（fast）和一个慢指针（slow）。
2. **快指针**：遍历数组，用于检查每个元素。
3. **慢指针**：指向处理后数组中不重复元素的下一个位置。
4. **哈希表**：用于存储已经出现过的元素。
5. 当快指针指向的元素在哈希表中不存在时，将其复制到慢指针的位置，并移动慢指针。同时更新哈希表。
6. 如果快指针指向的元素在哈希表中已存在，只移动快指针。
7. 继续这个过程直到快指针遍历完整个数组。
8. 慢指针的位置就是不重复元素的数量。

这里是Python中的实现：

```python
def remove_duplicates(nums):
    seen = set()
    slow = 0
    for fast in range(len(nums)):
        if nums[fast] not in seen:
            nums[slow] = nums[fast]
            seen.add(nums[fast])
            slow += 1
    return slow

# 示例用法
nums = [1, 2, 2, 3, 4, 4, 5]
length = remove_duplicates(nums)
print(length)  # 输出不重复数字的长度
print(nums[:length])  # 输出处理后的数组部分
```

在这个例子中，`remove_duplicates` 函数接收一个数组 `nums`，并返回数组中不重复数字的长度。同时，原数组 `nums` 被修改为只包含不重复的元素（在数组的前 `length` 个位置）。这个方法的时间复杂度是 O(n)，因为它只遍历了数组一次。



- #### 求二叉树每层最大值

求解二叉树每层的最大值可以通过**广度优先搜索（BFS）**来实现。BFS可以通过队列来辅助实现，它按层遍历二叉树的节点，并在每一层中找到最大值。下面是Python中实现该算法的步骤：

1. **初始化队列**：首先将根节点放入队列。

2. **按层遍历**：当队列不为空时，遍历每一层的节点。对于每层，计算该层的最大值。

3. **处理子节点**：将每个节点的子节点（如果有的话）加入队列，以便在下一次循环中处理。

4. **记录最大值**：记录并保存每层的最大值。

这里是具体的Python代码实现：

```python
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.val = value
        self.left = left
        self.right = right

def findLargestValueInEachTreeRow(root):
    if not root:
        return []
    
    largest_values = []
    queue = [root]

    while queue:
        level_size = len(queue)
        max_value = float('-inf')

        for _ in range(level_size):
            node = queue.pop(0)
            max_value = max(max_value, node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        largest_values.append(max_value)

    return largest_values

# 示例用法
root = TreeNode(1)
root.left = TreeNode(3)
root.right = TreeNode(2)
root.left.left = TreeNode(5)
root.left.right = TreeNode(3)
root.right.right = TreeNode(9)

print(findLargestValueInEachTreeRow(root))  # 输出应为 [1, 3, 9]
```

在这个例子中，首先定义了二叉树的节点类 `TreeNode`。然后实现了函数 `findLargestValueInEachTreeRow`，它接收根节点并返回一个列表，其中包含了二叉树每层的最大值。通过使用队列来实现BFS，该函数能够有效地遍历树的每一层并找到每层的最大值。