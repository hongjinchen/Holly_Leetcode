***\*对数据库的操作一般包括连接、打开、使用、关闭等步骤，对于不同类型的数据库，其操作步骤都一致，只是连接数据库方法有所区别，可以使用（）对其进行设计\****

 

模板方法模式

 

***\*共享网络设备模拟：很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发。共享网络设备可以使用（）模拟共享网络设备的设计原理。\****

 

***\*享元模式\****

 

 外观模式（Facade Pattern）是一种设计模式，用于为一个复杂的子系统提供一个统一的接口。这样，子系统更容易使用，因为你只需要与一个统一的接口进行交互，而不是各个子系统的独立接口。

以下是对这些选项的分析：

### A. 对客户端屏蔽了子系统组件

**正确**。外观模式的主要目的就是提供一个统一的接口，以隐藏子系统的复杂性。客户端只需要与外观类交互，而不需要直接与子系统的多个组件交互。

### C. 单个子系统的修改不影响其他子系统

**不一定正确**。这个描述更像是松耦合或模块化设计的特点，而不是外观模式特有的。外观模式主要是对一个特定子系统（或多个密切相关的子系统）提供统一的接口，并不能保证单个子系统的修改不影响其他子系统。

### D. 子系统类变化时，只需要修改外观类即可

**正确**。由于外观模式提供了一个统一的接口，所以如果子系统的内部发生变化，只需要更新这个统一接口（也就是外观类）即可。这样，客户端代码不需要任何修改，从而实现了解耦。



在模拟毛笔的使用过程中提供了大中小3种型号的画笔，够绘制5种不同颜色。我们可以使用（桥接）来模拟实现模拟毛笔的使用。

是的，桥接模式（Bridge Pattern）是一个很好的选择来模拟毛笔的使用过程中的不同组合（大小和颜色）。

桥接模式主要用于将抽象与其实现解耦，使得两者可以独立地变化。在这个场景中，毛笔的大小和颜色可以视为两个独立的维度。

- **抽象（Abstraction）**: 这里可以是一个`Brush`类，拥有绘制（draw）的方法。
- **实现（Implementation）**: 这里可以是颜色和大小，例如`Color`和`Size`。

这样，你可以通过桥接模式将`Brush`类与具体的`Color`和`Size`实现解耦，允许你独立地添加更多的颜色或更改笔刷大小，而不影响其他代码。



![image-20231020104459926](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020104459926.png)

### A. 样式文件的加载会阻塞脚本的执行

**正确**。外部的样式表（如：通过`<link rel="stylesheet" href="style.css">`加载）确实会阻塞后面的JavaScript脚本的执行，除非这些脚本是异步的或被设置为`defer`。

### B. iframe 会阻塞主页面的 load 事件

**正确**。`<iframe>`确实会阻塞主页面的`load`事件。直到iframe以及其中的所有资源都完成加载后，主页面的`load`事件才会触发。

### C. `<audio>`、`<img>` 中的资源下载会阻塞页面解析

**不正确**。通常，这些元素不会阻塞页面的解析。它们会异步地下载。

### D. 页面文档完全加载并解析完毕之后会触发 DOMContentLoaded 事件

**不正确**。实际上，`DOMContentLoaded`事件会在HTML文档被完全加载和解析完毕后触发，但在样式表、图片和子框架完成加载前就会触发。

![image-20231020105554295](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020105554295.png)

### A. 当前域的 cookie 都可以通过 js 在当前域下获取

**不一定正确**。虽然在大多数情况下，JavaScript 可以访问同一域名下设置的 cookie，但如果该 cookie 被标记为 `HttpOnly`，则 JavaScript 将无法访问它。因此，这个说法并不总是正确。

### B. JSONP 是 XMLHttpRequest 中的一种

**错误**。JSONP（JSON with Padding）与 XMLHttpRequest 不是同一回事。JSONP 是一种跨域数据访问的技术，而 XMLHttpRequest 是用于发起 HTTP 或 HTTPS 请求的 API。JSONP 不使用 XMLHttpRequest，而是通过动态创建 `<script>` 标签来实现跨域请求。

### C. 同源策略是浏览器的安全策略

**正确**。同源策略确实是浏览器的一种安全机制，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一种重要的安全措施，用于防止诸如 CSRF（跨站请求伪造）和 XSS（跨站脚本攻击）等安全问题。

### D. localStorage API 不支持设置过期时间

**正确**。与 cookie 不同，HTML5 的 `localStorage` API 本身并不提供设置过期时间的功能。一旦数据存储在 localStorage 中，它将一直存在，除非用户手动清除或者通过代码进行删除。

![image-20231020105847678](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020105847678.png)

### A. requestAnimationFrame(foo) 确保使浏览器在下一次重绘之前调用 foo 方法

**正确**。`requestAnimationFrame(foo)` 将确保在浏览器的下一次重绘之前调用 `foo` 函数。这是一种更高效的方式来进行动画或页面更新，因为它会与浏览器的绘制周期同步。

### B. 在 addEventListener 的处理方法中使用 e.preventDefault() 可以阻止事件冒泡

**错误**。`e.preventDefault()` 用于阻止事件的默认行为，而不是阻止事件冒泡。要阻止事件冒泡，你应该使用 `e.stopPropagation()`。

### C. 把 `<script>` 标签的引入放在文档末尾可以确保脚本下载和执行均在文档解析完成后发生

**正确**，通常情况下。将 `<script>` 标签放在文档的末尾（通常在 `</body>` 标签之前）确实是一种常用的做法，以确保脚本在整个文档解析完成后才执行。这样可以减少页面渲染的阻塞。

### D. 多个 `<script>` 标签使用 defer 属性引入脚本时，可以确保脚本的执行是按照其被引入的顺序的

**正确**。当使用 `defer` 属性时，多个脚本将按照它们在文档中出现的顺序进行执行，而且都会在文档解析完成后，DOMContentLoaded 事件触发之前执行。



![image-20231020111931217](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020111931217.png)

DMA（Direct Memory Access）I/O 控制方式通常用于数据传输速率高和数据量大的设备，因为它可以直接在设备和内存之间进行数据传输，而不需要 CPU 的介入。这样做可以减轻 CPU 的负担，让其有更多的时间来处理其他任务。

选项解析：

A. **打印机**：通常数据传输速率不高，不需要 DMA。

B. **键盘**：用户输入速度慢，不需要 DMA。

C. **鼠标**：与键盘类似，用户输入速度慢，不需要 DMA。

D. **磁盘**：数据传输速度高，数据量大，适合使用 DMA。



![image-20231020115622749](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020115622749.png)

独占设备是指在一段时间内只能由一个程序或用户独占使用的设备。这通常适用于低速设备或者需要进行大量连续读写操作的设备，因为它们的操作通常不能快速完成，而且不容易与其他操作进行有效的时间片切换。

选项解析：

A. **软磁盘**：通常是低速设备，适合作为独占设备。

B. **磁带机**：因为磁带机通常用于备份和其他需要大量连续读写的操作，它是低速设备，适合作为独占设备。

C. **可擦写光驱**：通常也是低速设备，特别是在执行大量数据读写（如刻录）时，适合作为独占设备。

D. **硬盘**：虽然硬盘在现代计算机系统中通常不是低速设备，但由于其作为主要的存储介质，在某些情况下（如数据恢复、磁盘检查等）可能需要作为独占设备使用。



![image-20231020115721962](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020115721962.png)

A. **Windows NT Server**：这是一个网络操作系统，主要用于企业级应用。

B. **Unix**：Unix 系统通常用于服务器和网络操作，拥有丰富的网络功能。

C. **DOS**（Disk Operating System）：这是一个用于个人计算机的操作系统，并没有专为网络操作而设计。它缺乏现代网络操作系统所需的多用户、多任务和其他网络功能。

D. **NetWare**：这是 Novell 公司开发的网络操作系统，专门用于文件服务器。



![image-20231020115903235](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020115903235.png)

分段对应的是内存具体存储管理的一种方式，是对具体内存进行管理，段号+基地址，分段尺寸最大为具体内存。在动态链接时先将主程序所对应的目标程序装入内存并启动运行，运行过程中需要调用某段时才将该段内存合并进行链接。 而作业的大小不受内存大小限制，由虚拟存储器解决空间不够问题，允许作业装入的时候只装入一部分，另一部分放在  磁盘  上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。同 时，用户编程的时候也摆脱了一定要编写小于主存容量的作业的限制。

**主要的储存管理方式：**

### 1. 连续内存分配

- **描述**：进程在内存中占用连续的地址空间。

- **优点**：简单，易于管理。

- **缺点**：容易导致内存碎片。

- **应用场景**：早期操作系统，嵌入式系统。

  

### 2. 分页存储管理

- **描述**：物理内存被划分为固定大小的页，进程也被划分为相同大小的页。
- **优点**：减少内存碎片，允许灵活的内存分配。
- **缺点**：增加了页表的管理成本。
- **应用场景**：现代通用操作系统。



- 在分页存储管理中，物理内存和逻辑内存都被分为固定大小的单位，称为“页”。
- 一个进程的页可以非连续地存储在物理内存中。

**主要特点**

1. **内存利用率高**：由于所有的块都是固定大小的，因此减少了内存碎片。
2. **简化内存管理**：页表提供了一种简单的方法来跟踪哪些页被加载到物理内存中。
3. **支持大内存模型**：通过虚拟内存，分页可以使程序认为它有比物理内存更多的可用内存。

**缺点**

1. **页表开销**：维护页表需要额外的内存和计算资源。
2. **不适合某些类型的数据或代码**：因为所有页都是固定大小的，可能不适合需要动态调整大小的数据结构。

**场景应用**

- 现代操作系统，如 Linux，Windows 和 macOS

- 大型和复杂的软件系统

- 虚拟内存系统

  

### 3. 分段存储管理

- #### 描述

  - 分段存储管理中，程序和数据被分为多个逻辑段。每个段有自己的起始地址和长度。
  - 地址空间被划分为不同的逻辑单位，如代码段、数据段和堆栈段。

  #### 主要特点

  1. **灵活性**：由于分段是逻辑上的划分，它允许每个段的大小按需分配。
  2. **易于共享和保护**：不同的段可以有不同的保护级别，也更容易进行资源共享。
  3. **支持高级语言特性**：更容易支持如数组和递归等高级编程语言特性。

  #### 缺点

  1. **内存碎片**：由于段大小不固定，可能会导致内存碎片。
  2. **地址转换复杂**：需要维护一个段表来进行虚拟地址到物理地址的转换，这增加了一些复杂性。

  #### 场景应用

  - 操作系统内核
  - 高级编程语言支持
  - 模块化程序设计

### 4. 混合分段/分页系统

- **描述**：将分段和分页结合起来使用。
- **优点**：结合了分段和分页的优点。
- **缺点**：管理相对复杂。
- **应用场景**：需要灵活和高效内存管理的高性能系统。

### 5. 虚拟内存

- **描述**：允许进程使用的地址空间超过物理内存，通常通过磁盘交换来实现。
- **优点**：增加了系统的灵活性和吞吐量。
- **缺点**：可能导致磁盘I/O性能瓶颈。
- **应用场景**：现代通用操作系统。

### 6. 伙伴系统（Buddy System）

- **描述**：内存被划分为大小为 2 的整数次幂的块。
- **优点**：高效，减少碎片。
- **缺点**：存在一定的内存浪费。
- **应用场景**：内存池管理，嵌入式系统。

### 7. 堆内存管理

- **描述**：由程序在运行时动态分配和释放。
- **优点**：灵活。
- **缺点**：可能导致内存泄漏和碎片。
- **应用场景**：动态数据结构，对象存储。

### 8. 栈内存管理

- **描述**：由编译器自动管理，用于存储函数调用的局部变量。
- **优点**：快速，无需手动管理。
- **缺点**：大小和生命周期受限。
- **应用场景**：函数调用，递归。

**9. 缓存管理**

- **描述**：频繁访问的数据或代码存储在快速但容量小的缓存中。
- **优点**：提高数据访问速度。
- **缺点**：增加了管理复杂性。
- **应用场景**：数据库，Web 服务器。



![image-20231020123409104](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020123409104.png)

保证系统不会发生死锁的最小M值为：M=N(W-1)+1。 

在分析这个问题时，死锁的一个关键点是：一个或多个进程因为无法获得它们所需的资源而永久地等待其他进程释放这些资源。

**分析各选项：**

1. **a.M=2, N=2, W=2**: 这里有2个进程，每个进程都需要2个资源，但总共只有2个资源。因此，每个进程都可能拿到一个资源，然后等待另一个资源，造成死锁。
2. **b.M=3, N=2, W=2**: 这里有3个资源和2个需要2个资源的进程。一个进程可能占用2个资源，另一个进程占用1个，然后释放，使得第一个进程可以获取剩下的一个。因此，不会发生死锁。
3. **c.M=3, N=2, W=3**: 这里有3个资源和2个进程，每个进程都需要3个资源。一个进程可能拿到2个资源，另一个进程拿到1个资源，然后都等待剩下的资源，造成死锁。
4. **d.M=5, N=3, W=2**: 这里有5个资源和3个需要2个资源的进程。理论上，所有3个进程都可以同时拿到它们所需的2个资源。因此，不会发生死锁。
5. **e.M=6, N=3, W=3**: 这里有6个资源和3个需要3个资源的进程。理论上，两个进程可以各自占用3个资源，而第三个进程等待。不会发生死锁。



![image-20231020123729873](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020123729873.png)

在这个问题中，我们需要考虑以下几个方面：

1. 磁盘块大小为1KB，即1024字节。
2. 直接索引指针有10个。
3. 一级和二级索引指针各1个。
4. 每个索引指针占4字节。

首先，考虑直接索引指针。这里有10个直接索引指针，所以前10KB（10240字节）可以通过直接索引来访问。即0~10239字节。

**对于偏移量1234：**

1234字节处于前10KB范围内（0-10239），所以只需访问1个磁盘块。

**对于偏移量307400：**

- 直接索引覆盖到10240字节。
- 一级索引：1KB/4字节 = 256，256个磁盘块可以通过一级索引来访问，即256KB（从10240字节到266240字节）。
- 剩下的需要通过二级索引。

307400字节 > 266240字节，所以需要使用二级索引。

二级索引覆盖：(1KB/4字节) * (1KB/4字节) = 256 * 256 = 65536个磁盘块，即65536KB。

访问磁盘块的数量：

1. 一次访问用于读取一级索引。
2. 一次访问用于读取二级索引。
3. 一次访问用于获取实际的磁盘块。

总共需要3次磁盘访问。

因此，对于1234和307400字节的偏移量，需访问的磁盘块个数分别是1和3。



![image-20231020124408586](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020124408586.png)

在Linux中，进程的主要状态包括：

1. 可运行状态（Runnable）：进程正在运行或在就绪队列中等待运行。
2. 阻塍状态（Blocked）：进程正在等待某种条件的发生（例如I/O操作完成）。
3. 僵死状态（Zombie）：进程已完成执行，但尚未被父进程清除。



进程的主要状态通常包括以下几种：

1. **新建（New）**: 进程正在创建，但尚未添加到可执行进程队列中。
2. **可运行（Runnable）或就绪（Ready）**: 进程已准备好运行并等待CPU时间。它已有所有必要的资源，除了CPU之外，一旦获得CPU时间，就会开始执行。
3. **运行（Running）**: 进程正在CPU上执行。在单核CPU上一次只能有一个进程在运行，而在多核系统中，多个进程可以同时运行。
4. **阻塞（Blocked）或等待（Waiting）**: 进程在等待某个事件发生或等待某种资源可用。例如，进程可能正在等待用户输入、磁盘I/O完成或某种系统资源变得可用。
5. **挂起（Suspended）**: 进程被挂起，通常是因为它要么是由用户手动挂起的，要么是因为系统资源不足。挂起的进程不能执行，但仍保留在内存中。
6. **终止（Terminated）或退出（Exited）**: 进程已完成执行或被显式地终止。
7. **僵死（Zombie）**: 进程已终止，但进程描述符仍在存在，因为父进程尚未读取子进程的退出状态。



![image-20231020124545854](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020124545854.png)

**Pipe (管道)**

1. **用途**: 主要用于有父子关系或者直接血缘关系的进程间的通信。
2. **特点**: 数据流是单向的，即从一个进程写入，另一个进程读出。
3. **缺点**: 只能在有直接关系的进程之间使用，并且通信是单向的。

**Named Pipe (命名管道, FIFO)**

1. **用途**: 类似于管道，但可以用于没有直接关系的进程间。
2. **特点**: 使用文件系统中的一个特殊文件作为数据传输的中介。
3. **缺点**: 通信仍然是单向的，但可以通过创建两个命名管道来实现双向通信。

**Semaphore (信号量)**

1. **用途**: 用于控制多个进程访问共享资源的顺序。
2. **特点**: 提供了一个计数器，该计数器用于追踪共享资源的使用状态。
3. **缺点**: 使用不当可能导致死锁。

**Message Queue (消息队列)**

1. **用途**: 用于不相关或者分布式进程之间的通信。
2. **特点**: 消息按照队列进行管理，可以实现复杂的消息优先级和查询功能。
3. **缺点**: 可能需要额外的同步和排队逻辑。

**Signal (信号)**

1. **用途**: 主要用于进程控制和状态通知。
2. **特点**: 异步，用于通知一个进程某个事件的发生。
3. **缺点**: 不适合大量数据的传输。

**Shared Memory (共享内存)**

1. **用途**: 多个进程共享一块内存区域。
2. **特点**: 非常高效，因为数据不需要在进程之间复制。
3. **缺点**: 需要额外的同步机制，如信号量。

**Socket** (套接字)

1. **用途**: 用于不同机器之间的进程通信，也可用于同一台机器上。
2. **特点**: 支持多种协议（TCP, UDP等）和数据格式。
3. **缺点**: 相对其他机制更为复杂，可能会有更高的延迟。



**线程间通信机制**

线程间通信（Inter-Thread Communication）由于所有线程共享相同的地址空间，因此相对于进程间通信来说，线程间通信通常更加简单和高效。以下是一些常见的线程间通信机制：

**1. 共享变量**

- **用途**: 最简单的方式，所有线程都可以访问这些变量。
- **特点**: 速度快，操作简单。
- **缺点**: 需要手动进行同步操作，以防止数据竞态。

**2. 互斥锁（Mutex）**

- **用途**: 用于控制对共享资源的访问。
- **特点**: 确保同一时刻只有一个线程能访问特定资源。
- **缺点**: 可能导致死锁，且可能有性能开销。

**3. 读-写锁（Read-Write Lock）**

- **用途**: 允许多个线程进行读操作，但写操作是互斥的。
- **特点**: 提高了读取操作的并发性。
- **缺点**: 相对复杂，需要更多的控制逻辑。

**4. 条件变量（Condition Variable）**

- **用途**: 允许线程在满足特定条件时被唤醒。
- **特点**: 非常灵活，可用于实现复杂的同步逻辑。
- **缺点**: 使用不当可能导致死锁或者性能问题。

**5. 信号量（Semaphore）**

- **用途**: 控制对资源或者任务队列的访问。
- **特点**: 可以用于实现生产者-消费者模型等。
- **缺点**: 同样可能导致死锁，且可能有性能开销。

**6. 屏障（Barrier）**

- **用途**: 同步一组线程，使它们在继续执行之前都达到一个点。
- **特点**: 确保所有线程都准备好进行下一步操作。
- **缺点**: 使用不当可能导致程序挂起。

**7. 线程局部存储（Thread-Local Storage, TLS）**

- **用途**: 存储每个线程的局部数据。
- **特点**: 避免了使用全局变量，简化了线程间数据的传递。
- **缺点**: 过度使用可能导致资源浪费和管理复杂性增加。

**8. 消息队列**

- **用途**: 用于传递消息或任务。
- **特点**: 可以实现复杂的流程控制。
- **缺点**: 需要额外的数据结构和同步。



![image-20231020125121427](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125121427.png)

在PC机的“Pentium 4/1.8G”或“Celeron/1.7G”中的“G”通常是指"GHz"，也就是吉赫兹（GigaHertz）。

吉赫兹是频率的单位，用于描述处理器周期的速度。在这个上下文中，1.8G和1.7G意味着处理器的时钟频率是1.8吉赫兹和1.7吉赫兹，分别对应Pentium 4和Celeron处理器。

简单地说，这个数字通常用于衡量CPU的运算速度。



![image-20231020125256466](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125256466.png)

逻辑文件通常有两种形式：流式文件（Stream-Oriented Files）和记录式文件（Record-Oriented Files）。

**流式文件：**

- **特点**: 数据存储为一连串的字节，没有固定的结构或界限。
- **用途**: 通常用于文本文件或者二进制文件，比如图像、音频等。

**记录式文件：**

- **特点**: 数据按照特定的结构或格式（通常为记录）进行组织。
- **用途**: 数据库文件、电子表格等。

现在来回答题目中的陈述：

- **源程序文件**: 一般为文本文件，文本文件通常被视为流式文件。因为它们由一连串的字节组成，没有固定的结构或界限。
- **学生选课文件**: 这种文件可能包含学生信息、课程信息等，更有可能是按照某种结构或记录来组织的，例如CSV或数据库表。



![image-20231020125421293](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125421293.png)

在磁盘阵列（RAID）中，RAID 10（也称为RAID 1+0）和RAID 50（也称为RAID 5+0）是两种常见的配置方式。我们来一步步地分析这两种RAID配置下的可用存储容量。

**RAID 10 (1+0)**

- **配置**: RAID 10 是一个由 RAID 1 和 RAID 0 组成的嵌套阵列。在这种配置中，首先创建镜像对（RAID 1），然后对这些镜像对进行条带化（RAID 0）。
- **磁盘数**: 在 RAID 10 配置中，至少需要4块磁盘。问题中给出的是8块600G磁盘。
- **可用容量**: 在 RAID 10 中，每一个镜像对（2块磁盘）中只有一块磁盘的容量是可用的（因为另一块是镜像）。所以，总的可用容量是 `8 / 2 * 600G = 2400G`。

**RAID 50 (5+0)**

- **配置**: RAID 50 是一个由 RAID 5 和 RAID 0 组成的嵌套阵列。在这种配置中，首先创建 RAID 5 阵列，然后对这些 RAID 5 阵列进行条带化（RAID 0）。
- **磁盘数**: 在最简单的 RAID 50 配置中，至少需要6块磁盘（每个 RAID 5 阵列至少3块，然后至少需要两个这样的阵列）。问题中给出的是8块600G磁盘。
- **可用容量**: 在一个 RAID 5 阵列中，一个磁盘的容量用于奇偶校验。假设我们有两个 RAID 5 阵列，每个包含4个磁盘，那么每个阵列中会有3个磁盘的容量是可用的。总的可用容量是 `2 * (3 * 600G) = 3600G`。

综上，8块600G磁盘分别作RAID 10和RAID 50时，整个虚拟盘的可用容量分别是2400G和3600G。



RAID（冗余独立磁盘阵列，Redundant Array of Independent Disks）是一种用于将多个硬盘驱动器组合成一个单一的逻辑单元的数据存储虚拟化技术。其主要目的是提高数据可靠性、容错能力和/或提高数据访问性能。

以下是几种常见的RAID级别：

### RAID 0（条带化）

- **组成**：至少需要2个磁盘。
- **性能**：提供最高的读写性能，但没有冗余。
- **可用容量**：所有磁盘容量的总和。

### RAID 1（镜像）

- **组成**：需要偶数数量的磁盘。
- **性能**：读取性能良好，写入性能可能较差。
- **可用容量**：单个磁盘的容量（其他磁盘用于镜像）。

### RAID 5（带奇偶校验的条带化）

- **组成**：至少需要3个磁盘。
- **性能**：读取性能良好，写入性能一般。
- **可用容量**：（N-1）个磁盘的容量。

### RAID 6（双奇偶校验）

- **组成**：至少需要4个磁盘。
- **性能**：读取性能良好，写入性能较差。
- **可用容量**：（N-2）个磁盘的容量。

### RAID 10（或1+0，镜像+条带化）

- **组成**：需要偶数数量的磁盘，最少4个。
- **性能**：读写性能都很优秀。
- **可用容量**：总容量的一半。

### RAID 50（或5+0，RAID 5 + 条带化）

- **组成**：通常需要6个或更多的磁盘。
- **性能**：读写性能都很优秀。
- **可用容量**：大约是（N-2）个磁盘的容量，但这取决于子阵列的配置。

### 相关设备和技术

- **硬件RAID**：使用专门的硬件控制器进行RAID运算。
- **软件RAID**：使用操作系统内的软件进行RAID运算。

RAID可以在多种环境中使用，包括服务器、网络附加存储（NAS）设备和存储区域网络（SAN）。



![image-20231020125959987](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020125959987.png)

临界资源（Critical Resource）是在并发编程中，多个线程或进程不能同时访问或修改的资源。这些资源通常包括共享变量、数据结构、外部设备，或者是一些用于维护程序逻辑的系统资源。因为多个线程或进程访问这些资源可能导致数据的不一致或者是其他的未定义行为，所以需要特殊的机制来同步和协调对这些资源的访问。

例如，在操作系统中，文件、打印机、数据库记录等都可以是临界资源。在多线程程序中，共享变量或数据结构也可能成为临界资源。

为了管理对临界资源的访问，通常使用以下同步机制：

1. **互斥锁（Mutex）**：确保一次只有一个线程或进程可以访问临界资源。
2. **信号量（Semaphore）**：允许有限数量的线程或进程同时访问临界资源。
3. **读写锁（Read-Write Locks）**：允许多个读操作同时进行，但写操作是独占的。
4. **条件变量（Condition Variables）**：用于等待某个特定条件成立才访问临界资源。
5. **自旋锁（Spinlock）**：当资源被占用时，线程会不断检查是否可以获得资源，而不是进入休眠。
6. **死锁检测与预防**：避免多个线程或进程相互等待对方释放资源，导致整个系统停滞。
7. **优先级调度和反向优先级继承**：用于解决优先级反转问题，即低优先级的线程占用了高优先级线程所需的临界资源。
8. **事务和数据库锁**：在数据库环境中用于确保数据的一致性。

对临界资源的访问需要仔细设计和高度警觉，以避免出现竞态条件、死锁或其他同步问题。



**在 CD 光盘上标记有“ CD-RW ”字样，“ RW ”标记表明该光盘是（）。**

在CD光盘上标记有“CD-RW”字样时，“RW”标记表明该光盘是可重写（Rewritable）的。这意味着你不仅可以将数据写入这种类型的光盘，还可以擦除和重新写入数据。这与CD-R（只读记录）光盘不同，CD-R光盘只允许你一次性地写入数据，之后就不能再进行修改或删除。

CD-RW光盘常用于数据备份、临时存储和文件传输等。但由于它们通常具有相对较低的读/写速度和较高的成本，以及由于USB闪存驱动器和网络存储越来越普及，CD-RW的使用已经相对减少。



![image-20231020130141974](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130141974.png)

在程序运行时，磁盘与主机之间的数据传送通常是通过DMA（Direct Memory Access，直接内存访问）方式进行的，即选项B。

解释如下：

A. 中断方式：这种方式是CPU负责从磁盘读取数据，并将其放入内存中。每次读取或写入一个数据块后，CPU会收到一个中断，通知它数据已准备好或已成功写入。这种方式会占用大量CPU时间。

B. DMA方式：在这种方式下，专门的DMA控制器负责将数据从磁盘传输到内存（或反之），而CPU则可以继续执行其他任务。当整个传输完成后，DMA控制器会发出一个中断来通知CPU。这种方式更为高效，因为它不会占用大量的CPU资源。

C. 陷阱：这是一种特殊的软件中断，通常用于操作系统内核和用户程序之间的交互，而不是用于数据传输。

D. 程序直接控制：这是一种非常低级的数据传输方式，需要程序直接控制硬件进行数据传输，通常不用于磁盘和主机之间的数据交换。





**死锁发生的条件**


产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



![image-20231020130438467](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130438467.png)

CPU不直接访问的存储器通常是外部存储器，例如硬盘、SSD、光盘、磁带等。这些类型的存储器需要通过I/O接口和相应的驱动程序来进行数据的读写操作。

解释如下：

1. 主存（RAM）：CPU可以直接访问主存（RAM）以获取指令和数据。
2. 缓存：在现代计算机体系结构中，CPU内部通常有多级缓存（L1, L2, L3等），这些也是CPU可以直接访问的。
3. 寄存器：这些是CPU内部的小容量存储单元，用于临时存储数据和指令，CPU可以非常快速地访问它们。
4. 外部存储器：如硬盘、SSD、光盘、USB驱动器等，这些是CPU不能直接访问的，需要通过操作系统和I/O子系统来访问。
5. 网络存储：如NAS（网络附加存储）、SAN（存储区域网络）等，这些也是CPU不能直接访问的。

因此，CPU不直接访问的存储器主要是外部存储器。



![image-20231020130535179](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231020130535179.png)

在Windows操作系统中，文件名不能包含以下字符：\ / : * ? " < > |。