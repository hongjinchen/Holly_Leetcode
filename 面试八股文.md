

# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

## 创建型模式（Creational Patterns）

### **单例模式（Singleton）**

单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

在单例模式的实现中，通常会：

1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
2. 创建一个**私有静态成员变量**，用于保存**单一实例**。
3. 提供一个**公共静态方法**来获取这个**唯一的实例**。



使用单例模式的理由主要有：

- 控制资源的使用，通过确保只有一个实例减少内存开销，如配置管理器、线程池等。
- 避免对资源的多重占用，例如一个文件的多重写操作，可能会导致数据冲突。
- 有时用于全局访问点，整个应用环境中只有一个全局实例。

单例模式在Java中的一个基本实现示例如下：

```
public class Singleton {
    // 私有静态变量，存储唯一实例
    private static Singleton instance;

    // 私有构造方法，防止外部直接使用new来创建对象
    private Singleton() {}

    // 公有静态方法，返回唯一实例
    public static Singleton getInstance() {
        if (instance == null) {
            // 如果实例不存在，就创建一个
            instance = new Singleton();
        }
        return instance;
    }
}
```

这是单例模式的懒汉式实现，它是延迟加载的，只有在实际需要时才创建实例。另一种常见的是饿汉式实现，它在类加载时就创建实例。

需要注意的是，上述懒汉式实现在多线程环境下可能不安全，如果多个线程同时进入`if (instance == null)` 判断，那么可能会创建多个实例。为了避免这种情况，可以将`getInstance()` 方法同步，或者使用其他技术来确保线程安全。



### **工厂方法模式（Factory Method）**

工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它**提供了一个接口用于创建对象**，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

工厂方法模式主要包括以下几个组件：

1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

如何实现

1. **定义一个返回对象（Product）的工厂接口（Creator）**。
2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

```python
from abc import ABC, abstractmethod

# Product 类
class Button(ABC):

    @abstractmethod
    def click(self):
        pass

# ConcreteProduct 类
class WindowsButton(Button):
    
    def click(self):
        print("Windows button clicked")

class LinuxButton(Button):
    
    def click(self):
        print("Linux button clicked")

# Creator 类
class ButtonFactory(ABC):
    
    @abstractmethod
    def create_button(self):
        pass

# ConcreteCreator 类
class WindowsButtonFactory(ButtonFactory):
    
    def create_button(self):
        return WindowsButton()

class LinuxButtonFactory(ButtonFactory):
    
    def create_button(self):
        return LinuxButton()

# 客户端代码
def button_client_code(factory):
    button = factory.create_button()
    button.click()

# 使用
windows_factory = WindowsButtonFactory()
button_client_code(windows_factory)

linux_factory = LinuxButtonFactory()
button_client_code(linux_factory)

```



Java集合框架（Java Collections Framework）的设计允许用户使用多种方式来创建和管理集合，而具体的实现细节（如数据如何存储、如何进行元素搜索等）则隐藏在这些实现类中。这样，用户可以根据自己的需求选择最合适的集合类型，而不用关心其背后的实现。

例如，当你需要一个 `List` 类型的集合时，你只需选择实现了 `List` 接口的一个类，如 `ArrayList` 或 `LinkedList`，来具体实现你的需求。Java的 `Collections` 工具类则提供了静态工厂方法来创建这些集合的实例，这进一步抽象了对象的创建过程，使得选择具体实现类的决策更加灵活。

这里有一个Java中使用`List`接口创建不同类型列表的例子：

```java
List<String> arrayList = new ArrayList<>();
List<String> linkedList = new LinkedList<>();
```

在这个例子中，`List` 是一个工厂接口，而 `ArrayList` 和 `LinkedList` 是具体的产品。你可以在代码中任何需要 `List` 行为的地方使用这些产品，而不需要关心它们的内部实现，从而实现了代码的松耦合和高可替换性。

所以，Java集合框架中的这些接口和它们的实现类反映了设计模式中的抽象工厂模式和工厂方法模式的原则。



### **抽象工厂模式（Abstract Factory）**

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，**用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类**。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

**结构和组件**

1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

   

   1. **定义抽象产品的接口（AbstractProduct）**。

   2. **创建实现该接口的具体产品（ConcreteProduct）**。

   3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

   4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

   5. **使用具体工厂和抽象工厂来创建产品实例**。

      

   ```python
   from abc import ABC, abstractmethod
   
   # 抽象产品
   class Button(ABC):
       @abstractmethod
       def click(self):
           pass
   
   class Checkbox(ABC):
       @abstractmethod
       def check(self):
           pass
   
   # 具体产品
   class WindowsButton(Button):
       def click(self):
           print("Windows Button clicked")
   
   class WindowsCheckbox(Checkbox):
       def check(self):
           print("Windows Checkbox checked")
   
   class LinuxButton(Button):
       def click(self):
           print("Linux Button clicked")
   
   class LinuxCheckbox(Checkbox):
       def check(self):
           print("Linux Checkbox checked")
   
   # 抽象工厂
   class GUIFactory(ABC):
       @abstractmethod
       def create_button(self):
           pass
   
       @abstractmethod
       def create_checkbox(self):
           pass
   
   # 具体工厂
   class WindowsGUIFactory(GUIFactory):
       def create_button(self):
           return WindowsButton()
   
       def create_checkbox(self):
           return WindowsCheckbox()
   
   class LinuxGUIFactory(GUIFactory):
       def create_button(self):
           return LinuxButton()
   
       def create_checkbox(self):
           return LinuxCheckbox()
   
   # 客户端代码
   def client_code(factory):
       button = factory.create_button()
       checkbox = factory.create_checkbox()
       
       button.click()
       checkbox.check()
   
   # 使用
   windows_factory = WindowsGUIFactory()
   client_code(windows_factory)
   
   linux_factory = LinuxGUIFactory()
   client_code(linux_factory)
   
   ```

   

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

抽象工厂模式是一种创建型设计模式，它提供了一个创建一系列相关或依赖对象的接口，而无需指定它们具体的类。在Java和Python中，抽象工厂模式通常用于创建一组具有共同主题的对象，但在不同主题之间进行切换时无需修改客户代码。



**Java中的抽象工厂模式实例：**

Java中的数据库连接池通常使用抽象工厂模式。例如，`javax.sql.DataSource` 是一个数据源的抽象工厂接口，它可以用来获取数据库连接。根据不同的数据库（如MySQL、Oracle、PostgreSQL），可以有不同的实现，但使用者不需要关心具体的实现细节。

`DBConnectionFactory` 是一个抽象工厂接口，`MySQLConnectionFactory` 和 `OracleConnectionFactory` 是具体的工厂实现。客户端代码仅依赖于 `DBConnectionFactory` 接口，**使得切换不同的数据库连接实现变得非常简单。**



**Python中的抽象工厂模式实例：**

在Python中，一个GUI工具库可能使用抽象工厂模式来提供跨平台的窗口和控件创建。这里是一个简单的例子：

```python
# 抽象产品
class Button:
    def paint(self):
        pass

# 具体产品
class WindowsButton(Button):
    def paint(self):
        print("Render a button in a Windows style")

class MacOSButton(Button):
    def paint(self):
        print("Render a button in a MacOS style")

# 抽象工厂
class GUIFactory:
    def create_button(self):
        pass

# 具体工厂
class WindowsFactory(GUIFactory):
    def create_button(self):
        return WindowsButton()

class MacOSFactory(GUIFactory):
    def create_button(self):
        return MacOSButton()

# 客户端代码
def client_code(factory: GUIFactory):
    button = factory.create_button()
    button.paint()

# 使用
if __name__ == "__main__":
    os_name = "Windows"  # This could be an environment variable
    factory = WindowsFactory() if os_name == "Windows" else MacOSFactory()
    client_code(factory)
```

在这个Python示例中，`GUIFactory` 是一个抽象工厂类，`WindowsFactory` 和 `MacOSFactory` 是具体工厂的实现。客户端代码（`client_code` 函数）只依赖于 `GUIFactory` 抽象类，因此可以轻松地在 `Windows` 和 `MacOS` 控件之间切换而不需改动客户端代码。

在这两个例子中，抽象工厂模式允许系统独立于如何创建、组合和表示产品。这使得系统在不同环境中配置产品族，而对客户端代码的影响最小化。



## 结构型模式（Structural Patterns）

### **适配器模式（Adapter）**

**适配器模式（Adapter Pattern）是一种结构型设计模式，它允许不兼容的接口之间能够相互合作。这种模式涉及到一个单独的类，该类负责加入独立的或不兼容的接口功能。**

**假设你有两个类，它们的接口不兼容，一个无法直接调用另一个的方法。适配器模式就是创建一个新类，它与一个或多个这样的具有不兼容接口的类协同工作，通过在内部包装这些类，来提供一个统一的接口。**

适配器模式通常有两种实现方式：
- **对象适配器模式**：使用组合来连接到适配器的接口。
- **类适配器模式**：使用多重继承来适配一个或多个适配者。



**Java中的适配器模式示例：**

假设你有一个`MediaPlayer`接口，它有一个`play()`方法，你还有一个`AdvancedMediaPlayer`接口，具有不同的`playVlc()`和`playMp4()`方法。现在，如果你想要让`MediaPlayer`的实现能够使用`AdvancedMediaPlayer`的功能，你可以创建一个适配器类。

```java
// 目标接口
public interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 适配者接口
public interface AdvancedMediaPlayer { 
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// 适配者接口的具体实现
public class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file. Name: "+ fileName);        
    }

    @Override
    public void playMp4(String fileName) {
        // do nothing
    }
}

public class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // do nothing
    }

    @Override
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file. Name: "+ fileName);
    }
}

// 适配器
public class MediaAdapter implements MediaPlayer {

    AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String audioType){
        if(audioType.equalsIgnoreCase("vlc") ){
            advancedMusicPlayer = new VlcPlayer();            
        } else if (audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer = new Mp4Player();
        }    
    }

    @Override
    public void play(String audioType, String fileName) {
        if(audioType.equalsIgnoreCase("vlc")){
            advancedMusicPlayer.playVlc(fileName);
        }else if(audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 客户端
public class AudioPlayer implements MediaPlayer {
    MediaAdapter mediaAdapter; 

    @Override
    public void play(String audioType, String fileName) {

        // 内置支持播放mp3音乐文件
        if(audioType.equalsIgnoreCase("mp3")){
            System.out.println("Playing mp3 file. Name: " + fileName);            
        } 
        // mediaAdapter 提供了播放其他文件格式的支持
        else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")){
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        }
        else{
            System.out.println("Invalid media. " + audioType + " format not supported");
        }
    }   
}

public class AdapterPatternDemo {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();

        audioPlayer.play("mp3", "beyond the horizon.mp3");
        audioPlayer.play("mp4", "alone.mp4");
        audioPlayer.play("vlc", "far far away.vlc");
        audioPlayer.play("avi", "mind me.avi");
    }
}
```

在上面的代码中，`MediaAdapter`是适配器，它实现了`MediaPlayer`接口并使用组合方式引用了`AdvancedMediaPlayer`对象。`AudioPlayer`是客户端类，它通过`MediaPlayer`接口与`MediaAdapter`进行交互。



**Python中的适配器模式示例：**

在Python中，我们可以使用特殊方法`__getattr__`来实现

一个简单的适配器：

```python
class Target:
    def request(self):
        return "Target: The default target's behavior."

class Adaptee:
    def specific_request(self):
        return ".eetpadA eht fo roivaheb laicepS"

class Adapter(Target, Adaptee):
    def request(self):
        return f"Adapter: (TRANSLATED) {self.specific_request()[::-1]}"

def client_code(target):
    print(target.request(), end="")

if __name__ == "__main__":
    print("Client: I can work just fine with the Target objects:")
    target = Target()
    client_code(target)
    print("\n")

    adaptee = Adaptee()
    print("Client: The Adaptee class has a weird interface. "
          "See, I don't understand it:")
    print(f"Adaptee: {adaptee.specific_request()}", end="\n\n")

    print("Client: But I can work with it via the Adapter:")
    adapter = Adapter()
    client_code(adapter)
```

在这个例子中，`Adaptee` 是一个具有特殊请求方法的类，其接口与`Target`类的接口不兼容。`Adapter` 类通过继承`Target` 并引用`Adaptee` 的一个实例，来使两个不兼容的接口能够一起工作。

在这两种语言中，适配器模式都是用来解决接口不兼容的问题，它允许原本不可能一起工作的类可以在一起工作。



### **装饰器模式（Decorator）**

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你动态地将行为添加到对象上，而无需修改其实现的类。这种模式通过创建一个包装器（一个装饰器对象）来包裹原始对象，并在保持原始对象类方法签名不变的前提下，提供额外的功能。

装饰器模式的关键优点是它遵循开闭原则，即软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。使用装饰器模式可以在不修改现有对象的情况下，通过添加新的装饰器类来增强对象的行为。

### 
装饰器模式通常涉及以下角色：
1. **组件（Component）**：定义一个对象接口，可以给这些对象动态添加职责。
2. **具体组件（ConcreteComponent）**：定义了一个具体的对象，也可以给这个对象添加一些职责。
3. **装饰（Decorator）**：持有一个组件对象的引用，并定义一个与组件接口一致的接口。
4. **具体装饰（ConcreteDecorator）**：向组件添加职责。



**Python中的装饰器模式示例**

在Python中，装饰器模式可以通过使用闭包和装饰器语法糖来实现，这里是一个简单的例子：

```python
from functools import wraps

# 组件
class Coffee:
    def get_cost(self):
        return 1

    def get_ingredients(self

):
        return "Coffee"

# 装饰器
def milk(coffee_class):
    @wraps(coffee_class)
    def wrapper(*args, **kwargs):
        c = coffee_class(*args, **kwargs)
        c.get_cost = lambda: c.get_cost() + 0.5
        c.get_ingredients = lambda: c.get_ingredients() + ", Milk"
        return c
    return wrapper

def sugar(coffee_class):
    @wraps(coffee_class)
    def wrapper(*args, **kwargs):
        c = coffee_class(*args, **kwargs)
        c.get_cost = lambda: c.get_cost() + 0.5
        c.get_ingredients = lambda: c.get_ingredients() + ", Sugar"
        return c
    return wrapper

# 使用装饰器
@milk
@sugar
class SomeCoffee(Coffee):
    pass

if __name__ == '__main__':
    coffee = SomeCoffee()
    print("Cost: " + str(coffee.get_cost()) + "; Ingredients: " + coffee.get_ingredients())
```

在这个Python代码中，我们使用了装饰器函数（`milk` 和 `sugar`）来装饰 `Coffee` 类，为其动态地增加额外的行为。

在这两种语言中，装饰器模式提供了一个非常灵活的方式来遵循单一职责原则，通过将职责分配到小的、独立的类中，而不是在一个复杂的类结构中管理它们。这种模式在GUI库、流处理、业务逻辑等许多场景中都很有用。



### **组合模式（Composite）**

**组合模式（Composite Pattern）是一种结构型设计模式，用于表示具有树形结构的对象组合。这种模式允许客户以一致的方式处理单个对象和对象组合。**

组合模式通常用于创建一个层次结构，例如图形用户界面中的控件集合，文件系统中的目录和文件，或任何需要表示对象的部分-整体层次结构的场所。



- **角色和职责：**

组合模式主要包括以下几个角色：

1. **抽象组件（Component）**：
   这是一个抽象接口，声明了叶节点和容器节点共有的操作。它可以是一个抽象类或者接口。

2. **叶节点（Leaf）**：
   叶节点是组合的基本单元，表示没有子节点的对象。它实现或继承了`Component`接口。

3. **复合组件（Composite）**：
   一个容器节点，可以有子节点，子节点可以是其他`Composite`或`Leaf`对象。复合组件同样实现或继承`Component`接口。

4. **客户端（Client）**：
   通过`Component`接口与组合结构中的对象进行交互。
   
   

- **优点和应用场景**：

组合模式的优点包括：

- **统一性**：客户端代码可以统一对待单个对象和组合对象，无需关心处理的是单个对象还是整个组合结构。
- **灵活性**：轻松地添加新类型的组件，因为客户端代码与具体类的实现解耦。
- **简洁性**：客户端代码更加简洁，因为树形结构中的任何组件都可以一致对待。

组合模式适用于以下场景：

- 当你希望客户代码可以忽略组合对象与单个对象的差异时。

- 当你希望构建对象的部分-整体层次结构时。

  

- **Java示例：**

下面是使用组合模式的一个简单Java示例：

```java
// 抽象组件
public interface Component {
    void operation();
}

// 叶子组件
public class Leaf implements Component {
    private String name;

    public Leaf(String name) {
        this.name = name;
    }

    @Override
    public void operation() {
        System.out.println("Leaf " + name + " is operated on.");
    }
}

// 复合组件
public class Composite implements Component {
    private List<Component> children = new ArrayList<>();

    public void add(Component component) {
        children.add(component);
    }

    public void remove(Component component) {
        children.remove(component);
    }

    @Override
    public void operation() {
        for (Component child : children) {
            child.operation();
        }
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Composite root = new Composite();
        root.add(new Leaf("Leaf 1"));
        root.add(new Leaf("Leaf 2"));

        Composite sub = new Composite();
        sub.add(new Leaf("Leaf 3"));
        root.add(sub);

        root.operation();
    }
}
```

在上述例子中，`Composite` 类有一个包含`Component`对象的列表。它的`operation()`方法会遍历所有子对象，并调用它们的`operation()`方法，不论这些子对象是`Leaf`还是`Composite`。客户端代码（`Client`类）可以一致地对待`Leaf`和`Composite`对象。



## 行为型模式（Behavioral Patterns）

### **观察者模式（Observer）**

当一个对象的状态发生变化时，其依赖者都会得到通知。



### **策略模式（Strategy）**

定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。



### **命令模式（Command）**

将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。





## 美团面试真题

### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）





### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。



### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。



# 中移物联

**引领物联网技术创新，赋能千行百业，共创万物互联的美好生活。**



**"拼搏、工匠、创新"** 这个**企业文化概念**可以从几个方面来理解：

1. **拼搏（Striving）**：这一部分强调的是**努力和奋斗的精神**。在企业文化中，拼搏通常意味着员工需要保持高度的热情和动力，不断地追求目标和成就。这种文化鼓励积极进取，**面对困难和挑战时不轻易放弃**。
2. **工匠（Craftsmanship）**：工匠精神代表着**对工作的热爱、对品质的追求以及精益求精的态度**。在这样的企业文化中，**员工被鼓励像工匠一样对待他们的工作，注重细节，追求卓越，不断提高自己的技能和工作质量。**
3. **创新（Innovation）**：创新是企业持续发展的关键。这部分文化强调**开放思维、探索新方法、开发新产品或改进现有产品。**在这种文化中，鼓励员工思考如何打破常规，寻求更有效、更高效的解决方案。



**中移物联网简介**

中移物联网有限公司是中国移动通信集团有限公司的全资子公司，是中国移动在物联网领域的主责企业。公司定位为物联网核心能力的锻造者、物联网专业市场的领导者、全网物联网业务的支撑者、科技型企业改革的示范者。

中移物联网有限公司积极践行中国移动集团发展战略部署，以“做出新规模”、“锻造新能力”、“开创新机制”、“谋划新布局”为目标，围绕“四新”开新局，不断推动产业数字化、数字产业化。

公司聚焦物联网业务能力建设与市场拓展，重点围绕物联网基础通用能力、视频物联网（VIoT）、智能物联网（AIoT）、产业物联网（IIoT）打造物联网核心技术和产品，支撑全网物联网业务发展。

数字经济赋能千行百业，5G融合驱动万物互联。中移物联网有限公司将把握数智化转型机遇，携手各界合作伙伴，共同开启数字经济发展新篇章！



**Web开发工程师需要具备的能力**

作为一什名Web开发工程师，除了具备专业的技术素质，还需要一系列的软技能和其他能力来提升自己的职业素养。以下是一些重要的非技术性能力：

1. **沟通技能**：这是非常重要的，因为你需要与团队成员、客户、利益相关者沟通需求、解决方案和进展。

2. **团队合作**：Web开发通常是团队工作。合作能力、适应团队工作流程和文化、以及有效地协同工作非常关键。

3. **解决问题的能力**：在开发过程中遇到问题是常有的事。能够有效地识别、分析和解决问题是必需的技能。

4. **学习能力**：技术领域不断发展，持续学习新技术和工具是必不可少的。

5. **时间管理和自我组织**：有效管理时间，合理安排任务和截止日期，能够提高工作效率。

6. **适应能力和灵活性**：能够适应快速变化的技术环境和项目需求的调整。

7. **注意细节**：在编码和设计中，对细节的关注可以减少错误和提高产品质量。

8. **创造力和创新思维**：创新的解决方案可以帮助解决复杂的问题，并提高工作的效率和质量。

9. **用户体验理解**：了解用户需求和体验，能够开发出更符合用户需求的产品。

10. **项目管理技能**：能夠管理项目流程、资源分配和风险评估。



**假如作为测试组长，怎么评价团队中的组员的工作好坏？**

1. **技术能力**：
   - 评估成员在测试设计、测试用例的编写、缺陷跟踪、自动化测试等方面的技术能力。
   - 观察他们是否能有效地使用测试工具和技术。
2. **问题解决能力**：
   - 观察成员在遇到测试中的问题时是如何分析和解决问题的。
   - 评价他们的创新思维和解决问题的能力。
3. **细节关注**：
   - 测试工作中对细节的关注非常重要。评估成员是否能准确无误地执行测试用例，是否能发现和记录软件中的微妙缺陷。
4. **沟通和协作能力**：
   - 观察成员如何与团队其他成员以及跨部门团队（如开发、产品管理）沟通交流。
   - 评估他们在团队中的合作程度以及在解决冲突中的能力。
5. **效率和生产力**：
   - 评估成员完成任务的速度和质量，以及他们管理时间和优先级的能力。
   - 观察他们对工作流程的适应性和对提高工作效率的贡献。
6. **自我改善和学习能力**：
   - 评估成员是否主动学习新技术、新工具和测试方法。
   - 观察他们是否能从错误中学习并改进自己的工作。
7. **主动性和责任感**：
   - 评估成员是否能主动承担责任，对自己的工作负责。
   - 观察他们是否能在不需要过多指导的情况下独立完成任务。
8. **质量意识**：
   - 评估成员在测试工作中对于保证软件质量的重视程度。
   - 观察他们是否能识别并提出改进产品质量的建议。



**对于前端开发人员，如何去评价团队中的组员的工作好坏？**

1. **技术能力和专业知识**：

   - 评估团队成员在HTML、CSS、JavaScript等前端技术方面的熟练程度。
   - 了解他们是否能有效使用前端框架和工具（如React, Vue, Angular等）。
   - 观察他们对于响应式设计、浏览器兼容性等方面的处理能力。

2. **代码质量和维护性**：

   - 检查代码是否干净、整洁、易于理解和维护。
   - 评价他们遵循最佳实践和代码规范的能力。

3. **性能优化**：

   - 评估他们在前端性能优化方面的知识和实践，比如减少页面加载时间、优化资源使用等。

4. **用户体验和设计感知**：

   - 观察他们在设计实现过程中对用户体验的关注程度。
   - 评估他们将设计稿转换为实际界面时的准确性和对细节的关注。

5. **问题解决能力**：

   - 了解他们面对问题时的解决方法和创造性思维。
   - 观察他们在遇到难题时是否能持续寻找解决方案。

6. **沟通和团队合作**：

   - 评估他们与团队成员（包括开发者、设计师、产品经理等）的沟通效果。
   - 观察他们在团队协作中的参与度和贡献。

7. **学习和适应能力**：

   - 观察他们对新技术、新工具的学习速度和适应性。
   - 评价他们对行业趋势的关注程度和持续学习的态度。

8. **时间管理和工作效率**：

   - 评估他们按时完成任务的能力。
   - 观察他们在工作中的效率和对时间的管理。

9. **创新和主动性**：

   - 评价他们在工作中是否能提出新想法，是否能主动寻找改善工作流程和产品的方法。

10. **项目管理和责任感**：

    - 观察他们在项目管理中的参与度和责任感。

    - 了解他们在处理多任务和紧急情况时的能力。

      

**减少页面加载时间**

1. **优化图片和媒体文件**：
   - 压缩图片和视频文件，减少它们的大小。
   - 使用正确的文件格式，例如，对于图像使用JPEG（更小的文件）或PNG（更高的质量）。
   - 使用响应式图片（`<picture>` 标签或 `srcset` 属性），以根据不同的设备尺寸加载不同大小的图片。
2. **最小化和合并文件**：
   - 将CSS和JavaScript文件最小化（删除多余的空格、注释等），减少文件大小。
   - 合并多个CSS和JavaScript文件，减少HTTP请求的数量。
3. **使用浏览器缓存**：
   - 设置合适的缓存策略，使得返回访问者可以加载页面上已经缓存的资源。
4. **使用内容分发网络（CDN）**：
   - 将内容放在不同地理位置的服务器上，减少数据传输的延迟。
5. **优化CSS和JavaScript**：
   - 确保关键的CSS是内联的，而不是外部加载的，以减少阻塞渲染的资源。
   - 将JavaScript脚本放在页面底部，以防止JS阻塞DOM的构建。
6. **减少HTTP请求**：
   - 通过合并文件、使用CSS精灵图、减少外部脚本等方法减少HTTP请求的数量。
7. **使用异步或延迟加载**：
   - 对于非关键JavaScript和CSS使用异步（`async`）或延迟（`defer`）加载。
8. **优化Web字体**：
   - 减少使用的字体变体数量。
   - 使用现代格式的字体文件（如WOFF2）。
9. **优化服务器响应时间**：
   - 使用高效的服务器和网络资源。
   - 优化数据库查询。
   - 使用缓存策略来减少重复的数据处理。

1. **移动优先的设计**：
   - 针对移动设备优化页面，因为它们通常比台式机有更慢的网络连接。
2. **监控和分析**：
   - 使用工具如Google PageSpeed Insights、Lighthouse或WebPageTest等，来监控网页性能，并根据建议进行优化。