# HTML

### 基础的HTML页面元素

在构成一个基础的HTML页面中，有几个必要或者说基础的元素，这些元素构成了HTML页面的骨架。下面是这些基础元素的简要概述：

`<!DOCTYPE html>`

这不是一个HTML标签，但它告诉浏览器你正在使用的是HTML5。这应该是你HTML文件的第一行。

```

<!DOCTYPE html>
```

`<html>`

这个元素是所有其他HTML元素的容器。它通常包含两个子元素：`<head>` 和 `<body>`。

```
<html>
  <!-- head and body go here -->
</html>
```

`<head>`

这个元素包含了关于文档的元数据（metadata），这些信息不会显示在页面内容中。常见的子元素有 `<title>`、`<meta>`、`<link>`、`<script>` 等。

```
<head>
  <title>Page Title</title>
</head>
```

`<title>`

这个元素定义了浏览器窗口的标题或者页面在搜索引擎结果中的标题。它是 `<head>` 区域的一个重要组成部分。

```

<title>This is the page title</title>
```

`<meta>`

元数据标签用于提供有关页面的各种信息，如字符集、作者、描述等。

```
<meta charset="UTF-8">
<meta name="description" content="This is a description">
```

`<body>`

这个元素包含了所有要显示给用户的内容，包括文本、图像、视频、游戏、可播放轨迹、等等。

```
<body>
  <!-- your content goes here -->
</body>
```



**其他可选但常用的元素**

虽然下面的元素不是严格“必要”的，但它们经常出现在实际页面中：

- `<header>`：用于包含页面或区域的标题和其他信息。

- `<footer>`：用于包含页面或区域的页脚信息。

- `<nav>`：用于包含页面导航链接。

- `<main>`：用于包含页面的主要内容。

  

**完整的最小示例**

一个包含所有这些基础元素的最小HTML页面可能看起来像这样：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Page Title</title>
  </head>
  <body>
    <!-- your content goes here -->
  </body>
</html>
```



### 版本区别

| 版本      | 发布年份 | 主要特点与功能                                               |
| --------- | -------- | ------------------------------------------------------------ |
| HTML 2.0  | 1995     | - 基础的 HTML 结构和标签<br>- 包括标题、段落、列表和链接等基本元素 |
| HTML 3.2  | 1997     | - 脚本支持（JavaScript）<br>- 样式表（CSS）<br>- 增加了表格和对齐选项 |
| HTML 4.0  | 1997     | - 更多的 CSS 支持<br>- 丰富的表单控制<br>- 文档元数据和链接关系的元素 |
| HTML 4.01 | 1999     | - HTML 4.0 的修订版<br>- 解决了一些错误和进行了微小的更新    |
| XHTML 1.0 | 2000     | - 以 XML 格式编写<br>- 更严格的语法要求（如标签必须小写、必须关闭等） |
| XHTML 1.1 | 2001     | - 基于 XHTML 1.0 的改进<br>- 模块化结构                      |
| HTML5     | 2014     | - 语义化元素（如 `<header>`、`<footer>` 等）<br>- 多媒体支持（`<audio>`、`<video>`）<br>- 新的 API |
| HTML 5.1  | 2016     | - 细化和扩展了 HTML5 的特性<br>- 添加了新的布局和表单选项    |
| HTML 5.2  | 2017     | - 增加和修改了 HTML5.1 的特性<br>- 引入了新的 API 和安全特性 |



### iframe

'<iframe> '是一个 HTML 标签，用于在当前 HTML 文档中嵌入另一个 HTML 页面。这个内嵌的 HTML 页面有自己独立的 DOM、CSS 和 JavaScript 上下文环境。<iframe> 在许多应用场景中都非常有用，例如嵌入第三方应用、视频、地图或其他多媒体内容。.

**基础语法**

基础的 `<iframe>` 元素大致如下：

```

<iframe src="https://example.com" width="600" height="400"></iframe>
```

- `src`: 指定要嵌入的页面的 URL。
- `width` 和 `height`: 指定 `<iframe>` 的宽度和高度。

**主要属性**

除了 `src`、`width` 和 `height` 外，`<iframe>` 还有其他一些重要的属性：

- `sandbox`: 用于增加安全性，可以限制内嵌页面的一些行为。
- `frameborder`: 指定是否显示边框（在 HTML5 中，建议使用 CSS 来设置这个选项）。
- `scrolling`: 指定是否显示滚动条。
- `name`: `<iframe>` 的名称，用于脚本和链接。

**安全性和限制**

虽然 `<iframe>` 很有用，但也存在一些安全风险，例如点击劫持（Clickjacking）。因此，许多现代浏览器都提供了一些安全性措施：

- 同源策略（Same-Origin Policy）：默认情况下，嵌入的内容不能访问父页面的 DOM。
- `X-Frame-Options` HTTP 头：网站可以使用这个选项来阻止其内容被嵌入到 `<iframe>` 中。

**应用场景**

1. **嵌入第三方应用**: 如社交媒体插件或支付网关。
2. **多媒体内容**: 例如 YouTube 视频。
3. **网站内导航**: 在一个页面内展示另一个子页面。
4. **广告**: 嵌入外部广告内容。



### 页面的加载和渲染过程

![image-20231019131744151](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231019131744151.png)



## 异步编程

### async

`defer` 和 `async` 都是与异步编程和并发有关的概念。

`defer`

1. **JavaScript 中的 `defer`**: 在 HTML 和 JavaScript 中，`defer` 是一个属性，通常与 `<script>` 标签一起使用。它告诉浏览器先解析完文档再执行脚本。

   ```
   <script defer src="script.js"></script>
   ```

`async`

1. **JavaScript 的 `async/await`**: 在 JavaScript 中，`async` 用来声明一个函数是异步的，意味着它返回一个 `Promise`。`await` 关键字用于等待这个 `Promise` 完成。

   ```
   async function fetchData() {
       const response = await fetch('https://api.example.com/data');
       const data = await response.json();
       return data;
   }
   ```

   在这个例子中，`fetchData` 函数是一个异步函数，内部有两个 `await` 表达式用于等待异步操作完成。

2. **Python 的 `async/await`**: Python 的 `asyncio` 库也使用 `async` 和 `await` 关键字，与 JavaScript 的用法类似但适用于 Python 的异步编程模型。

   ```
   import asyncio
   
   async def main():
       await asyncio.sleep(1)
       print("Hello, World!")
   
   asyncio.run(main())
   ```

3. **其他语言**: 在其他编程语言中，`async` 关键字或者类似的概念也可能存在，通常用于声明一个函数或操作是异步的。

总结，`defer` 主要用于确保某些操作在函数退出时执行，用于资源管理和清理。而 `async` 主要用于异步编程，使得你能够更容易地编写非阻塞代码。





### DOCTYPE

`<!DOCTYPE>`（Document Type Declaration）是一种用于 HTML 文档中的指令，它告诉浏览器该文档使用哪种 HTML 规范（或“文档类型”）编写。这有助于浏览器准确地解析和渲染文档。它通常放置在 HTML 文档的第一行，位于 `<html>` 标签之前。

```
<!DOCTYPE html>
<html>
  <!-- 其他内容 -->
</html>
```

**作用和意义**

1. **标准模式与怪异模式**：`<!DOCTYPE>` 的存在或缺失，以及它的具体类型，会影响浏览器是以“标准模式”（Standards Mode）还是“怪异模式”（Quirks Mode）来渲染页面。标准模式更接近 W3C 的规范，而怪异模式会兼容一些过时的布局规则。
2. **版本指示**：在早期的 HTML 和 XHTML 版本中，`<!DOCTYPE>` 用于指定文档符合哪个 HTML/XHTML 规范。例如，HTML 4.01、XHTML 1.0 等。
3. **解析准确性**：正确的 `<!DOCTYPE>` 有助于防止浏览器对标记进行错误的解析。

**常见类型**

- **HTML5**：在现代网页中最常见，简单并推荐使用。

  ```
  
  <!DOCTYPE html>
  ```

- **HTML 4.01 Strict、Transitional 和 Frameset**

  ```
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
  ```

- **XHTML**：虽然现在用得少，但在一些旧项目中可能还会见到。

  ```
  
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  ```





### href、src区别

在HTML（HyperText Markup Language）中，`href` 和 `src` 是两个用于建立链接的常用属性，但它们有几个关键区别。

#### `href` (HyperText Reference)

- **用途**：`href` 属性用于在HTML元素（通常是`<a>`，`<link>`，或`<base>`标签）中定义一个链接的目标URL。

  ```
  
  <a href="https://www.example.com">Visit Example.com</a>
  ```

- **行为**：`href` 创建的是一个引用或者连接到其他资源的链接，但不会嵌入内容。

- **适用元素**：主要用于 `<a>`、`<link>`、`<base>` 等标签。

- **关联资源**：用于关联文档、样式表、网址等。

#### `src` (Source)

- **用途**：`src` 属性用于嵌入外部资源，通常是图像、视频、脚本等。

  ```
  
  <img src="image.jpg" alt="An example image">
  ```

- **行为**：与`href` 不同，`src` 用于嵌入内容，这意味着外部资源会成为文档的一部分。

- **适用元素**：主要用于 `<img>`、`<script>`、`<iframe>`、`<audio>`、`<video>` 等标签。

- **关联资源**：用于嵌入图像、脚本、视频、音频等。

#### **区别**

1. **用途不同**：`href` 用于建立到其他页面或资源的链接，而 `src` 用于嵌入内容。

2. **行为不同**：`href` 只是建立一个到其他页面或文件的链接，而不会将其作为当前页面的一部分。而 `src` 实际上会将外部资源嵌入到当前文档中。

3. **适用元素不同**：`href` 主要用于 `a`, `link`, `base` 等元素，而 `src` 主要用于 `img`, `script`, `iframe` 等。

4. **浏览器处理方式不同**：使用 `href` 的时候，浏览器会识别该资源为当前文档的一部分，但不会阻止文档的加载；而使用 `src` 的时候，浏览器会暂停文档的加载，直到外部资源被加载和执行（例如脚本）。

   

### 同源策略

同源策略（Same-Origin Policy）是一种在网页脚本计算中实施的安全措施，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

两个URL要被认为是“同源”，必须满足以下三个条件：

1. **协议相同**：例如，都是HTTP或都是HTTPS。
2. **域名相同**：例如，都是www.example.com。
3. **端口相同**：例如，都是80端口或都是443端口。

只有当这三个条件都满足时，两个URL才被认为是“同源”。



**解决同源问题（Same-Origin Policy issues）**

1. **服务器端解决方案**

**CORS（跨源资源共享）**：最直接的解决方案是在服务器端设置HTTP头部，以允许特定的跨源请求。

```

Access-Control-Allow-Origin: *
```

或者只允许特定域：

```

Access-Control-Allow-Origin: https://www.example.com
```

**代理服务器**：使用一个后端服务器作为代理，转发来自前端的请求到目标服务器，并返回响应。因为前端和代理服务器是同源的，所以这样可以绕过同源限制。



2. **客户端解决方案**

**Document.domain**：当两个页面有相同的主域（但不同子域）时，可以通过设置 `document.domain = "example.com"` 来实现它们之间的通信。

**Window.postMessage**：这是一个用于安全跨源通信的HTML5 API。源可以发送消息，并在接收端对消息和源进行验证。

**WebSocket**：WebSocket协议不受同源策略的限制，因此可以用于跨域通信。但服务器必须支持WebSocket连接。



### `window` 对象

`window` 对象在浏览器环境中是一个非常重要和常用的对象。它代表了浏览器窗口，并包含了许多用于与浏览器窗口和其内部的文档互动的属性和方法。

**基础知识**

- `window` 对象是JavaScript在浏览器环境中的全局对象。这意味着在浏览器环境中，全局变量和函数都是 `window` 对象的属性和方法。
- `window` 对象同时也是文档对象模型（DOM）的入口点，你可以通过 `window.document` 访问到 `document` 对象。

**重要的属性和方法**

1. **DOM 操作**：`window.document` 允许你访问和操作DOM。
2. **定时器**：`setTimeout()` 和 `setInterval()` 用于执行延迟和定时操作。
3. **浏览器信息**：`navigator` 和 `location` 对象提供了关于浏览器和当前URL的信息。
4. **窗口控制**：`open()`, `close()`, `moveTo()`, `resizeTo()` 等方法用于控制浏览器窗口。
5. **会话和本地存储**：`localStorage` 和 `sessionStorage` 属性用于在浏览器中存储键值对。
6. **跨文档通信**：`postMessage()` 方法用于安全地实现跨源通信。

**示例**

1. 获取窗口尺寸

   ```js
   const width = window.innerWidth;
   const height = window.innerHeight;
   ```

2. 操作 DOM

   ```js
   const title = window.document.title;
   window.document.body.appendChild(someElement);
   ```

3. 使用定时器

   ```js
   window.setTimeout(function() {
     console.log("Hello, world!");
   }, 3000);
   ```



# JavaScript

### 冒泡机制（Event Bubbling）

冒泡机制是DOM（文档对象模型）事件传播的一种方式。当一个元素上的事件被触发时，该事件不仅仅会作用于这个元素，还会“冒泡”到这个元素的父元素，再到父元素的父元素，依此类推，直到达到`document`对象。这样做的一个主要好处是，你可以在一个共同的父元素上设置一个事件监听器，用于处理多个子元素的事件，这被称为事件委托。

```
<div id="parent">
  <button id="child">Click me!</button>
</div>

document.getElementById("parent").addEventListener("click", function() {
  alert("Parent Div Clicked!");
});

document.getElementById("child").addEventListener("click", function() {
  alert("Button Clicked!");
});
```

在这个例子中，如果你点击了按钮（即 "Button Clicked!"），你也会看到 "Parent Div Clicked!" 的弹窗。这是因为事件从按钮开始，然后冒泡到其父元素，也就是`div`元素。



### null、NaN 和 undefined

#### `null`

- **语义**：`null` 表示“没有值”或“空”。当你想明确地表示某个变量没有值时，可以使用 `null`。

- **用途**：经常用于初始化变量，表示该变量尚未引用任何对象或值。也常用于对象属性或数组中表示空的槽。

- **类型**：虽然 `typeof null` 会返回 `"object"`，但这其实是JavaScript中的一个历史错误。

  ```
  let a = null;
  typeof a; // "object"（历史错误）
  ```

使用 instanceof：null instanceof Object 返回 false。

#### `NaN` (Not-a-Number)

- **语义**：`NaN` 用于表示一个不能表示为合法数字的值。通常是在数学运算失败时出现，如将字符串减去数字。

- **用途**：用于表示数学运算的错误结果而不是抛出异常。JavaScript提供了 `isNaN()` 函数来检查一个值是否是 `NaN`。

- **类型**：它是一个特殊的 `Number` 类型。

  ```
  let a = "text" / 3;
  isNaN(a); // true
  typeof a; // "number"
  ```

- **特殊性**：`NaN` 是唯一一个不等于自己的值。

  ```
  
  NaN === NaN; // false
  ```

- 使用 `instanceof`：`NaN instanceof Number` 返回 `false`，因为 `NaN` 是 `Number` 类型的一个特殊值，但它不是 `Number` 对象的实例。

#### `undefined`

- **语义**：当一个变量被声明但没有被赋值时，其默认值为 `undefined`。它表示“未定义”或“不存在”。

- **用途**：常用于检查变量是否已赋值或对象属性或数组元素是否存在。

- **类型**：`typeof undefined` 会返回 `"undefined"`。

  ```
  let a;
  typeof a; // "undefined"
  ```

- 使用 `instanceof`：由于 `undefined` 不是一个对象，所以 `undefined instanceof AnyConstructor` 总是返回 `false`。

- **与 `null` 的区别**：`null` 是一个表示“无”的对象，`undefined` 表示一个**变量没有被初始化**。

**比较**

- `null == undefined` 返回 `true`，因为 `==` 运算符会进行类型转换。
- `null === undefined` 返回 `false`，因为 `===` 运算符（全等运算符）要求类型和值都相同。

```
null == undefined  // true
null === undefined // false
```



### ===，==

**JavaScript**

- `==`：**宽松相等运算符**。这意味着它在比较时会进行**类型转换**。例如，字符串 `'5'` 和数字 `5` 会被认为是相等的。

  ```
  '5' == 5  // true
  null == undefined  // true
  ```

- `===`：**严格相等运算符**。这意味着不进行任何类型转换，所以类型和值都必须相等。

  ```
  '5' === 5  // false
  null === undefined  // false
  ```

**Java**

- `==`：在Java中，这个操作符用于**基本数据类型（如 `int`、`char` 等）的值比较和引用类型（如对象）的引用比较**。对于对象，`==` 比较的是两个引用**是否指向内存中的同一个对象实例**。

  ```
  int a = 5;
  int b = 5;
  a == b  // true
  
  String str1 = new String("hello");
  String str2 = new String("hello");
  str1 == str2  // false
  ```

- `equals()`：Java中通常使用 `equals()` 方法来比较**两个对象的内容是否相等**。这是一个可以在任何对象上调用的方法，并且可以根据需要重写。

  ```
  
  str1.equals(str2)  // true, assuming equals() is properly overridden
  ```

  

**Python**

- `==`：在Python中，这个操作符用于**比较两个对象的值是否相等**。不同类型的对象也可以被认为是相等的，只要它们的值是相等的（这取决于该类型如何实现 `__eq__()` 方法）。

  ```
  5 == 5  // true
  '5' == 5  // false
  ```

- `is`：Python中的 `is` 运算符用于比较两个对象是**否是同一个对象**（即比较它们的内存地址）。这类似于Java中的 `==` 运算符在对象上的行为。

  ```
  a = [1, 2, 3]
  b = [1, 2, 3]
  a == b  // true
  a is b  // false
  ```

总结一下，不同语言中的 `==` 和 `===`（或类似的操作符和方法）有各自的行为和用途。在JavaScript中，`==` 和 `===` 主要是用来进行值的比较，其中 `===` 是严格相等运算符，需要类型也相同。在Java中，`==` 可用于基本数据类型的值比较和对象引用的比较，而 `equals()` 用于比较对象的内容。在Python中，`==` 用于值比较，`is` 用于引用比较。



### 类型转换

JavaScript是一种**弱类型语言**

#### 隐式类型转换（Coercion）

当运算符在操作不同类型的变量时，JavaScript会自动转换其中一个类型，以完成操作。这就是所谓的隐式类型转换。

- **字符串拼接**：当你尝试拼接字符串和非字符串时，非字符串会被转换为其字符串表示形式。

  ```
  
  "Hello, " + 42  // "Hello, 42"
  ```

- **数学运算**：在加减乘除等运算中，非数字通常会被转换为数字。

  ```
  "5" - 1  // 4
  "5" + 1  // "51" (注意：加法运算符会触发字符串拼接)
  ```

- **比较运算**：使用 `==` 运算符进行比较时，JavaScript会尝试转换操作数的类型。

  ```
  
  "5" == 5  // true
  ```

- **逻辑运算**：在逻辑表达式（如 `if` 语句）中，某些值会被转换为其布尔表示形式。

  ```
  
  if ("string") { /* 这个块会执行，因为非空字符串为真 */ }
  ```



#### 显式类型转换

除了隐式类型转换外，你也可以明确地转换变量的类型。

- **使用 `String()`，`Number()` 和 `Boolean()` 函数**

  ```
  String(42)  // "42"
  Number("42")  // 42
  Boolean(0)  // false
  ```

- **使用 `parseInt()` 和 `parseFloat()`**

  ```
  parseInt("42px")  // 42
  parseFloat("42.2em")  // 42.2
  ```

- **使用一元 `+` 和 `-` 运算符进行数值转换**

  ```
  +"42"  // 42
  -"42"  // -42
  ```

- **使用 `!!` 运算符进行布尔转换**

  ```
  !!42  // true
  !!0  // false
  ```

- **使用 `.toString()` 方法转为字符串**

  ```
  
  (42).toString()  // "42"
  ```



**特殊情况**

- `null` 和 `undefined` 在数学运算和比较运算中有特殊的转换规则。

  ```
  null + 1  // 1
  undefined + 1  // NaN
  ```

- `NaN`（Not-a-Number）是一个特殊的数值，**任何涉及 `NaN` 的数学运算都将返回 `NaN`。**

  ```
  NaN + 1  // NaN
  ```

- 对象、数组和函数在转换时会有特殊的行为。

  ```
  [1, 2, 3] + 4  // "1,2,34"
  ```



### 事件（Events）

在JavaScript中，事件是浏览器或用户自身执行的某种动作，如点击、加载、鼠标移动等。你可以使用 `addEventListener` 方法来监听一个特定元素上的事件，并指定当该事件触发时运行的函数。

```
document.getElementById("myBtn").addEventListener("click", function() {
  alert("Button clicked!");
});
```