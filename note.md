

# ACM模式

https://www.programmercarl.com/qita/acm.html



# 二分法

二分算法（Binary Search Algorithm），比较集合中间元素与目标元素，根据比较结果来消除一半的搜索空间。

1. **初始化指针**: 设定两个指针，`low` 和 `high`，分别指向集合的首尾。
2. **计算中点**: 在循环内，计算 `mid = (low + high) // 2`。
3. **比较**: 比较集合中间点 mid 的元素与目标元素。
   - 如果 `mid` 元素等于目标，搜索成功，返回 `mid` 的索引。
   - 如果 `mid` 元素小于目标，更新 `low = mid + 1`。
   - 如果 `mid` 元素大于目标，更新 `high = mid - 1`。
4. **重复**: 继续步骤2和3，直到 `low <= high` 不成立，或找到目标元素。

### 时间复杂度

- 最好情况*O*(1)（目标元素就在集合的中间位置）
- 平均和最坏情况：O(logn)



### 相关问题

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)



# 动态规划





## 相关题目

[46. 全排列](https://leetcode.cn/problems/permutations/)

[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 只用返回一个数字会比较适合dp解法，在这个题中是将球最大的数组和简化为在当前的index上，最大和为多少

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

# 分治法





# 递归



## Memoization

在递归算法中使用`memo`字典来保存已经计算过的子问题的解的技术被称为“记忆化”（Memoization）。这是一种优化技术，用于通过存储昂贵的函数调用结果来避免重复计算，从而提高算法的运行速度。

记忆化是动态规划（Dynamic Programming, DP）中的一个常用手法。事实上，很多时候动态规划问题首先可以通过一个朴素的、没有优化的递归算法来解决。然后，通过添加记忆化，我们可以显著提高其效率。

简而言之，记忆化是一种特定类型的缓存策略，用于提高递归算法或者动态规划算法的效率。它通过保存已经解决的子问题的结果来避免重复工作。

Example:

```python
class Solution:
    def numTrees(self, n: int) -> int:
        if n==0:
            return 0
        if n==1:
            return 1
        
        def DFS(l,r):
            if l>=r:
                return 1
            res = 0
            for i in range(l,r+1):
                res += DFS(l,i-1)*DFS(i+1,r)
            return res
        
        return DFS(1,n)
```

```python
class Solution:
    def numTrees(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1

        # 创建一个字典（或者数组）来存储已经计算过的值
        memo = {}

        def DFS(l, r):
            if l >= r:
                return 1

            # 检查是否已经计算过这个值
            if (l, r) in memo:
                return memo[(l, r)]

            res = 0
            for i in range(l, r+1):
                res += DFS(l, i-1)*DFS(i+1, r)
                # 将计算过的值存储在字典中
            memo[(l, r)] = res
            return res

        return DFS(1, n)
```

使用memo（记忆化）的核心思想是保存已经计算过的子问题的解，以便在将来需要时可以直接使用，从而避免重复计算。这在递归算法中尤其有效，因为递归算法往往会多次计算相同的子问题。



考虑numTrees(19)这个例子，它需要计算的子问题涉及的范围是[1, 19]。这样的子问题数量本身就是非常多的。如果没有记忆化，那么相同的子问题（同样的(l, r)值对）会被多次重新计算，导致大量的时间浪费。



例如，考虑子问题DFS(1, 18)和DFS(2, 19)。两者都需要计算DFS(2, 18)作为其子问题之一。在没有记忆化的情况下，DFS(2, 18)会被重新计算两次，而使用记忆化后，DFS(2, 18)只会被计算一次，其结果会被保存起来供以后使用。



这样的重复子问题在整个计算过程中会出现非常多次。通过记忆化，我们可以大大减少这些重复计算，从而显著提高算法效率。



记忆化通常能将时间复杂度从指数级（或更高）降低到多项式级。在这个具体的例子中，记忆化能够将算法的时间复杂度降低到O(n^2)（这里 n=19），这对于n=19来说是完全可接受的。



所以，使用memo字典节省了大量时间，使得即使对于较大的n值（如19），算法也能在合理的时间内运行完成。



## 经典问题

阶乘问题

二叉树深度

汉诺塔问题

斐波那契数列

快速排序、归并排序、分治算法



https://zhuanlan.zhihu.com/p/338302261



## 相关题目

致力于构建和优化四种不同类型的情感分类器，包括两个传统的机器学习模型（朴素贝叶斯和支持向量机）和两个神经网络模型（LSTM和GRU）。项目开始于对Semeval 2017提供的数据集进行初步分析，识别出类别不平衡等问题，并对数据进行了一系列预处理步骤，如文本清洗和词形还原。
继续开发了用于特征提取的多种方法，包括TF-IDF和词嵌入，以及尝试了各种不同的优化算法，如Adam和SGD。在模型训练阶段，利用交叉验证和网格搜索来调整超参数，并使用了不同的评估指标，如准确率和F1分数，来比较四种模型的性能。

朴素贝叶斯和支持向量机在一些基线测试中表现出色，但在处理更复杂的情感模式时遇到了局限性。与此同时，LSTM和GRU神经网络模型展示了更高的准确性和灵活性，尤其是在捕捉文本中长距离依赖关系方面。

经过多轮实验和调优，最终选择了GRU模型作为最优解，该模型在测试集上达到了最高的F1分数。



# 排序问题



## 冒泡排序

[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)



# 回溯算法和DFS

回溯算法是一种用于找到所有（或某些）可能解决方案的算法，特别是在涉及约束满足问题（Constraint Satisfaction Problems，CSP）的情况下。回溯算法的核心思想是从问题的可能解决方案的空间树中，按照深度优先搜索（DFS）的策略，从根节点出发遍历解空间树。

**深度优先搜索算法（Depth First Search，简称DFS）**：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将**回溯**到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。

1. 为了求得问题的解，先选择某一种可能情况向前探索；
2. 在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索；
3. 如此反复进行，直至得到解或证明无解。

### 算法步骤

1. **初始状态**：一般来说，所有的节点都是未访问状态。
2. **选择起点**：选择一个起点作为当前节点。
3. **标记当前节点**：将当前节点标记为已访问。
4. **检查邻接点**：
   - 查找当前节点的所有未访问的邻接点。
   - 如果当前节点存在未访问的邻接点，则选择其中一个，作为当前节点，并回到步骤3。
   - 如果当前节点没有未访问的邻接点，则回溯到上一个节点，并将其设置为当前节点。
5. **终止条件**：
   - 所有可访问的节点都已访问。
   - 找到目标节点（如果有）。
   - 手动终止。

### 应用场景

- 图遍历
- 路径搜索
- 拓扑排序
- 迷宫（或格网）问题
- 组合问题（如 N-皇后问题）

## 相关题目

[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

# 数据结构

## 链表

### 相关题目

[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

[86. 分隔链表](https://leetcode.cn/problems/partition-list/)





# 面试题目

## 合并有序数组

### 方法1：双指针法

1. 使用两个指针分别遍历两个有序数组。
2. 比较两个指针指向的元素，将较小的元素添加到结果数组中，并将对应的指针向前移动。
3. 如果一个数组遍历完了，将另一个数组剩余的元素添加到结果数组中。

