# HTML

- HTML 指的是超文本标记语言: **H**yper**T**ext **M**arkup **L**anguage
- HTML 不是一种编程语言，而是一种**标记**语言
- 标记语言是一套**标记标签** (markup tag)
- HTML 使用标记标签来**描述**网页
- HTML 文档包含了HTML **标签**及**文本**内容
- HTML文档也叫做 **web 页面**

### HTML 标签

HTML 标记标签通常被称为 HTML 标签 (HTML tag)。

- HTML 标签是由*尖括号*包围的关键词，比如 <html>
- HTML 标签通常是*成对出现*的，比如 <b> 和 </b>
- 标签对中的第一个标签是*开始标签*，第二个标签是*结束标签*
- 开始和结束标签也被称为*开放标签*和*闭合标签*

### 基础的HTML页面元素-网页结构

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027132644213.png" alt="image-20231027132644213" style="zoom:67%;" />

<img src="https://www.runoob.com/wp-content/uploads/2013/06/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="img" style="zoom: 50%;" />

在构成一个基础的HTML页面中，有几个必要或者说基础的元素，这些元素构成了HTML页面的骨架。下面是这些基础元素的简要概述：

#### DOCTYPE

`<!DOCTYPE html>`

这不是一个HTML标签，但它告诉浏览器你正在使用的是HTML5。这应该是你HTML文件的第一行。

```
<!DOCTYPE html>
```

`<!DOCTYPE>`（Document Type Declaration）是一种用于 HTML 文档中的指令，它告诉浏览器该文档使用哪种 HTML 规范（或“文档类型”）编写。这有助于浏览器准确地解析和渲染文档。它通常放置在 HTML 文档的第一行，位于 `<html>` 标签之前。

**作用和意义**

1. **标准模式与怪异模式**：`<!DOCTYPE>` 的存在或缺失，以及它的具体类型，会影响浏览器是以“标准模式”（Standards Mode）还是“怪异模式”（Quirks Mode）来渲染页面。标准模式更接近 W3C 的规范，而怪异模式会兼容一些过时的布局规则。
2. **版本指示**：在早期的 HTML 和 XHTML 版本中，`<!DOCTYPE>` 用于指定文档符合哪个 HTML/XHTML 规范。例如，HTML 4.01、XHTML 1.0 等。
3. **解析准确性**：正确的 `<!DOCTYPE>` 有助于防止浏览器对标记进行错误的解析。

**常见类型**

- **HTML5**：在现代网页中最常见，简单并推荐使用。

  ```
  <!DOCTYPE html>
  ```

- **HTML 4.01 Strict、Transitional 和 Frameset**

  ```
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
  ```

- **XHTML**：虽然现在用得少，但在一些旧项目中可能还会见到。

  ```
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  ```

doctype 声明是不区分大小写的。



#### `<html>`

这个元素是所有其他HTML元素的容器。它通常包含两个子元素：`<head>` 和 `<body>`。

```
<html>
  <!-- head and body go here -->
</html>
```

`<head>`

这个元素包含了关于文档的元数据（metadata），这些信息不会显示在页面内容中。常见的子元素有 `<title>`、`<meta>`、`<link>`、`<script>` 等。

```
<head>
  <title>Page Title</title>
</head>
```

`<title>`

这个元素定义了浏览器窗口的标题或者页面在搜索引擎结果中的标题。它是 `<head>` 区域的一个重要组成部分。

```

<title>This is the page title</title>
```

`<meta>`

元数据标签用于提供有关页面的各种信息，如字符集、作者、描述等。

```
<meta charset="UTF-8">
<meta name="description" content="This is a description">
```

`<body>`

这个元素包含了所有要显示给用户的内容，包括文本、图像、视频、游戏、可播放轨迹、等等。

```
<body>
  <!-- your content goes here -->
</body>
```



**其他可选但常用的元素**

虽然下面的元素不是严格“必要”的，但它们经常出现在实际页面中：

- `<header>`：用于包含页面或区域的标题和其他信息。

- `<footer>`：用于包含页面或区域的页脚信息。

- `<nav>`：用于包含页面导航链接。

- `<main>`：用于包含页面的主要内容。

  

**完整的最小示例**

一个包含所有这些基础元素的最小HTML页面可能看起来像这样：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Page Title</title>
  </head>
  <body>
    <!-- your content goes here -->
  </body>
</html>
```



### 行内元素（Inline Elements）和块级元素（Block-level Elements）



#### 块级元素（Block-level Elements）

**特点：**

1. **占据整行**: 块级元素在页面上占据新的一行，前后会有换行符。
2. **宽度默认为父元素的100%**: 除非你设置了它们的宽度。
3. **高度自动**: 默认情况下，高度是由它们包含的内容来决定的。
4. **可嵌套**: 可以嵌套行内元素和其他块级元素。
5. **外边距和内边距（Margin 和 Padding）**: 可以设置上下左右的外边距和内边距。

**常见的块级元素：**

- `<div>`
- `<h1>, <h2>, ..., <h6>`
- `<p>`
- `<ul>, <ol>, <li>`
- `<form>`
- `<header>, <footer>, <section>, <article>`
- `<table>`

#### 行内元素（Inline Elements）

**特点：**

1. **不独占一行**: 它们可以与其他行内元素或文本在同一行内显示。
2. **宽度和高度**: 由内容决定，不能手动设置。
3. **无法嵌套块级元素**: 通常只能嵌套文本或其他行内元素。
4. **外边距和内边距**: 只能设置左右的外边距和内边距，上下的无效。

**常见的行内元素：**

- `<span>`

- `<a>`

- `<img>`（注意：虽然是行内元素，但 `<img>` 的宽度和高度是可以设置的）

- `<button>`

- `<input>`

- `<label>`

- `<strong>, <em>, <b>, <i>`

  

**可以通过 CSS 进行转换**

通过设置`display`属性为`inline`或`block`，你可以改变元素的类型。

```
/* 把 div 转为行内元素 */
div {
  display: inline;
}

/* 把 span 转为块级元素 */
span {
  display: block;
}
```

#### 空元素



空元素（Empty Elements）是HTML中一类特殊的元素，它们没有内容和闭合标签。这意味着它们由单一的标签组成，该标签中可能包含属性，但没有开始和结束之间的文本或其他元素。这类元素也被称为自闭合元素（Self-closing Elements）。

**常见的空元素：**

- `<img>`：用于嵌入图像。
- `<br>`：插入一个换行。
- `<hr>`：创建一个水平线。
- `<input>`：用于表单的输入字段。
- `<meta>`：提供有关网页的元信息。
- `<link>`：用于链接外部资源，通常用于链接CSS文件。
- `<area>`：在图像映射中定义一个区域。
- `<base>`：定义页面中所有相对URL的基础URL。
- `<col>`：定义`<colgroup>`元素内的一列属性。
- `<source>`：用于`<video>`和`<audio>`元素，以提供媒体资源。
- `<wbr>`：建议浏览器在此位置添加换行（如果需要）。
- `<command>`：表示用户可以调用的命令。
- `<keygen>`：用于生成一个密钥对控件（现已废弃）。
- `<param>`：为`<object>`元素定义参数。

**语法注意点：**

在HTML5中，空元素的标签不需要尾随的斜线（`/`），尽管在XHTML或更严格的XML结构中可能需要这样做。

```
<!-- HTML5中有效的空元素标记 -->
<img src="image.jpg" alt="An image">
<br>
<hr>

<!-- XHTML中，可能需要添加尾随的斜线 -->
<img src="image.jpg" alt="An image" />
<br />
<hr />
```



### HTML 属性

- HTML 元素可以设置**属性**
- 属性可以在元素中添加**附加信息**
- 属性一般描述于**开始标签**
- 属性总是以名称/值对的形式出现，**比如：name="value"**。



#### 常见的全局属性（Global Attributes）

全局属性是可以应用于所有 HTML 元素的属性。

- `class`: 用于为元素指定一个或多个类名，通常用于 CSS 样式或 JavaScript。
- `id`: 用于为元素指定一个唯一的标识符。
- `style`: 用于内联 CSS 样式。
- `title`: 用于给元素添加额外的信息，通常会在鼠标悬停时显示。
- `data-*`: 自定义数据属性，用于存储额外的信息。
- `lang`: 用于定义元素的语言。
- `dir`: 用于定义文本方向，如 `"ltr"`（从左到右）或 `"rtl"`（从右到左）。



#### 特定元素的属性

某些属性仅适用于特定的 HTML 元素。

`<a>` 元素

- `href`: 超链接引用，定义链接的目标 URL。
- `target`: 定义如何打开链接，比如 `_blank` 会在新窗口中打开。

`<img>` 元素

- `src`: 图像源 URL。
- `alt`: 替换文本，用于在图像无法显示时提供信息。
- `width` 和 `height`: 定义图像的尺寸。

`<table>` 元素

- `rowspan`: 定义单元格在垂直方向上跨越的行数。
- `colspan`: 定义单元格在水平方向上跨越的列数。

`<form>` 元素

- `action`: 提交表单数据到该 URL。
- `method`: 定义数据提交的 HTTP 方法（`GET` 或 `POST`）。

`<input>` 元素

- `type`: 定义输入字段的类型（如 `text`, `password`, `checkbox` 等）。

- `name`: 定义输入字段的名称。

- `value`: 定义输入字段的初始值。

- `placeholder`: 定义输入字段的占位符文本。

  > **文本类型**
  >
  > - `text`: 普通的单行文本输入。
  > - `password`: 用于密码，输入的文本会被遮住。
  > - `search`: 用于搜索字段。
  > - `tel`: 用于输入电话号码。
  >
  > **数字类型**
  >
  > - `number`: 用于输入数字，浏览器通常会提供一个微调控件（spinner control）。
  > - `range`: 用于输入一个范围内的数字，通常呈现为滑块。
  >
  > **日期和时间类型**
  >
  > - `date`: 用于选择日期，通常会显示一个日期选择控件。
  > - `time`: 用于选择时间。
  > - `datetime-local`: 用于选择日期和时间，没有时区信息。
  > - `month`: 用于选择月份和年份。
  > - `week`: 用于选择周和年份。
  >
  > **文件**
  >
  > - `file`: 用于文件上传。
  >
  > **选择**
  >
  > - `checkbox`: 复选框。
  > - `radio`: 单选按钮。
  > - `color`: 颜色选择器。
  >
  > **特殊类型**
  >
  > - `email`: 用于电子邮件地址，浏览器可能会进行格式验证。
  > - `url`: 用于网址，浏览器可能会进行格式验证。
  >
  > **按钮**
  >
  > - `button`: 一般的按钮，没有默认行为。
  > - `submit`: 提交按钮，会提交表单。
  > - `reset`: 重置按钮，会重置表单字段到初始值。
  >
  > **隐藏类型**
  >
  > - `hidden`: 用于存储不需要显示给用户的数据。
  >
  > **图像**
  >
  > - `image`: 定义图像形式的提交按钮。

`<ol>` 和 `<ul>` 元素

- `type`: 定义列表项（`<li>`）标记的类型。
- `start`: 定义有序列表（`<ol>`）的起始数字。



### 文本格式化

```
<em>强调文本</em><br>
<strong>加粗文本</strong><br>
<dfn>定义项目</dfn><br>
<code>一段电脑代码 print("Hello World")</code><br>
<samp>计算机样本</samp><br>
<kbd>键盘输入</kbd><br>
<var>变量</var>
```

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027135456858.png" alt="image-20231027135456858" style="zoom:67%;" />

### 链接

HTML 使用超级链接与网络上的另一个文档相连。

HTML中的链接是一种用于在不同网页之间导航的元素。

链接通常用于将一个网页与另一个网页或资源（如文档、图像、音频文件等）相关联。

链接允许用户在浏览网页时单击文本或图像来跳转到其他位置，从而实现网页之间的互联。

### href、src区别

在HTML（HyperText Markup Language）中，`href` 和 `src` 是两个用于建立链接的常用属性，但它们有几个关键区别。

#### `href` (HyperText Reference)

- **用途**：`href` 属性用于在HTML元素（通常是`<a>`，`<link>`，或`<base>`标签）中定义一个链接的目标URL。

  ```
  <a href="https://www.example.com">Visit Example.com</a>
  ```

- **行为**：`href` 创建的是一个引用或者连接到其他资源的链接，但不会嵌入内容。

- **适用元素**：主要用于 `<a>`、`<link>`、`<base>` 等标签。

- **关联资源**：用于关联文档、样式表、网址等。

#### `src` (Source)

- **用途**：`src` 属性用于嵌入外部资源，通常是图像、视频、脚本等。

  ```
  <img src="image.jpg" alt="An example image">
  ```

- **行为**：与`href` 不同，`src` 用于嵌入内容，这意味着外部资源会成为文档的一部分。

- **适用元素**：主要用于 `<img>`、`<script>`、`<iframe>`、`<audio>`、`<video>` 等标签。

- **关联资源**：用于嵌入图像、脚本、视频、音频等。

#### **区别**

1. **用途不同**：`href` 用于建立到其他页面或资源的链接，而 `src` 用于嵌入内容。
2. **行为不同**：`href` 只是建立一个到其他页面或文件的链接，而不会将其作为当前页面的一部分。而 `src` 实际上会将外部资源嵌入到当前文档中。
3. **适用元素不同**：`href` 主要用于 `a`, `link`, `base` 等元素，而 `src` 主要用于 `img`, `script`, `iframe` 等。
4. **浏览器处理方式不同**：使用 `href` 的时候，浏览器会识别该资源为当前文档的一部分，但不会阻止文档的加载；而使用 `src` 的时候，浏览器会暂停文档的加载，直到外部资源被加载和执行（例如脚本）。

### link，@import

**`<link>` 标签**

1. **HTML 层面引入**: `<link>` 是一个 HTML 标签，因此它是在 **HTML** 文件中定义的。

   ```
   
   <link rel="stylesheet" type="text/css" href="styles.css">
   ```

2. **更高的加载优先级**: 由于 `<link>` 是 HTML 的一部分，**浏览器会在解析 HTML 文档的同时立即下载并应用样式。**

3. **支持多种媒体类型**: 你可以通过 `media` 属性指定媒体查询，以确定何时使用该样式表。

   ```
   
   <link rel="stylesheet" type="text/css" href="print.css" media="print">
   ```

4. **DOM 可访问**: 由于 `<link>` 是 DOM 的一部分，你可以用 JavaScript 动态改变它的属性。

5. **并行下载**: 多个 `<link>` 标签的样式文件可以并行下载，不会阻塞页面渲染。

   

**`@import` 规则**

1. **CSS 层面引入**: `@import` 是在 **CSS** 文件中使用的，因此必须放在 CSS 文件或 `<style>` 标签中。

   ```
   
   @import url('styles.css');
   ```

2. **较低的加载优先级**: 由于 `@import` 是 CSS 的一部分，**浏览器必须首先加载并解析外部 CSS 文件，然后才会下载 `@import` 引入的文件。**

3. **支持媒体类型**: 跟 `<link>` 类似，你也可以在 `@import` 语句中指定媒体查询。

   ```
   
   @import url('print.css') print;
   ```

4. **不易于动态修改**: 虽然技术上可能，但用 JavaScript 动态改变 `@import` 规则相对更复杂。

5. **可能的串行下载**: 依赖于浏览器和网络状况，`@import` 引入的文件可能会串行下载，这可能会导致页面渲染的延迟。

**总结**

- `<link>` 更适用于生产环境，因为它允许并行下载，加载更快，而且更容易与 JavaScript 互动。
- `@import` 可能更适用于测试或开发环境，或者当你想将多个样式表组合成一个时。







### 版本区别

| 版本      | 发布年份 | 主要特点与功能                                               |
| --------- | -------- | ------------------------------------------------------------ |
| HTML 2.0  | 1995     | - 基础的 HTML 结构和标签<br>- 包括标题、段落、列表和链接等基本元素 |
| HTML 3.2  | 1997     | - 脚本支持（JavaScript）<br>- 样式表（CSS）<br>- 增加了表格和对齐选项 |
| HTML 4.0  | 1997     | - 更多的 CSS 支持<br>- 丰富的表单控制<br>- 文档元数据和链接关系的元素 |
| HTML 4.01 | 1999     | - HTML 4.0 的修订版<br>- 解决了一些错误和进行了微小的更新    |
| XHTML 1.0 | 2000     | - 以 XML 格式编写<br>- 更严格的语法要求（如标签必须小写、必须关闭等） |
| XHTML 1.1 | 2001     | - 基于 XHTML 1.0 的改进<br>- 模块化结构                      |
| HTML5     | 2014     | - 语义化元素（如 `<header>`、`<footer>` 等）<br>- 多媒体支持（`<audio>`、`<video>`）<br>- 新的 API |
| HTML 5.1  | 2016     | - 细化和扩展了 HTML5 的特性<br>- 添加了新的布局和表单选项    |
| HTML 5.2  | 2017     | - 增加和修改了 HTML5.1 的特性<br>- 引入了新的 API 和安全特性 |



### iframe

'<iframe> '是一个 HTML 标签，用于在当前 HTML 文档中嵌入另一个 HTML 页面。这个内嵌的 HTML 页面有自己独立的 DOM、CSS 和 JavaScript 上下文环境。<iframe> 在许多应用场景中都非常有用，例如嵌入第三方应用、视频、地图或其他多媒体内容。.

**基础语法**

基础的 `<iframe>` 元素大致如下：

```

<iframe src="https://example.com" width="600" height="400"></iframe>
```

- `src`: 指定要嵌入的页面的 URL。
- `width` 和 `height`: 指定 `<iframe>` 的宽度和高度。

**主要属性**

除了 `src`、`width` 和 `height` 外，`<iframe>` 还有其他一些重要的属性：

- `sandbox`: 用于增加安全性，可以限制内嵌页面的一些行为。
- `frameborder`: 指定是否显示边框（在 HTML5 中，建议使用 CSS 来设置这个选项）。
- `scrolling`: 指定是否显示滚动条。
- `name`: `<iframe>` 的名称，用于脚本和链接。

**安全性和限制**

虽然 `<iframe>` 很有用，但也存在一些安全风险，例如点击劫持（Clickjacking）。因此，许多现代浏览器都提供了一些安全性措施：

- 同源策略（Same-Origin Policy）：默认情况下，嵌入的内容不能访问父页面的 DOM。
- `X-Frame-Options` HTTP 头：网站可以使用这个选项来阻止其内容被嵌入到 `<iframe>` 中。

**应用场景**

1. **嵌入第三方应用**: 如社交媒体插件或支付网关。
2. **多媒体内容**: 例如 YouTube 视频。
3. **网站内导航**: 在一个页面内展示另一个子页面。
4. **广告**: 嵌入外部广告内容。



### 页面的加载和渲染过程

![image-20231019131744151](C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231019131744151.png)



## 异步编程

### async

`defer` 和 `async` 都是与异步编程和并发有关的概念。

`defer`

1. **JavaScript 中的 `defer`**: 在 HTML 和 JavaScript 中，`defer` 是一个属性，通常与 `<script>` 标签一起使用。它告诉浏览器先解析完文档再执行脚本。

   ```
   <script defer src="script.js"></script>
   ```

`async`

1. **JavaScript 的 `async/await`**: 在 JavaScript 中，`async` 用来声明一个函数是异步的，意味着它返回一个 `Promise`。`await` 关键字用于等待这个 `Promise` 完成。

   ```
   async function fetchData() {
       const response = await fetch('https://api.example.com/data');
       const data = await response.json();
       return data;
   }
   ```

   在这个例子中，`fetchData` 函数是一个异步函数，内部有两个 `await` 表达式用于等待异步操作完成。

2. **Python 的 `async/await`**: Python 的 `asyncio` 库也使用 `async` 和 `await` 关键字，与 JavaScript 的用法类似但适用于 Python 的异步编程模型。

   ```
   import asyncio
   
   async def main():
       await asyncio.sleep(1)
       print("Hello, World!")
   
   asyncio.run(main())
   ```

3. **其他语言**: 在其他编程语言中，`async` 关键字或者类似的概念也可能存在，通常用于声明一个函数或操作是异步的。

总结，`defer` 主要用于确保某些操作在函数退出时执行，用于资源管理和清理。而 `async` 主要用于异步编程，使得你能够更容易地编写非阻塞代码。





### 同源策略

同源策略（Same-Origin Policy）是一种在网页脚本计算中实施的安全措施，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

两个URL要被认为是“**同源**”，必须满足以下三个条件：

1. **协议相同**：例如，都是HTTP或都是HTTPS。
2. **域名相同**：例如，都是www.example.com。
3. **端口相同**：例如，都是80端口或都是443端口。

只有当这三个条件都满足时，两个URL才被认为是“同源”。



**解决同源问题（Same-Origin Policy issues）**

1. **服务器端解决方案**

**CORS（跨源资源共享）**：最直接的解决方案是在服务器端设置HTTP头部，以允许特定的跨源请求。

```

Access-Control-Allow-Origin: *
```

或者只允许特定域：

```

Access-Control-Allow-Origin: https://www.example.com
```

**代理服务器**：使用一个后端服务器作为代理，转发来自前端的请求到目标服务器，并返回响应。因为前端和代理服务器是同源的，所以这样可以绕过同源限制。



2. **客户端解决方案**

**Document.domain**：当两个页面有相同的主域（但不同子域）时，可以通过设置 `document.domain = "example.com"` 来实现它们之间的通信。

**Window.postMessage**：这是一个用于安全跨源通信的HTML5 API。源可以发送消息，并在接收端对消息和源进行验证。

**WebSocket**：WebSocket协议不受同源策略的限制，因此可以用于跨域通信。但服务器必须支持WebSocket连接。



### `window` 对象

`window` 对象在浏览器环境中是一个非常重要和常用的对象。它代表了浏览器窗口，并包含了许多用于与浏览器窗口和其内部的文档互动的属性和方法。

**基础知识**

- `window` 对象是JavaScript在浏览器环境中的全局对象。这意味着在浏览器环境中，全局变量和函数都是 `window` 对象的属性和方法。
- `window` 对象同时也是文档对象模型（DOM）的入口点，你可以通过 `window.document` 访问到 `document` 对象。

**重要的属性和方法**

1. **DOM 操作**：`window.document` 允许你访问和操作DOM。
2. **定时器**：`setTimeout()` 和 `setInterval()` 用于执行延迟和定时操作。
3. **浏览器信息**：`navigator` 和 `location` 对象提供了关于浏览器和当前URL的信息。
4. **窗口控制**：`open()`, `close()`, `moveTo()`, `resizeTo()` 等方法用于控制浏览器窗口。
5. **会话和本地存储**：`localStorage` 和 `sessionStorage` 属性用于在浏览器中存储键值对。
6. **跨文档通信**：`postMessage()` 方法用于安全地实现跨源通信。

**示例**

1. 获取窗口尺寸

   ```js
   const width = window.innerWidth;
   const height = window.innerHeight;
   ```

2. 操作 DOM

   ```js
   const title = window.document.title;
   window.document.body.appendChild(someElement);
   ```

3. 使用定时器

   ```js
   window.setTimeout(function() {
     console.log("Hello, world!");
   }, 3000);
   ```





### 常见图片格式

<img src="C:\Users\hongj\AppData\Roaming\Typora\typora-user-images\image-20231027132952563.png" alt="image-20231027132952563" style="zoom:50%;" />



# CSS

## 常见CSS选择器

在CSS中，选择器用于指定哪些HTML元素应该被样式化。以下是一些常见的CSS选择器：

- #### 基础选择器


1. **通用选择器（Universal Selector）**：
   
- 选择所有元素。语法：`* {}`
   
2. **元素/类型选择器（Element/Type Selector）**：
   - 选择所有特定类型的元素。语法：`elementname {}`
   - 例如：`div {}` 会选择所有的 `<div>` 元素。

3. **类选择器（Class Selector）**：
   - 选择具有特定类属性的所有元素。语法：`.classname {}`
   - 例如：`.my-class {}` 会选择所有带有 `class="my-class"` 的元素。

4. **ID选择器（ID Selector）**：
   - 选择具有特定ID的元素。语法：`#idname {}`
   - 例如：`#my-id {}` 会选择带有 `id="my-id"` 的元素。

5. **属性选择器（Attribute Selector）**：
   - 根据元素属性及其值来选择元素。语法：`[attribute="value"] {}`
   
   - 例如：`[type="text"] {}` 会选择所有 `type="text"` 的 `<input>` 元素。
   
     

- #### 组合选择器


1. **后代选择器（Descendant Selector）**：
   - 选择所有嵌套在指定元素内的特定元素。语法：`A B {}`
   - 例如：`div span {}` 会选择所有放在 `<div>` 元素内的 `<span>` 元素。

2. **子选择器（Child Selector）**：
   - 选择所有直接子元素。语法：`A > B {}`
   - 例如：`ul > li {}` 会选择所有作为 `<ul>` 直接子元素的 `<li>` 元素。

3. **相邻兄弟选择器（Adjacent Sibling Selector）**：
   - 选择所有紧跟在特定元素后的兄弟元素。语法：`A + B {}`
   - 例如：`h1 + p {}` 会选择所有直接跟在 `<h1>` 元素后的 `<p>` 元素。

4. **通用兄弟选择器（General Sibling Selector）**：
   - 选择所有同一父元素下特定元素之后的兄弟元素。语法：`A ~ B {}`
   
   - 例如：`h1 ~ p {}` 会选择所有同一父元素下且在 `<h1>` 元素之后的 `<p>` 元素。
   
     

- #### 伪类选择器


1. **链接伪类选择器（Link Pseudo-classes）**：
   - `:link` - 选择所有未访问的链接。
   - `:visited` - 选择所有已访问的链接。
   - `:hover` - 选择鼠标悬停其上的元素。
   - `:active` - 选择活动链接。
   - 例如：`a:hover {}` 在鼠标悬停时会改变链接样式。

2. **结构伪类选择器（Structural Pseudo-classes）**：
   - `:first-child` - 选择作为第一个子元素的元素。
   - `:last-child` - 选择作为最后一个子元素的元素。
   - `:nth-child(n)` - 选择作为第n个子元素的元素。

3. **输入伪类选择器（Input Pseudo-classes）**：
   - `:focus` - 选择获得焦点的输入元素。
   
   - `:disabled` - 选择被禁用的表单元素。
   
     

- #### 伪元素选择器


1. **`::before`**：
   - 在元素内容前插入内容。语法：`element::before {}`
   - 需要与 `content` 属性一起使用。

2. **`::after`**：
   - 在元素内容后插入内容。语法：`element::after {}`
   - 同样需要与 `content` 属性一起使用。

3. **

`::first-letter`**：
   - 选择元素的第一个字母。语法：`element::first-letter {}`

4. **`::first-line`**：
   - 选择元素的第一行。语法：`element::first-line {}`



- `!important`声明的样式的优先级最高
- 如果优先级一致，则最后出现的样式生效
- 继承得到的样式的优先级最低
- 样式来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式



### REACT和VUE中的CSS

- ### React中的样式规则：


1. **内联样式**：React推荐使用**JavaScript**对象来定义样式，这些样式对象可以作为属性直接传递给React元素。
   
   ```jsx
   const divStyle = {
     color: 'blue',
     backgroundColor: 'lightgray',
   };
   function HelloWorldComponent() {
     return <div style={divStyle}>Hello World!</div>;
   }
```
   
2. **CSS类**：传统的CSS类也可以在React中使用，通常会用`className`属性而不是`class`属性来避免与JavaScript中的保留字冲突。
   
   ```jsx
   // 在CSS文件中
   .my-style {
     color: 'blue';
     background-color: 'lightgray';
   }
   // 在React组件中
   function HelloWorldComponent() {
     return <div className="my-style">Hello World!</div>;
   }
```
   
3. **CSS模块**：为了避免样式冲突，React支持CSS模块，它可以自动为CSS类名添加唯一的标识符。
   
   ```jsx
   // 假设有一个名为styles的CSS模块文件
   import styles from './App.module.css';
   function HelloWorldComponent() {
     return <div className={styles.myStyle}>Hello World!</div>;
   }
```
   
4. **样式化组件（Styled Components）**：这是React生态中的一个流行库，允许在JavaScript文件中写CSS，并将样式绑定到组件。
   
   ```jsx
   import styled from 'styled-components';
   const StyledDiv = styled.div`
     color: blue;
     background-color: lightgray;
   `;
   function HelloWorldComponent() {
     return <StyledDiv>Hello World!</StyledDiv>;
   }
   ```

- ### Vue中的样式规则：


1. **内联样式**：Vue使用`v-bind:style`指令来提供内联样式，它也是使用JavaScript对象来定义。
   
   ```vue
   <template>
     <div v-bind:style="divStyle">Hello World!</div>
   </template>
   <script>
   export default {
     data() {
       return {
         divStyle: {
           color: 'blue',
           backgroundColor: 'lightgray'
         }
       };
     }
   };
   </script>
```
   
2. **CSS类**：Vue中使用`v-bind:class`指令来动态绑定CSS类，支持字符串、对象或数组。
   
   ```vue
   <template>
     <div v-bind:class="{'my-style': isStyled}">Hello World!</div>
   </template>
   <script>
   export default {
     data() {
       return {
         isStyled: true
       };
     }
   };
   </script>
```
   
3. **作用域样式**：通过在`<style>`标签中添加`scoped`属性，**Vue提供了样式作用域的概念，以确保样式只应用于当前组件。**
   
   ```vue
   <template>
     <div class="my-style">Hello World!</div>
   </template>
   <style scoped>
   .my-style {
     color: blue;
     background-color: lightgray;
   }
   </style>
```
   
4. **预处理器**：Vue支持如Sass/SCSS、Less等CSS预处理器，并且可以很容易地集成到`.vue`文件的`<style>`块中。

在两个框架中，你都可以使用传统的CSS文件，并通过构建工具（如Webpack）将它们与组件关联起来。但由于Vue的单文件组件（Single File Components）概念，Vue在将HTML、JavaScript和CSS组合在一个文件中方面提供了更原生的支持。

总体来说，React和Vue在样式化方面都提供了灵活性，既可以采用传统的CSS类方法，也支持内联样式和JavaScript风格的对象。二者的选择主要取决于项目需求、开发者偏好和团队约定。



## 面经

### display属性值及其作用

| 属性值       | 作用                                                       |
| ------------ | ---------------------------------------------------------- |
| none         | 元素不显示，并且会从文档流中移除                           |
| block        | 块元素类型。默认宽度为父元素宽度，可设置宽高，换行显示     |
| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示   |
| inline-block | 行内块元素类型。默认宽度为内容宽度，可以设置宽高，同行显示 |
| list-item    | 像块类型元素一样显示，并添加样式列表标记                   |
| table        | 此元素会作为块级表格来显示                                 |
| inherit      | 规定应该从父元素继承display属性的值                        |

### block、inline和inline-block的区别

| 区别     | block | inline       | inline-block |
| -------- | ----- | ------------ | ------------ |
| 独占一行 | 是    | 否           | 否           |
| width    | 是    | 否           | 是           |
| height   | 是    | 否           | 是           |
| margin   | 是    | 水平方向有效 | 是           |
| padding  | 是    | 是           | 是           |

### 行内元素和块级元素的区别

| 区别         | 行内元素     | 块级元素     |
| ------------ | ------------ | ------------ |
| 宽高         | 无效         | 有效         |
| padding      | 有效         | 有效         |
| margin       | 水平方向有效 | 有效         |
| 自动换行     | 不可以       | 可以         |
| 多个元素排列 | 默认从左到右 | 默认从上到下 |

### 隐藏元素的方法

| 方法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| display: none;        | 渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件 |
| visibility: hidden;   | 元素在页面中仍占据空间，但是不会响应绑定的监听事件           |
| opacity: 0;           | 透明度设置为0，来隐藏元素。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件 |
| position: absolute;   | 通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏   |
| z-index: -10;         | 使用其余元素遮盖当前元素实现隐藏                             |
| clip/clip-path        | 使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件 |
| transform: scale(0,0) | 将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件 |

### transition和animation的区别

| transition                                       | animation                                          |
| ------------------------------------------------ | -------------------------------------------------- |
| 过渡属性，强调过渡，需要触发事件来实现过渡效果。 | 动画属性，不需要触发事件，可自己执行，并且可以循环 |



### 伪元素和伪类的区别和作用

| 伪元素                                                       | 伪类                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 在元素前后插入额外的元素或样式，插入的元素没有子文档中生成，它们只在外部显示可见 | 将特殊的效果添加到特定的选择器上。它是在现有元素上添加类别，并不会产生新的元素 |
| css3中伪元素在书写是使用双冒号::，比如::before               | 冒号:用于伪类，比如:hover                                    |

> 伪类是通过在元素选择器上加入伪类改变元素的状态，而伪元素通过对元素的操作来改变元素

在CSS中，伪元素和伪类是两种特殊类型的选择器，它们可以选择页面上无法用常规CSS选择器选择的部分。

### 伪类（Pseudo-classes）
伪类用于定义元素的特殊状态。例如，它可以选择鼠标悬停在上面的元素，或者选择每个列表的第一个元素。伪类以冒号 `:` 开头，表示它们不是选择实际存在于文档树中的元素，而是基于某些特定条件来选择元素。例如：

```css
a:hover {
  color: red;
}
```
这个伪类选择器选择所有处于悬停状态的 `<a>` 元素，并将它们的文本颜色设置为红色。

### 伪元素（Pseudo-elements）
伪元素用于选择并样式化页面上一部分内容的特定部分，即使这部分内容没有实际的HTML元素对应。它以双冒号 `::` 开头，用于区分伪类和伪元素。例如：

```css
p::first-line {
  font-weight: bold;
}
```
这个伪元素选择器选择每个 `<p>` 元素的第一行，并将其字体加粗。

以下是一些常见的伪类和伪元素的例子：

#### 常见伪类
- `:hover` — 当用户将鼠标悬停在元素上时。
- `:focus` — 当元素获得焦点时，例如通过点击或使用键盘导航。
- `:active` — 当元素正在被激活（例如点击一个按钮）时。
- `:visited` — 选择已经被用户访问过的链接。
- `:first-child` — 选择其父元素的第一个子元素。
- `:last-child` — 选择其父元素的最后一个子元素。
- `:nth-child(an+b)` — 选择其父元素的一个特定的子元素。

#### 常见伪元素
- `::before` — 在元素内容之前插入内容。
- `::after` — 在元素内容之后插入内容。
- `::first-line` — 选择元素中的第一行。
- `::first-letter` — 选择元素中的第一个字母。
- `::selection` — 选择用户用鼠标选中的部分文本。

伪类和伪元素在CSS中非常有用，它们提供了一种在不改变HTML结构的情况下，通过CSS添加细节和装饰效果的方法。



### 盒模型

> 盒模型由四个部分组成，分别是margin、border、padding、content

CSS盒模型是CSS（层叠样式表）中的一个基础概念，用于布局和设计。在CSS中，所有的HTML元素可以看作是放在盒子内，这些盒子决定了元素的布局和空间占用。盒模型包含了几个不同的部分：

1. **内容（Content）**：元素的实际内容区域，包括文本、图片或其他媒体内容。

2. **内边距（Padding）**：内容区域周围的空白区域，即内容与边框之间的距离。内边距是透明的，可以设置大小。

3. **边框（Border）**：围绕内边距和内容的线条或框。边框的粗细、样式和颜色都可以设置。

4. **外边距（Margin）**：盒子与其他盒子之间的空白区域。外边距是透明的，可以设置大小。

这些部分一起决定了整个元素盒子的大小和在页面中的位置。默认情况下，一个元素的总宽度和高度计算方式如下：

```
总宽度 = 左外边距 + 左边框 + 左内边距 + 内容宽度 + 右内边距 + 右边框 + 右外边距
总高度 = 上外边距 + 上边框 + 上内边距 + 内容高度 + 下内边距 + 下边框 + 下外边距
```

- #### 盒模型的类型

CSS提供了两种盒模型的计算方式：

1. **标准盒模型（Content-Box）**：在这个模型中，元素的宽度和高度只包括内容区域，不包括内边距、边框和外边距。

2. **替代盒模型（Box-Box）**：在这个模型中，元素的宽度和高度包括内容、内边距和边框，但不包括外边距。

可以通过CSS的`box-sizing`属性来控制哪种盒模型被使用：
- `box-sizing: content-box;` 会触发标准盒模型。
- `box-sizing: border-box;` 会触发替代盒模型。



### 实现单行、多行文本溢出隐藏

> 单行文本溢出

```css
overflow: hidden;           // 溢出隐藏
text-overflow: ellipsis;    // 溢出部分使用省略号显示
white-space: nowrap;        // 规定段落中的文本不可换行
```

> 多行文本溢出

```css
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;     // 溢出用省略号显示
display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
-webkit-line-clamp:3;        // 显示的行数
```



### 实现水平垂直居中

> 利用绝对定位（一）

```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%)
}
```

> 利用绝对定位（二）：适用于已知盒子宽高

```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
}
```

> 利用绝对定位（三）：适用于已知盒子宽高

```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -50px;     /* 自身 height 的一半 */
    margin-left: -50px;    /* 自身 width 的一半 */
}
```

> flex布局

```css
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
```



# JavaScript

## 数据类型

JavaScript有几种基本数据类型：

- **字符串（String）**：表示文本数据，例如 `"Hello, world!"`。
- **数字（Number）**：既可以是整数也可以是浮点数，例如 `42` 或 `3.14159`。
- **布尔值（Boolean）**：只有两个值，`true` 或 `false`。
- **对象（Object）**：用于存储键值对的集合，例如 `{ name: "Alice", age: 25 }`。
- **数组（Array）**：用于存储值的有序集合，例如 `[1, "two", 3.14]`。
- **`null`**：表示一个空值。
- **`undefined`**：表示未赋值的变量的默认值。



### 变量

在JavaScript中，你可以使用 `var`、`let` 或 `const` 来声明变量：

- **var**：传统的变量声明关键字，具有函数级作用域。
- **let**：引入了块级作用域的变量声明。
- **const**：声明不可改变的常量，其值初始化后不能再更改。



### 操作符

JavaScript提供了多种操作符：

- **赋值**：`=`

- **数学**：`+`, `-`, `*`, `/`, `%` 等

- **比较**：`==`, `===`, `!=`, `!==`, `<`, `>`, `<=`, `>=`

- **逻辑**：`&&`（与），`||`（或），`!`（非）

  

### null、NaN 和 undefined

#### `null`

- **语义**：`null` 表示“没有值”或“空”。当你想明确地表示某个变量没有值时，可以使用 `null`。

- **用途**：经常用于初始化变量，表示该变量尚未引用任何对象或值。也常用于对象属性或数组中表示空的槽。

- **类型**：虽然 `typeof null` 会返回 `"object"`，但这其实是JavaScript中的一个历史错误。

  ```
  let a = null;
  typeof a; // "object"（历史错误）
  ```

使用 instanceof：null instanceof Object 返回 false。

#### `NaN` (Not-a-Number)

- **语义**：`NaN` 用于表示一个不能表示为合法数字的值。通常是在数学运算失败时出现，如将字符串减去数字。

- **用途**：用于表示数学运算的错误结果而不是抛出异常。JavaScript提供了 `isNaN()` 函数来检查一个值是否是 `NaN`。

- **类型**：它是一个特殊的 `Number` 类型。

  ```
  let a = "text" / 3;
  isNaN(a); // true
  typeof a; // "number"
  ```

- **特殊性**：`NaN` 是唯一一个不等于自己的值。

  ```
  NaN === NaN; // false
  ```

- 使用 `instanceof`：`NaN instanceof Number` 返回 `false`，因为 `NaN` 是 `Number` 类型的一个特殊值，但它不是 `Number` 对象的实例。

#### `undefined`

- **语义**：当一个变量被声明但没有被赋值时，其默认值为 `undefined`。它表示“未定义”或“不存在”。

- **用途**：常用于检查变量是否已赋值或对象属性或数组元素是否存在。

- **类型**：`typeof undefined` 会返回 `"undefined"`。

  ```
  let a;
  typeof a; // "undefined"
  ```

- 使用 `instanceof`：由于 `undefined` 不是一个对象，所以 `undefined instanceof AnyConstructor` 总是返回 `false`。

- **与 `null` 的区别**：`null` 是一个表示“无”的对象，`undefined` 表示一个**变量没有被初始化**。

**比较**

- `null == undefined` 返回 `true`，因为 `==` 运算符会进行类型转换。
- `null === undefined` 返回 `false`，因为 `===` 运算符（全等运算符）要求类型和值都相同。

```
null == undefined  // true
null === undefined // false
```



### ===，==

**JavaScript**

- `==`：**宽松相等运算符**。这意味着它在比较时会进行**类型转换**。例如，字符串 `'5'` 和数字 `5` 会被认为是相等的。

  ```
  '5' == 5  // true
  null == undefined  // true
  ```

- `===`：**严格相等运算符**。这意味着不进行任何类型转换，所以类型和值都必须相等。

  ```
  '5' === 5  // false
  null === undefined  // false
  ```

**Java**

- `==`：在Java中，这个操作符用于**基本数据类型（如 `int`、`char` 等）的值比较和引用类型（如对象）的引用比较**。对于对象，`==` 比较的是两个引用**是否指向内存中的同一个对象实例**。

  ```
  int a = 5;
  int b = 5;
  a == b  // true
  
  String str1 = new String("hello");
  String str2 = new String("hello");
  str1 == str2  // false
  ```

- `equals()`：Java中通常使用 `equals()` 方法来比较**两个对象的内容是否相等**。这是一个可以在任何对象上调用的方法，并且可以根据需要重写。

  ```
  str1.equals(str2)  // true, assuming equals() is properly overridden
  ```

  

**Python**

- `==`：在Python中，这个操作符用于**比较两个对象的值是否相等**。不同类型的对象也可以被认为是相等的，只要它们的值是相等的（这取决于该类型如何实现 `__eq__()` 方法）。

  ```
  5 == 5  // true
  '5' == 5  // false
  ```

- `is`：Python中的 `is` 运算符用于比较两个对象是**否是同一个对象**（即比较它们的内存地址）。这类似于Java中的 `==` 运算符在对象上的行为。

  ```
  a = [1, 2, 3]
  b = [1, 2, 3]
  a == b  // true
  a is b  // false
  ```

总结一下，不同语言中的 `==` 和 `===`（或类似的操作符和方法）有各自的行为和用途。在JavaScript中，`==` 和 `===` 主要是用来进行值的比较，其中 `===` 是严格相等运算符，需要类型也相同。在Java中，`==` 可用于基本数据类型的值比较和对象引用的比较，而 `equals()` 用于比较对象的内容。在Python中，`==` 用于值比较，`is` 用于引用比较。



### 类型转换

JavaScript是一种**弱类型语言**

#### 隐式类型转换（Coercion）

当运算符在操作不同类型的变量时，JavaScript会自动转换其中一个类型，以完成操作。这就是所谓的隐式类型转换。

- **字符串拼接**：当你尝试拼接字符串和非字符串时，非字符串会被转换为其字符串表示形式。

  ```
  "Hello, " + 42  // "Hello, 42"
  ```

- **数学运算**：在加减乘除等运算中，非数字通常会被转换为数字。

  ```
  "5" - 1  // 4
  "5" + 1  // "51" (注意：加法运算符会触发字符串拼接)
  ```

- **比较运算**：使用 `==` 运算符进行比较时，JavaScript会尝试转换操作数的类型。

  ```
  "5" == 5  // true
  ```

- **逻辑运算**：在逻辑表达式（如 `if` 语句）中，某些值会被转换为其布尔表示形式。

  ```
  if ("string") { /* 这个块会执行，因为非空字符串为真 */ }
  ```



#### 显式类型转换

除了隐式类型转换外，你也可以明确地转换变量的类型。

- **使用 `String()`，`Number()` 和 `Boolean()` 函数**

  ```
  String(42)  // "42"
  Number("42")  // 42
  Boolean(0)  // false
  ```

- **使用 `parseInt()` 和 `parseFloat()`**

  ```
  parseInt("42px")  // 42
  parseFloat("42.2em")  // 42.2
  ```

- **使用一元 `+` 和 `-` 运算符进行数值转换**

  ```
  +"42"  // 42
  -"42"  // -42
  ```

- **使用 `!!` 运算符进行布尔转换**

  ```
  !!42  // true
  !!0  // false
  ```

- **使用 `.toString()` 方法转为字符串**

  ```
  (42).toString()  // "42"
  ```



**特殊情况**

- `null` 和 `undefined` 在数学运算和比较运算中有特殊的转换规则。

  ```
  null + 1  // 1
  undefined + 1  // NaN
  ```

- `NaN`（Not-a-Number）是一个特殊的数值，**任何涉及 `NaN` 的数学运算都将返回 `NaN`。**

  ```
  NaN + 1  // NaN
  ```

- 对象、数组和函数在转换时会有特殊的行为。

  ```
  [1, 2, 3] + 4  // "1,2,34"
  ```



## 控制结构

控制结构允许你根据条件执行不同的代码路径，例如：

- **if...else**：条件语句。

  ```js
  if (condition) {
    // do something
  } else {
    // do something else
  }
  ```

- **switch**：多路分支。

- **for**：循环语句，用于重复执行代码块直到条件不再为真。

  ```javascript
  for (let i = 0; i < 5; i++) {
    console.log(i);
  }
  ```

- **while** 和 **do...while**：也是循环语句，但是在循环开始前或结束后检查条件。



### 函数

- 函数可以通过 `function` 关键字声明，或者使用箭头函数。
  ```javascript
  function add(x, y) {
    return x + y;
  }
  
  const multiply = (x, y) => x * y;
  ```



### 对象和数组

- **对象：** 一组键值对的集合。
  ```javascript
  const person = {
    firstName: 'John',
    lastName: 'Doe',
    age: 30
  };
  ```

- **数组：** 一个可以包含多个值的有序列表。
  ```javascript
  const fruits = ['Apple', 'Banana', 'Cherry'];
  ```



### DOM 

DOM（Document Object Model）是一个跨平台和语言独立的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。DOM将HTML或XML文档表示为树状结构，每个节点都是文档中的对象，这使得开发者可以通过脚本语言如JavaScript来创建、改变、删除或重排文档中的节点。**通过 `document` 对象可以操作 HTML 文档的内容、结构和样式。**

- ### DOM的组成

DOM由节点（Node）的层次结构构成，包括但不限于以下类型的节点：

- **元素节点（Element Node）**

元素节点代表HTML或XML文档中的标签。例如，在下面的HTML代码中，`<div>`、`<h1>` 和 `<p>` 都会被创建为元素节点：

```html
<div>
  <h1>页面标题</h1>
  <p>这是一个段落。</p>
</div>
```

- **文本节点（Text Node）**

文本节点包含元素或属性中的文本内容。它总是被包含在元素节点中。例如，在上面的HTML中，"页面标题" 和 "这是一个段落。" 都是文本节点。

- **属性节点（Attribute Node）**

属性节点定义了HTML元素的属性。在HTML DOM中，属性节点通常不作为独立的节点，而是作为元素节点的一部分来处理。然而，它们也可以被视为描述元素特征的节点。例如：

```html
<a href="https://www.example.com">访问示例网站</a>
```

在这个例子中，`href="https://www.example.com"` 是`<a>`元素的属性节点。

- **注释节点（Comment Node）**

注释节点包含文档的注释内容，用于提供信息而不会在浏览器中显示。例如：

```html
<!-- 这是一个注释 -->
```

在这里，"这是一个注释" 是注释节点。

- **文档节点（Document Node）**

文档节点是每个文档树的根节点，代表整个文档。在浏览器中，可以通过全局的 `document` 对象访问它。

- **文档类型节点（Document Type Node）**

文档类型节点包含与文档类型定义相关的所有信息，例如DOCTYPE声明（用于指定HTML文档的版本）。

```html
<!DOCTYPE html>
```

在这里，`<!DOCTYPE html>` 是文档类型节点。



- ### DOM的操作

通过DOM API，可以执行如下操作：

- **遍历：** 读取文档的结构，访问DOM树中的节点。

- **查询：** 查找特定元素或元素集合。

- **修改：** 改变文档的结构、样式或内容。

- **监听：** 在元素上注册事件监听器以响应用户交互。

- **创建和删除：** 添加新节点或移除现有节点。

  

- ### JavaScript中的DOM操作

在JavaScript中，可以通过全局变量`document`来访问DOM，并进行操作。例如：

- **查询元素：**
  ```javascript
  let element = document.getElementById('myElement');
  ```

- **创建新元素：**
  ```javascript
  let newElement = document.createElement('div');
  ```

- **更改元素内容：**
  ```javascript
  element.textContent = 'Hello, World!';
  ```

- **更改样式：**
  ```javascript
  element.style.color = 'blue';
  ```

- **添加或移除子元素：**
  ```javascript
  element.appendChild(newElement); // 添加
  element.removeChild(newElement); // 移除
  ```

- **事件监听：**
  ```javascript
  element.addEventListener('click', function() {
    console.log('Element clicked!');
  });
  ```



- ### DOM的优点和局限

DOM的优点在于提供了一个统一的方式来交互和操纵不同类型的文档。它是一个标准的API，由W3C维护和更新。

然而，DOM操作有时候可能会很慢，特别是在处理大型文档和复杂的页面时。对DOM的频繁操作可能会引起浏览器的重排（reflow）和重绘（repaint），这可能会影响页面的性能。因此，开发者通常会寻求优化DOM操作，减少操作的频率和范围，或者使用虚拟DOM技术（如React中的虚拟DOM）来间接操作真实的DOM。



#### 事件处理

- 可以将事件处理器绑定到 HTML 元素上，响应用户的交互操作。
  ```javascript
  document.getElementById('myButton').addEventListener('click', function() {
    alert('Button clicked!');
  });
  ```



### 异步编程

- 使用 `Promises` 和 `async/await` 处理异步操作。
  ```javascript
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
  
  // 使用 async/await
  async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  }
  ```



### 错误处理

- 使用 `try...catch` 语句来处理错误。
  ```javascript
  try {
    // 尝试执行的代码
  } catch (error) {
    // 错误处理代码
  }
  ```

这些是JavaScript的一些核心基础知识点。学习和掌握这些概念是成为一个有效的JavaScript开发者的关键。



### this

在JavaScript中，`this` 关键字是一个特殊的变量，它指向函数执行时的**上下文对象（context）**。`this` 的值取决于函数是如何被调用的，而不是如何被定义的。它的值在函数被调用时确定，并且在函数执行期间保持不变。

1. **在全局执行上下文中（非严格模式）**，`this` 指向全局对象。在浏览器中，`this` 通常指向 `window` 对象。
   
   ```javascript
   console.log(this === window); // true
```
   
2. **在函数内部（非严格模式）**，`this` 仍然指向全局对象。
   ```javascript
   function myFunction() {
     console.log(this === window); // true
   }
   myFunction();
   ```

3. **在方法内部**，`this` 指向调用该方法的对象。
   ```javascript
   const myObject = {
     method: function() {
       console.log(this === myObject); // true
     }
   };
   myObject.method();
   ```

4. **在严格模式下**（在函数或全局范围内使用 `'use strict';`），`this` 的值为 `undefined`，除非函数被一个对象调用。
   ```javascript
   'use strict';
   function myFunction() {
     console.log(this); // undefined
   }
   myFunction();
   ```

5. **在事件处理器中**，`this` 指向触发事件的元素。
   ```javascript
   button.addEventListener('click', function() {
     console.log(this === button); // true
   });
   ```

6. **在构造器中**，`this` 指向新创建的对象实例。
   ```javascript
   function MyConstructor() {
     this.myProperty = 'value';
   }
   const myInstance = new MyConstructor();
   console.log(myInstance.myProperty); // "value"
   ```

7. **在箭头函数中**，`this` 被词法地绑定，即它使用包含箭头函数的上下文中的 `this` 值。
   
   ```javascript
   const myObject = {
     method: () => {
       console.log(this === window); // true
     }
   };
   myObject.method();
   ```



### 事件（Events）

在JavaScript中，事件是浏览器或用户自身执行的某种动作，如点击、加载、鼠标移动等。你可以使用 `addEventListener` 方法来监听一个特定元素上的事件，并指定当该事件触发时运行的函数。

```
document.getElementById("myBtn").addEventListener("click", function() {
  alert("Button clicked!");
});
```

#### 事件传播的三个阶段

事件在DOM（Document Object Model）中的传播通常分为三个主要阶段：**捕获阶段（Capturing Phase）、目标阶段（Target Phase）和冒泡阶段（Bubbling Phase**）。

**1. 捕获阶段（Capturing Phase）**

- **开始点**：事件传播的捕获阶段从最顶层的父元素（通常是`document`对象）开始。

- **传播方向**：事件会沿着DOM树由上而下地传播，直到达到触发该事件的元素。

- **用途**：捕获阶段较少用于实际的事件处理，但在需要在事件到达目标元素之前进行某种预处理时可能会用到。

- **如何监听**：在使用`addEventListener`方法添加事件监听器时，可以设置第三个参数为`true`，表示在捕获阶段触发。

  ```
  element.addEventListener("click", function() {
    console.log("Capturing phase");
  }, true);
  ```

**2. 目标阶段（Target Phase）**

- **焦点**：当事件传播到达实际触发该事件的元素时，它处于目标阶段。

- **特点**：这一阶段是捕获阶段和冒泡阶段之间的临界点。

- **用途**：这一阶段通常用于具体的事件处理逻辑。

- **如何监听**：`addEventListener`默认就是在目标阶段触发的。

  ```
  element.addEventListener("click", function() {
    console.log("Target phase");
  });
  ```

**3. 冒泡阶段（Bubbling Phase）**

- **开始点**：事件从触发该事件的元素开始。

- **传播方向**：事件会由下而上，逐级向外传播，直到最顶层的父元素。

- **用途**：冒泡阶段通常用于事件委托，可以在一个共同的父元素上设置一个事件监听器，用于处理多个子元素的事件。

- **如何监听**：在使用`addEventListener`方法添加事件监听器时，可以设置第三个参数为`false`或者省略该参数，表示在冒泡阶段触发。

  ```
  element.addEventListener("click", function() {
    console.log("Bubbling phase");
  }, false);
  ```



**冒泡机制（Event Bubbling）**

冒泡机制是DOM（文档对象模型）事件传播的一种方式。当一个元素上的事件被触发时，该事件不仅仅会作用于这个元素，还会“冒泡”到这个元素的父元素，再到父元素的父元素，依此类推，直到达到`document`对象。这样做的一个主要好处是，你可以在一个共同的父元素上设置一个事件监听器，用于处理多个子元素的事件，这被称为事件委托。

```
<div id="parent">
  <button id="child">Click me!</button>
</div>

document.getElementById("parent").addEventListener("click", function() {
  alert("Parent Div Clicked!");
});

document.getElementById("child").addEventListener("click", function() {
  alert("Button Clicked!");
});
```

在这个例子中，如果你点击了按钮（即 "Button Clicked!"），你也会看到 "Parent Div Clicked!" 的弹窗。这是因为事件从按钮开始，然后冒泡到其父元素，也就是`div`元素。



# REACT

React是一个用于构建用户界面的JavaScript库，特别适用于构建大型、可复用组件的单页应用程序（SPA）。以下是React中一些主要的语法和概念：

### JSX（JavaScript XML）
JSX是一种JavaScript的语法扩展，它允许你在JavaScript代码中编写类似HTML的标记语言。它让创建React元素变得更直观。

```jsx
const element = <h1>Hello, world!</h1>;
```

JSX最终会被Babel这样的编译器转换为普通的JavaScript对象。

### 组件（Components）
组件是React应用的基础构建块。它们是独立和可复用的代码块，负责渲染UI的一部分。组件可以是类组件或函数组件。

#### 类组件
类组件使用ES6的类语法定义，并且可以包含状态（state）和生命周期方法。

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

#### 函数组件
函数组件是更简单的组件类型，通常用于不包含状态和生命周期方法的UI。

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

### 状态（State）
状态是一个组件可以管理的数据，它可以随时间变化，并影响组件的渲染输出。在类组件中，状态是一个对象，通过`this.setState`方法更新。

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

在函数组件中，可以使用`useState` Hook来添加状态。

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

### 属性（Props）
Props是从父组件传递到子组件的只读数据。它们在组件内部不应该被修改。

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
```

### 钩子（Hooks）
Hooks是React 16.8引入的新特性，它允许你在函数组件中使用状态和其他React特性，如生命周期、上下文（context）等。

```jsx
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // 相当于类组件中的 componentDidMount 和 componentDidUpdate:
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

### 生命周期方法
生命周期方法是类组件中的特殊方法，它们在组件的生命周期的特定时刻被调用，例如组件创建、更新和销毁时。

```jsx
class MyComponent extends React.Component {
  componentDidMount() {
    // 组件被挂载到DOM后调用
  }

  componentDidUpdate(prevProps, prevState) {
    // 组件更新后调用
  }

  componentWillUnmount() {
    // 组件卸载前调用
  }

  render() {
    return <div>{/* ... */}</div>;
  }
}
```

### 事件处理
React元素可以有事件处理器，它们的命名遵循camelCase约定，而且你需要传递一个函数作为事件处理器，而不是一个字符串。

```jsx
<button

 onClick={activateLasers}>
  Activate Lasers
</button>
```

### 条件渲染
在React中，你可以使用JavaScript运算符来创建表示当前状态的不同UI部分。

```jsx
function Greeting(props) {
  if (props.isLoggedIn) {
    return <UserGreeting />;
  }
  return <GuestGreeting />;
}
```

### 列表与键（Keys）
当你有一个元素数组时，每个元素都应该有一个独一无二的`key`属性，这有助于React识别哪些项被改变、添加或是移除。

```jsx
const todoItems = todos.map((todo) =>
  <li key={todo.id}>
    {todo.text}
  </li>
);
```

### 表单处理
React中的表单元素通常是受控组件，这意味着输入的状态由React的状态控制。

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

### 上下文（Context）
Context提供了一种在组件间共享此类值的方式，而不必显式地通过组件树的每个层级传递props。

```jsx
// 创建一个 Context
const ThemeContext = React.createContext('light');

// 使用Provider来传递当前的theme，任何组件都可以读取它，无论多深
<ThemeContext.Provider value="dark">
  <Toolbar />
</ThemeContext.Provider>

// 在组件中读取Context
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <Button theme={theme} />;
}
```

### 高阶组件（HOCs）
高阶组件是React中用于重用组件逻辑的高级技术。HOC本身不是React API的一部分，它是一种模式，源自React自身的组合性质。

```jsx
function withSubscription(WrappedComponent, selectData) {
  // 返回另一个组件
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    // ... 其他生命周期方法 ...

    render() {
      // 使用最新的数据渲染WrappedComponent
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
```

### 状态管理
在更复杂的应用中，状态管理可能会变得复杂，这时候可以使用Redux或Context API等库来管理应用的状态。

```jsx
import { createStore } from 'redux';

// Redux store的创建
const store = createStore(reducer);

// 在React组件中使用Redux
import { useSelector, useDispatch } from 'react-redux';
function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    </div>
  );
}
```

以上就是React中的一些高级话题，深入理解和正确使用这些概念将使你能够构建出强大且易于维护的前端应用程序。



# VUE

Vue.js是一种用于构建用户界面的渐进式JavaScript框架。Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，也便于与第三方库或现有项目整合。以下是Vue的一些主要特性：

### 响应式数据绑定
Vue最显著的特性之一是其响应式系统。当Vue实例的数据对象的属性被访问和修改时，视图会自动更新。

```javascript
var vm = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

这会导致具有`id="app"`的DOM在其内容中显示“Hello Vue!”。如果`vm.message`的值改变，DOM会自动更新。

### 组件系统
Vue使用组件系统，允许开发者构建可复用的组件，每个组件都可以有自己的视图、数据逻辑和样式。

```javascript
Vue.component('todo-item', {
  template: '<li>这是一个待办项</li>'
})

var app = new Vue(...)
```

### 虚拟DOM
Vue.js使用虚拟DOM来渲染视图。这意味着Vue构建一个轻量级的内存中DOM表示，计算出最小的必要DOM更新，然后进行必要的DOM操作，这种方式可以提高渲染效率。

### 模板
Vue使用基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。所有Vue.js模板都是合法的HTML，所以可以被遵循规范的浏览器和HTML解析器解析。

```html
<div id="app">
  {{ message }}
</div>
```

### 计算属性和侦听器
计算属性是依赖于响应式数据变化而自动更新的值。侦听器（watchers）则允许执行代码响应于数据的变化。

```javascript
var vm = new Vue({
  el: '#app',
  data: {
    a: 1
  },
  computed: {
    // 计算属性的 getter
    b: function () {
      // `this` 指向 vm 实例
      return this.a + 1
    }
  }
})
```

### 指令（Directives）
Vue指令（例如v-bind和v-on）提供了声明式的方法来将DOM元素的行为绑定到数据模型上。这些指令前缀为`v-`。

```html
<div id="app">
  <!-- 绑定属性 -->
  <img v-bind:src="imageSrc">
  
  <!-- 绑定事件 -->
  <button v-on:click="doSomething">
    Click me!
  </button>
</div>
```

### 过渡 & 动画
Vue提供了过渡的应用方式，通过包裹要动画化的组件或元素，在CSS过渡和动画中自动应用类名。

```html
<div id="demo">
  <button v-on:click="show = !show">
    Toggle
  </button>
  <transition name="fade">
    <p v-if="show">hello</p>
  </transition>
</div>
```

### 路由
通过Vue Router，Vue.js提供了前端路由的解决方案，用于构建单页面应用（SPA）。

```javascript
const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
  ]
})
```

### 状态管理
Vuex是Vue应用程序的状态管理模式和库，它为应用中的所有组件提供了一个集中存储服务。

```javascript
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
```

