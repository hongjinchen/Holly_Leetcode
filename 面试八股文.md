





# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）**: 单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

   在单例模式的实现中，通常会：

   1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
   2. 创建一个私有静态成员变量，用于保存单一实例。
   3. 提供一个公共静态方法来获取这个唯一的实例。

2. **工厂方法模式（Factory Method）**: 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个接口用于创建对象，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

   工厂方法模式主要包括以下几个组件：

   1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
   2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
   3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
   4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

   如何实现

   1. **定义一个返回对象（Product）的工厂接口（Creator）**。
   2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
   3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

   ```python
   from abc import ABC, abstractmethod
   
   # Product 类
   class Button(ABC):
   
       @abstractmethod
       def click(self):
           pass
   
   # ConcreteProduct 类
   class WindowsButton(Button):
       
       def click(self):
           print("Windows button clicked")
   
   class LinuxButton(Button):
       
       def click(self):
           print("Linux button clicked")
   
   # Creator 类
   class ButtonFactory(ABC):
       
       @abstractmethod
       def create_button(self):
           pass
   
   # ConcreteCreator 类
   class WindowsButtonFactory(ButtonFactory):
       
       def create_button(self):
           return WindowsButton()
   
   class LinuxButtonFactory(ButtonFactory):
       
       def create_button(self):
           return LinuxButton()
   
   # 客户端代码
   def button_client_code(factory):
       button = factory.create_button()
       button.click()
   
   # 使用
   windows_factory = WindowsButtonFactory()
   button_client_code(windows_factory)
   
   linux_factory = LinuxButtonFactory()
   button_client_code(linux_factory)
   
   ```

   

3. **抽象工厂模式（Abstract Factory）**: 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

   **结构和组件**

   1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

   2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

   3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

   4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

      

      1. **定义抽象产品的接口（AbstractProduct）**。

      2. **创建实现该接口的具体产品（ConcreteProduct）**。

      3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

      4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

      5. **使用具体工厂和抽象工厂来创建产品实例**。

         

      ```python
      from abc import ABC, abstractmethod
      
      # 抽象产品
      class Button(ABC):
          @abstractmethod
          def click(self):
              pass
      
      class Checkbox(ABC):
          @abstractmethod
          def check(self):
              pass
      
      # 具体产品
      class WindowsButton(Button):
          def click(self):
              print("Windows Button clicked")
      
      class WindowsCheckbox(Checkbox):
          def check(self):
              print("Windows Checkbox checked")
      
      class LinuxButton(Button):
          def click(self):
              print("Linux Button clicked")
      
      class LinuxCheckbox(Checkbox):
          def check(self):
              print("Linux Checkbox checked")
      
      # 抽象工厂
      class GUIFactory(ABC):
          @abstractmethod
          def create_button(self):
              pass
      
          @abstractmethod
          def create_checkbox(self):
              pass
      
      # 具体工厂
      class WindowsGUIFactory(GUIFactory):
          def create_button(self):
              return WindowsButton()
      
          def create_checkbox(self):
              return WindowsCheckbox()
      
      class LinuxGUIFactory(GUIFactory):
          def create_button(self):
              return LinuxButton()
      
          def create_checkbox(self):
              return LinuxCheckbox()
      
      # 客户端代码
      def client_code(factory):
          button = factory.create_button()
          checkbox = factory.create_checkbox()
          
          button.click()
          checkbox.check()
      
      # 使用
      windows_factory = WindowsGUIFactory()
      client_code(windows_factory)
      
      linux_factory = LinuxGUIFactory()
      client_code(linux_factory)
      
      ```

      

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

### 结构型模式（Structural Patterns）

1. **适配器模式（Adapter）**: 允许不兼容的接口可以一起工作。
2. **装饰器模式（Decorator）**: 在不改变对象本身的基础上，动态地添加额外的功能。
3. **组合模式（Composite）**: 将对象组合成树形结构以表示“部分-整体”的层次结构。

### 行为型模式（Behavioral Patterns）

1. **观察者模式（Observer）**: 当一个对象的状态发生变化时，其依赖者都会得到通知。
2. **策略模式（Strategy）**: 定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。
3. **命令模式（Command）**: 将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。

# 计算机网络

## HTTP 和 HTTPS 的基本概念

**HTTP**：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP 原理**：

①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 **TCP** 来完成的，一般 TCP 连接的端口号是**80**。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。



**HTTPS**：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。**SSL 握手协议（SSL Handshake Protocol）**，它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
![img](https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70)

**HTTPS 设计目标**：

(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。

(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。



### HTTP 与 HTTPS  的区别

1、HTTPS  协议需要到 **CA （Certificate Authority，证书颁发机构）**申请证书，一般免费证书较少，因而需要一定费用。（但是云服务器供应商会免费配置HTTPS  证书）

2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。

- **HTTP**: 使用明文进行传输，信息在传输过程中没有加密。这意味着第三方可以容易地截获和查看数据。
- **HTTPS**: 使用 SSL/TLS 协议对数据进行加密，保证了数据在传输过程中的安全性。这使得第三方即使截获了数据也很难解读。

3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者是443。

4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

5、CPU 资源消耗

- **HTTP**: 由于没有加密和解密过程，所以 CPU 资源消耗相对较少。
- **HTTPS**: 加密和解密需要额外的 CPU 资源，从而导致更高的计算成本。





### HTTPS 相对于 HTTP 的改进

#### **双向的身份认证**

客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：

- 客户端发起 SSL 握手消息给服务端要求连接。

- 服务端将证书发送给客户端。

- 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

- 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。



注意：

(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是*一对公钥和私钥*。

(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。

(3) 客户端内置的是 **CA 的根证书(Root Certificate)**，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。



#### 数据传输的机密性

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的**加密算法**。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的**密钥交换算法** ( 一般是**RSA**)，**数据签名摘要算法** ( 一般是SHA或者MD5) ，加密传输数据的**对称加密算法** ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。



#### 防止重放攻击

SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。

可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。

重放攻击（Replay Attack）是一种网络攻击类型，其中攻击者拦截并记录了有效的数据传输，然后在稍后的时间里再次发送（或“重放”）该数据，以尝试进行未授权的操作。因为这些数据包在初次传输时是有效的，所以在没有额外安全措施的情况下，接收方可能会认为重放的数据包也是有效和合法的。



**如何进行重放攻击？**

1. **拦截阶段**: 攻击者首先需要能够拦截目标和服务器之间的通信。这通常通过嗅探、中间人攻击或者其他网络侦听技术来完成。
2. **记录阶段**: 攻击者记录拦截到的数据包。
3. **重放阶段**: 攻击者在合适的时机将记录的数据包重新发送给服务器或目标。

**重放攻击的影响**

1. **身份冒充**: 如果拦截的是身份验证信息（如登录令牌或密码），攻击者可能通过重放攻击成功冒充用户。
2. **数据篡改**: 如果拦截的是一个修改数据的操作，重放攻击可能导致数据被重复修改。
3. **信息泄露**: 攻击者可能通过分析拦截的数据包获取敏感信息。

**防御措施**

1. **时间戳**: 在数据包中包含一个时间戳，并在接收数据包时检查它是否在一个合理的时间窗口内。这样，过时的数据包（即可能已经被记录和重放的数据包）就会被拒绝。

2. **序列号**: 使用一个递增的序列号来标记每个数据包。服务器会记录最后一个接收到的有效序列号，并拒绝所有序列号小于或等于该值的数据包。

3. **一次性令牌**: 使用一次性令牌（如 OTP，One-Time Password）进行身份验证。

4. **加密和完整性校验**: 使用像 HTTPS 这样的安全协议，其内部有措施（如消息认证码）来防止重播攻击。

5. **多因素认证**: 使用多种方式进行身份验证，降低单一数据包被重放导致的风险。

   

### HTTPS 的优点

1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。



### HTTPS 的缺点（对比优点）

1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。

3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。

5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。



### HTTPS连接过程

HTTPS 的连接过程涉及多个步骤，主要目的是建立一个安全的加密通道，并进行服务器和（可选的）客户端的身份验证。这通常是通过 TLS（传输层安全）或其前身 SSL（安全套接字层）来实现的。以下是 HTTPS 连接的基本流程，分为几个关键步骤：

#### 1. TCP 握手

在进行任何 HTTPS 交互之前，客户端（通常是一个Web浏览器）和服务器首先需要建立一个 TCP 连接。这是通过三次握手（SYN, SYN-ACK, ACK）完成的。

#### 2. 客户端发起 TLS 握手

一旦 TCP 连接建立，客户端会发起一个 TLS 握手。握手开始时，客户端会发送一个 `ClientHello` 消息，该消息中包含：

- 支持的加密算法列表
- 一个随机生成的客户端随机数（Client Random）
- 其他设置和扩展

#### 3. 服务器响应

服务器接收 `ClientHello` 消息后，会选择一组加密算法和其他设置，然后发送一个 `ServerHello` 消息，其中包含：

- 选定的加密算法
- 一个随机生成的服务器随机数（Server Random）
- 服务器的数字证书

#### 4. 证书验证

客户端接收到服务器的证书后，会对其进行验证以确认服务器的身份。这通常包括：

- 检查证书是否由受信任的证书颁发机构（CA）签发
- 验证证书是否过期
- 验证证书是否被撤销

#### 5. 密钥交换

客户端和服务器使用各自的随机数和一个（在某些密钥交换算法中的）预主密钥（Pre-Master Secret）来生成主密钥（Master Secret）。主密钥将用于加密和解密数据。

客户端生成预主密钥，并使用服务器公钥进行加密，然后发送给服务器。服务器使用其私钥解密获取预主密钥。

#### 6. 完成握手

客户端和服务器都发送一个 `Finished` 消息，该消息使用之前生成的主密钥进行加密。

#### 7. 加密数据传输

一旦 TLS 握手完成，客户端和服务器就会使用生成的主密钥进行加密和解密数据，从而确保数据传输的安全性。

#### 8. 连接关闭

连接完成后，任何一方都可以选择关闭连接。通常，这是通过发送一个 `close_notify` 警告来完成的。这样，双方都能知道连接将安全地关闭，而不是因为某种错误或攻击而突然中断。



#### tcp的三次挥手和四次挥手

**三次握手（Three-Way Handshake）**

三次握手是 TCP 连接建立的过程，涉及三个主要步骤：

1. **SYN（同步序列编号）**: 客户端发送一个 TCP 包，其中设置了 SYN 标志位，以请求建立连接。这个包也包含一个初始的序列号 `x`。
2. **SYN-ACK（同步应答）**: 服务器收到 SYN 包后，回复一个设置了 SYN 和 ACK（确认）标志位的 TCP 包。这个包确认了客户端的 SYN，并提供了服务器自己的初始序列号 `y`。
3. **ACK（应答）**: 客户端收到 SYN-ACK 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 SYN。

完成这三个步骤后，TCP 连接就建立了，数据可以双向传输。

**四次挥手（Four-Way Handshake）**

四次挥手是 TCP 连接终止的过程，涉及四个主要步骤：

1. **FIN（完成）**: 当一方（假设是客户端）准备关闭连接时，它发送一个设置了 FIN 标志位的 TCP 包。
2. **ACK（应答）**: 服务器收到 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认客户端的 FIN。此时，从客户端到服务器的连接关闭，但服务器到客户端的连接仍然打开。
3. **FIN（完成）**: 当服务器准备关闭连接时（可能是立即，也可能是稍后），它发送一个设置了 FIN 标志位的 TCP 包。
4. **ACK（应答）**: 客户端收到服务器的 FIN 包后，发送一个设置了 ACK 标志位的 TCP 包，确认服务器的 FIN。

完成这四个步骤后，TCP 连接就完全关闭了。

![img](https://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116161802952-584681349.png)

https://www.cnblogs.com/liyuhui-Z/p/7844880.html

### HTTP连接过程

#### 1. DNS 解析

首先，浏览器会对目标服务器的域名进行 DNS（Domain Name System）解析，以获取其 IP 地址。

#### 2. 建立 TCP 连接

DNS 解析完成后，浏览器与服务器的 IP 地址建立一个 TCP 连接。这是通过 TCP 的三次握手过程（SYN, SYN-ACK, ACK）完成的。

#### 3. 发送 HTTP 请求

TCP 连接建立后，浏览器会通过该连接发送一个 HTTP 请求给服务器。HTTP 请求通常包括：

- 请求方法（GET、POST、PUT、DELETE 等）
- 目标 URL
- HTTP 版本
- 请求头（如 `User-Agent`, `Accept-Language` 等）
- 可选的请求体（主要用于 POST 和 PUT 请求）

#### 4. 服务器处理请求

服务器接收到 HTTP 请求后，会根据请求的类型和目标资源进行处理。这可能包括查询数据库、执行服务器端代码等。

#### 5. 发送 HTTP 响应

服务器处理完请求后，会发送一个 HTTP 响应回到客户端。HTTP 响应通常包括：

- HTTP 状态码（如 200 OK，404 Not Found 等）
- 响应头（如 `Content-Type`, `Cache-Control` 等）
- 响应体（返回的实际数据，如 HTML 文档、图像等）

#### 6. 渲染和显示

客户端（通常是浏览器）接收到 HTTP 响应后，会根据响应内容进行相应的处理。例如，如果返回的是一个 HTML 文档，浏览器会解析并渲染它。

#### 7. 关闭 TCP 连接

数据传输完成后，客户端和服务器可以选择关闭 TCP 连接，或者保持它以用于后续的请求和响应（HTTP/1.1 默认行为是保持连接）。关闭连接通常是通过发送 TCP FIN 包来完成的。



[^https://blog.csdn.net/qq_38289815/article/details/80969419]: 



## TCP



## **浏览器的渲染过程**

### DNS解析

- 浏览器首先需要知道目标服务器的IP地址。如果该地址不在本地DNS缓存中，浏览器或操作系统会发出一个DNS查询请求。



### TCP连接

- 浏览器与服务器建立一个TCP连接。这通常涉及一个“三次握手”过程。

  

### 发送HTTP请求

- TCP连接建立后，浏览器会通过该连接发送一个HTTP请求到服务器。这个请求包含了许多信息，如请求方法（GET、POST等）、headers、以及可能的请求体。



### 服务器处理请求

- 服务器收到HTTP请求后，会进行各种处理，这可能包括查询数据库、计算、身份验证等。



### 发送HTTP响应

- 处理完成后，服务器会创建一个HTTP响应，并通过TCP连接发送回浏览器。这个响应通常包含一个状态码（如200 OK）、响应头和响应体（通常是HTML文档）。



### 浏览器解析HTML

- 浏览器收到HTTP响应后，开始解析HTML代码，创建DOM（文档对象模型）。



### 资源加载和渲染

- 在解析HTML的同时，浏览器也会请求其他资源，如CSS、JavaScript文件和图片等。这些资源可能来自同一个服务器，也可能来自其他服务器。

  

### 执行JavaScript



### 页面渲染完成

- 当所有的资源都加载完成并且所有的JavaScript代码都被执行后，页面就算是完全渲染完成。

  

# 数据结构与算法







# Linux

**`ls`命令**

`ls`可能是每个Linux用户在其终端中键入的第一个命令。它允许您列出您想要的目录的内容（默认情况下是当前目录），包括文件和其他嵌套目录。

```bash
ls
```

它有很多选择，所以最好使用 `--help` 来获得一些帮助。此标志返回所有可以与 ls一起使用的flags参数。



**`alias`命令**

`alias`命令允许您在shell会话中定义临时别名。创建别名时，您指示shell用一系列命令替换单词。

例如，要设置 `ls` 为颜色而不每次键入标志 `--color`，您将使用：

```bash
alias ls="ls --color=auto"
```

正如你所看到的，`alias`命令需要一个关键值对参数：`alias NAME="VALUE"` .请注意，该值必须是使用引号。

如果你想列出你的shell会话中所有的别名，你可不使用argument运行命令`alias`。

```bash
alias
```



**`pwd`命令**

`pwd`命令代表“打印工作目录”，它输出您所在目录的绝对路径。例如，如果您的用户名是“john”，并且您位于文档目录中，则其绝对路径将是 `/home/john/Documents`.

要使用它，只需在终端中键入`pwd`：

```bash
pwd
# My result: /home/wbolt/Documents/linux-commands
```



# Git

### 初始化和配置

1. **`git init`**：在当前目录下初始化一个新的 Git 仓库。
2. **`git config`**: 用于设置 Git 配置信息。

### 克隆和远程操作

1. **`git clone [url]`**：克隆（复制）一个远程仓库到本地。
2. **`git remote`**: 用于管理远程仓库。
3. **`git fetch`**: 获取远程仓库的最新版本，但不合并。
4. **`git pull`**: 获取并合并远程仓库的最新版本。

### 文件和状态操作

1. **`git status`**: 显示工作目录和暂存区的状态。
2. **`git add [file]`**: 将文件添加到暂存区。
3. **`git rm [file]`**: 从版本控制中移除文件。

### 提交和历史

1. **`git commit`**: 提交暂存区的文件。
2. **`git log`**: 查看提交历史。
3. **`git revert`**: 回滚到之前的提交。

### 分支和标签

1. **`git branch`**: 列出、创建或删除分支。
2. **`git checkout [branch]`**: 切换到指定分支。
3. **`git merge [branch]`**: 将指定分支合并到当前分支。
4. **`git tag`**: 用于操作标签。

### 其他

1. **`git stash`**: 临时保存当前的修改。
2. **`git reset`**: 重置当前分支到某个状态。
3. **`git diff`**: 查看文件差异。





# 数据库

## SQL 语法

### 数据库

**1. 查看现有数据库**

```text
SHOW DATABASES;
```

**2. 新建数据库**

```text
CREATE DATABASE <数据库名>;
```

**3. 选择数据库**

```text
USE <数据库名>;
```

**4. 从`.sql`文件引入SQL语句**

```text
SOURCE <.sql文件路径>;
```

**5. 删除数据库**

```text
DROP DATABASE <数据库名>;
```

### 表

**6. 查看当前数据库中的表**

```text
SHOW TABLES;
```

![img](https://pic4.zhimg.com/80/v2-d7ddbd8950efe4a2a320f4684fa03c6f_1440w.webp)

**7. 创建新表**

```text
CREATE TABLE <表名> (
    <列名1> <列类型1>,
    <列名2> <列类型2>,
    <列名3> <列类型3>,
    PRIMARY KEY (<列名1>),
    FOREIGN KEY (<列名2>) REFERENCES <表名2>(<列名2>)
);
```

主键（`PRIMARY KEY`）用来标识一条记录（一行），所以每条记录的主键值必须是唯一的。主键可以定义在多列上，这称为**联合主键（composite primary key）**。

如果我们把表视作具有某种结构的数组（例如，C语言中的struct），那么外键（`FOREIGN KEY`）可以视作指针。

例子：

```text
CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2), 
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name));
```

在上面的例子中，我们创建了一个教员（`instructor`）表，该表的主键是ID，外键是教员所在的部门名称（`dept_name`），关联部门（`department`）表。此外，教员表还包括姓名（`name`）、薪水（`salary`）。其中，姓名有约束`NOT NULL`，表示姓名这一项不能为空。

**8. 概述表中的列**

使用如下语句查看表中的列的基本信息：

```text
DESCRIBE <表名>;
```

下图显示了一些例子：

![img](https://pic2.zhimg.com/80/v2-23727505d367e44a9c4d56d8df1f7509_1440w.webp)

**9. 在表中插入新纪录**

```text
INSERT INTO <表名> (<列名1>, <列名2>, <列名3>, …)
    VALUES (<值1>, <值2>, <值3>, …);
```

也可以省略列名（依序在所有列上插入新值）：

```text
INSERT INTO <表名>
    VALUES (<值1>, <值2>, <值3>, …);
```

**10. 在表中更新记录**

```text
UPDATE <表名>
    SET <列名1> = <值1>, <列名2> = <值2>, ...
    WHERE <条件>;
```

**11. 清空表**

```text
DELETE FROM <表名>;
```

**12. 删除表**

```text
DROP TABLE <表名>;
```



### 查询

**13. SELECT**

**SELECT**语句可以从表中选择数据：

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>;
```

以下语句选择所有内容：

```text
SELECT * FROM <表名>;
```

![img](https://pic3.zhimg.com/80/v2-7c3f80ef110ed423ae4fdbe53efe2726_1440w.webp)

选中department表和course表中的所有内容

**14. SELECT DISTINCT**

**SELECT DISTINCT**过滤掉了重复的值：

```text
SELECT DISTINCT <列名1>, <列名2>, …
    FROM <表名>;
```

![img](https://pic2.zhimg.com/80/v2-637855a8cc50ae2ca4c52b90e537cde1_1440w.webp)

**15. WHERE**

我们之前在更新记录时已经用到了**WHERE**关键字，用来指明条件。这里我们稍微详细一点地介绍下**WHERE**。

**WHERE**的条件通常是：

- 比较**文本（text）**
- 比较**数字（numbers）**
- **AND**、**OR**、**NOT**等逻辑运算

让我们来看一些例子：

```text
SELECT * FROM course WHERE dept_name='Comp. Sci.';
SELECT * FROM course WHERE credits>3;
SELECT * FROM course WHERE dept_name='Comp. Sci.' AND credits>3;
```

![img](https://pic4.zhimg.com/80/v2-ba65cae91c8a07113428dc700a77350b_1440w.webp)

**16. GROUP BY**

**GROUP BY**语句可以分组结果，常用于**COUNT**、**MAX**、**MIN**、**SUM**、**AVG**等**聚合函数（aggregate functions）**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    GROUP BY <列名>;
```

让我们来看一个例子，列出每个部门的课程数量：

```text
SELECT COUNT(course_id), dept_name 
     FROM course 
     GROUP BY dept_name;
```

![img](https://pic2.zhimg.com/80/v2-b98b02a2e727819e0bb393dd39ea6609_1440w.webp)

**17. HAVING**

乍看起来，**HAVING**和**WHERE**很像：

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    GROUP BY <列名x>
    HAVING <条件>;
```

那么，**HAVING**和**WHERE**有什么不同呢？让我们先来看一个例子，列出开了不止一门课程的部门开设的课程数：

```text
SELECT COUNT(course_id), dept_name 
    FROM course 
    GROUP BY dept_name 
    HAVING COUNT(course_id)>1;
```

这里**HAVING**不能换成**WHERE**，因为**WHERE**直接针对行操作，且在**GROUP BY**之前运行（即先通过**WHERE**筛选行，之后再将筛选出的行通过**GROUP BY**分组）。假设SQL中不存在**HAVING**语句，那么我们只能先新建一张表，将`COUNT(course_id)`作为新表的列，然后在新表上再通过**WHERE**进行筛选（当然，实际上SQL提供了派生表、CTE等机制，并不用真的手工建新表）。

![img](https://pic4.zhimg.com/80/v2-9822a7cdbae57d65986b8760be362e63_1440w.webp)

**18. ORDER BY**

**ORDER BY**可以对结果进行排序，在没有明确指定**ASC**（升序）或**DESC**（降序）的情况下，默认按升序排列。

```text
SELECT <列名1>, <列名2>, …
FROM <表名>
ORDER BY <列名1>, <列名2>, …, ASC|DESC;
```

例子：

```text
SELECT * FROM course ORDER BY credits;
SELECT * FROM course ORDER BY credits DESC;
```

![img](https://pic2.zhimg.com/80/v2-6671d510a7597957436428001436d695_1440w.webp)

**19. BETWEEN**

**BETWEEN**语句用于**指定区间**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名x> BETWEEN <值1> AND <值2>;
```

其中“值”可能是数字，文本，乃至日期等。

例如，列出薪资在50000和100000之间的教员：

```text
SELECT * FROM instructor 
    WHERE salary BETWEEN 50000 AND 100000;
```

![img](https://pic2.zhimg.com/80/v2-67fd4e97bdbac7493f10d0cea8270ba1_1440w.webp)

**20. LIKE**

**LIKE**用于匹配**文本中的特定模式**。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名x> LIKE <模式>;
```

模式中可以使用以下两个通配符：

- `%` （零个、一个或多个字符）
- `_` （单个字符）

例子：列出课程名中包含“to”的课程，以及课程ID以“CS-”开头的课程。

```text
SELECT * FROM course WHERE title LIKE '%to%';
SELECT * FROM course WHERE course_id LIKE 'CS-___';
```

![img](https://pic4.zhimg.com/80/v2-b79387e250a3df16e27e6046e4256b6b_1440w.webp)

**21. IN**

**IN**语句表示值属于某个集合。

```text
SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <列名n> IN (<值1>, <值2>, …);
```

例子：列出计算机科学、物理、电子工程部门的学生。

```text
SELECT * FROM student 
    WHERE dept_name IN ('Comp. Sci.', 'Physics', 'Elec. Eng.');
```

![img](https://pic4.zhimg.com/80/v2-e3aa7ceab577f85e8f1b0676f2ec45af_1440w.webp)

**22. JOIN**

**JOIN**用来组合两张以上表中的值。下图展示了**JOIN**的三种类型：



![img](https://pic3.zhimg.com/80/v2-f3f027a8b81ed884d5e77a4e989cb44e_1440w.webp)

图片来源：zeroturnaround.com

```text
SELECT <列名1>, <列名2>, …
    FROM <表名1>
    JOIN <表名2>
    ON <表名1.列名x> = <表名2.列名x>
```

让我们来看三个例子，分别对应三种**JOIN**的类型。

第一个例子，列出课程时包含开设课程的部门详情：

```text
SELECT * FROM course 
    JOIN department 
    ON course.dept_name=department.dept_name;
```

![img](https://pic4.zhimg.com/80/v2-29c046ddedee80e2fc617ff411e68503_1440w.webp)

第二个例子，列出所有具有前置课程的课程的详情：

```text
SELECT prereq.course_id, title, dept_name, credits, prereq_id 
    FROM prereq 
    LEFT OUTER JOIN course 
    ON prereq.course_id=course.course_id;
```

![img](https://pic3.zhimg.com/80/v2-8b5cca57797228d0cd5d132bc66aa2fa_1440w.webp)

最后一个例子，列出所有课程的详情，不管是否具有前置课程：

```text
SELECT course.course_id, title, dept_name, credits, prereq_id 
    FROM prereq 
    RIGHT OUTER JOIN course 
    ON prereq.course_id=course.course_id;
```

![img](https://pic3.zhimg.com/80/v2-4ca21be6eb7f2009ab3789554d4026ca_1440w.webp)

**23. 视图**

视图（view）是虚拟的SQL表。它包含行和列，和一般的SQL表格很类似。视图总是显示数据库中的最新数据。

**CREATE VIEW**

创建视图：

```text
CREATE VIEW <视图名> AS
    SELECT <列名1>, <列名2>, …
    FROM <表名>
    WHERE <条件>;
```

**DROP VIEW**

删除视图：

```text
DROP VIEW <视图名>;
```

例如，创建3学分的课程视图：

```text
CREATE VIEW my_view AS
    SELECT * FROM course
    WHERE credits=3;
```

![img](https://pic4.zhimg.com/80/v2-3581a7722415db9e97590892ef8452af_1440w.webp)

**24. 聚合函数**

我们之前已经提到聚合函数，这里列出最常用的一些聚合函数：

- **COUNT(列名)** 返回行数
- **SUM(列名)** 返回指定列的值之和
- **AVG(列名)** 返回指定列的平均值
- **MIN(列名)** 返回指定列的最小值
- **MAX(列名)** 返回指定列的最大值

**25. 嵌套子查询**

在SQL请求中，可以嵌套**SELECT-FROM-WHERE**表达式，称为**嵌套子查询（nested subqueries）**。

例如，查找2009年秋、2010年春都开的课程：

```text
SELECT DISTINCT course_id 
    FROM section 
    WHERE semester = ‘Fall’ AND year= 2009 AND course_id IN (
        SELECT course_id 
            FROM section 
            WHERE semester = ‘Spring’ AND year= 2010
    );
```

![img](https://pic1.zhimg.com/80/v2-e70916f1c617bafc28d1f2ab68e936a4_1440w.webp)



https://www.runoob.com/sql/sql-select.html



# 测试

## 通用测试用例八要素

![img](https://img-blog.csdnimg.cn/img_convert/fde5e8955b1c0d7366ea094708cd1fc6.png)　　<img src="https://img-blog.csdnimg.cn/da3dfbaa6b9441589dd178540d3552ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASVTlpbPlrak=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

**1、用例编号；**

> 一般是数字和字符组合成的字符串，可以包括（下划线、单词缩写、数字等等），但是需要注意的是，尽量不要写汉语拼音，因为拼音的意义可能有好几种，有可能会导致乱码； 
>
> 用例编号具有唯一性和易识别性。（ 比如说我们唯一标识一个人：中国-上海市-xx区xx号-xx楼--xx室-xxx.这样标识的话就具有唯一性了。)

　　不同阶段的测试用例的用例编号有不同的规则：
　　（1）系统测试用例：产品编号-ST-系统测试项名-系统测试子项名-XXX
　　（2）集成测试用例：产品编号-IT-系统测试项名-系统测试子项名-XXX
　　（3）单元测试用例：产品编号-UT-系统测试项名-系统测试子项名-XXX
　　**其中产品编号也叫项目标识，每个公司都有若干不同的项目或者产品，如何来区分它们呢？这就需要有产品编号了，每个公司都有自己的一套定义产品编号的规则，并且每个现有产品的编号已经制定好了，直接拿过来用就可以了。
　　**产品编号后的ST、IT、UT分别对应系统测试阶段、集成测试阶段、单元测试阶段。实际工作中有些公司会将产品编号以及测试阶段省略。
　　**测试阶段后面就是测试项目名了，对应的是较大较系统的测试点。
　　**测试项目名后面就是测试子项目名，有些测试是没有子项目名的，只有当测试项力度比较大的时候才会有成都市子项 （比如说：我们要测试用户能否成功登录这个功能，那我们就可以分为很多个子项，qq登录、邮箱登录等等）。
　	测试子项名后面就是具体的用例编号了，可以是数字：01、001、002等等。



　　**2、测试项目；**

（1）系统测试用例：对应一个功能点（功能测试）、性能指标（性能测试）、界面中控件（GUI测试）等等。
（2）集成测试用例：对应集成后的模块功能或者接口功能。
（3）单元测试用例：对应函数名。 



　　**3、测试标题；**

　　**4、重要级别；**

用例的重要级别一般分成三个级别：高、中、低。
高级别：对应保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例；
中级别：对应重要程度介于高和低之间的测试用例；
低级别：对应实际使用频率不高，对系统业务功能影响比较大的模块或功能的测试用例。



　　**5、预置条件；**

> 　 测试用例在执行前需要满足一些前提条件，否则测试用例是无法执行的，这些前提条件就是预置条件。

　　预置条件分为两种情况：
　　（1）环境的设置。
　　例如：测试word打开文件的功能，预置条件就是：需要提前准备被打开的文件；
　　例如：登录成功的预置条件就是：该用户名已经注册过了。
　　例如：购买商品成功的预置条件就是：后台已经配置好商品、发货区域、以及支付方式了。
　　（2）先要运行的其他用例，有些操作系统会比较复杂，如果都是从最开始的操作开始会导致用例写起来比较麻烦，这样可以在预置条件中设定要先运行的测试用例，后面的用例只需要写后续的操作就可以了。
　　例如：对自动取款机进行测试，有针对的输入账户信息的测试，有对输入取钱金额的测试，后者的预置条件就可以写成输入正确账户信息的测试用例。
　　注：具体预置条件的设置不同的公司会有自己的规定，比如有的公司是不允许第二种情况出现的。



　　**6、测试输入；**

测试输入是用于运行测试用例的具体数据或值。这些输入数据用于模拟不同的用户操作和场景。

- **示例**：

  - 用户名和密码用于登录测试。
  - 搜索关键词用于搜索功能测试。

- **重要性**：

  - 它们是产生预期结果的“触发器”。

  - 用于验证应用程序如何处理不同类型和范围的数据。

    

　　**7、操作步骤；**

明确描述测试执行过程中具体的操作步骤，以方便测试执行人员可以根据该操作步骤完成测试用例执行。

- **示例**：

  1. 打开应用程序。
  2. 在用户名字段中输入预定义的用户名。
  3. 在密码字段中输入预定义的密码。
  4. 点击“登录”按钮。

- **重要性**：

  - 提供了一种结构化的方式来执行测试，确保测试的一致性和可重复性。

  - 有助于准确地复现缺陷和问题。

    

　　**8、预期输出；**

> （1）界面显示：在操作步骤完成之后，界面会有显示；比如说我们测试用户登录功能，界面可能会显示登录成功或者登录失败。
>
> （2）数据库的变化：在操作步骤完成之后，数据库中的记录会发生相应的变化，比如删除功能的测试，点击删除后，数据库中该记录会被删除。
>
> （3）相关信息的变化：在操作步骤执行完成后，一些和被测对象相关的信息会发生变化，比如：注销功能的测试，点击注销后，以前能访问的页面将无法再访问。 



## 测试要点

![img](https://img-blog.csdn.net/20180505154820871)

## 软件测试类别

![img](https://img-blog.csdnimg.cn/20210919103511372.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57qi55uu6aaZ6Jaw,size_20,color_FFFFFF,t_70,g_se,x_16)



## 常用自动化测试工具

https://zhuanlan.zhihu.com/p/603190738

https://blog.csdn.net/weixin_44015669/article/details/121082810

**Selenium**--WebUI自动化测试

**Postman**--接口测试

Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。

**Jmeter**--性能测试

最初是为了测试Web应用程序而开发的

1. **模拟高负载**：JMeter 可以模拟多个用户同时访问一个服务，以测试该服务在高负载下的性能和稳定性。
2. **性能分析**：JMeter 不仅可以测试服务在极限负载下的性能，还可以分析服务在不同负载级别下的整体性能。



**Jenkins**

**Appium** -- AppUI自动化测试



## 软件测试开发流程



## 美团面试真题

### TCP/IP 协议栈

TCP/IP（传输控制协议/互联网协议）是一套用于计算机网络通信的协议族。这套协议定义了数据应如何封装、定址、传输和在目标接收。TCP/IP 协议栈通常被分为四层：

1. **应用层（Application Layer）**: 这一层包括了各种应用层协议，如HTTP、FTP、SMTP等。

2. **传输层（Transport Layer）**: 这里主要是TCP（传输控制协议）和UDP（用户数据报协议）。

3. **网络层（Internet Layer）**: 主要是IP协议，负责将数据包从源地址送达到目标地址。

4. **链路层（Link Layer）**: 这一层处理与本地网络接入相关的问题，例如以太网。

   

### TCP（传输控制协议）与 UDP（用户数据报协议）的区别

#### TCP

1. **面向连接**: 在数据传输之前需要先建立连接（三次握手）。
2. **可靠性高**: 提供数据传输的确认机制、错误恢复等。
3. **有序传输**: 数据报文段按照其发送顺序进行接收。
4. **拥塞控制**: 通过流量控制和拥塞控制机制，适应网络状态。
5. **速度较慢**: 由于上述特性，通常比UDP慢。
6. **重量级**: 由于保证可靠性和有序性，所以报头较大，消耗更多的CPU资源。

#### UDP

1. **无连接**: 不需要预先建立连接。

2. **可靠性低**: 不提供数据传输的确认机制。

3. **无序传输**: 数据报文段可能会乱序到达。

4. **无拥塞控制**: 速度快，但在网络拥塞时可能会丢包。

5. **速度较快**: 由于较少的检查和确认，通常比TCP快。

6. **轻量级**: 报头小，消耗较少的CPU资源。

   

### 应用场景

#### 适合使用TCP的场景

1. **文件传输**: 如FTP, HTTP，需要确保数据的完整性。
2. **电子邮件**: 如SMTP。
3. **远程登录**: 如SSH, Telnet。
4. **数据库操作**: 如MySQL。
5. **流媒体的可靠传输**: 如用于实时但需要可靠传输的WebRTC。

#### 适合使用UDP的场景

1. **实时应用**: 如VoIP，实时视频会议。

2. **广播和多播应用**: 如IPTV。

3. **快速交互**: 如DNS查询。

4. **在线游戏**: 对实时性要求高，允许少量丢包。

5. **流媒体的不可靠传输**: 如用于实时但可以容忍一定丢包的流媒体应用。

   

### 常用的排序算法

1. ### **冒泡排序（Bubble Sort）**

   #### 基本思路

   1. 遍历整个数组，比较相邻的两个元素，如果它们是逆序的，则交换它们。
   2. 重复这个过程，每次遍历少看一个元素。
   3. 如果一次遍历中没有发生任何交换，则数组已经是有序的，可以提前结束算法。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def bubble_sort(arr):
       n = len(arr)
       for i in range(n):
           swapped = False
           for j in range(0, n-i-1):
               if arr[j] > arr[j+1]:
                   arr[j], arr[j+1] = arr[j+1], arr[j]
                   swapped = True
           if not swapped:
               break
   ```

2. ### **归并排序（Merge Sort）**

   #### 基本思路

   1. 分：将原始数组分成两个或更多的空间。
   2. 解决：递归地将子数组排序。
   3. 合并（Merge）：将排序后的子数组合并，形成一个新的排序数组。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def merge_sort(arr):
       if len(arr) <= 1:
           return arr
       mid = len(arr) // 2
       left = arr[:mid]
       right = arr[mid:]
       return merge(merge_sort(left), merge_sort(right))
   ```

   

3. ### **快速排序（Quick Sort）**

   快速排序（Quick Sort）是一种被广泛应用的排序算法，由英国计算机科学家 Tony Hoare 在1960年提出。它是一种分治法（Divide and Conquer）的应用，能够在平均情况下实现 O(n log n) 的时间复杂度。下面是快速排序的基本思路和详细解释。

   **基本思路**

   1. **选取基准元素（Pivot）**: 在数组中选择一个元素作为基准。
   2. **分区（Partitioning）**: 重新排列数组，使得比基准元素小的元素在其左侧，比基准元素大的元素在其右侧。在这一过程中，基准元素到达其最终位置。
   3. **递归排序子数组**: 对基准元素左右两侧的子数组进行同样的操作。
   4. **结束条件**: 当子数组的大小为 0 或 1 时，该子数组已经是有序的，不需要进一步处理。

   **算法步骤**

   假设我们有一个数组 `arr = [3, 6, 8, 10, 1, 2, 1]`，并且我们选择最后一个元素作为基准元素。

   1. **选取基准元素**:
      - 我们选择 `1` 作为基准元素。
   2. **分区**:
      - 定义两个指针 `i` 和 `j`。其中，`i` 从数组的第一个元素开始，`j` 从数组的倒数第二个元素开始。
      - 遍历数组，使得所有小于 `1` 的元素都移到它的左侧，所有大于 `1` 的元素都移到它的右侧。
      - 例如，我们可能得到一个这样的数组：`[1, 1, 8, 10, 3, 6, 2]`。
      - 现在，基准元素 `1` 已经到达了它应该在的位置。
   3. **递归排序子数组**:
      - 对于基准元素左侧的子数组 `[1]` 和右侧的子数组 `[8, 10, 3, 6, 2]`，我们递归地进行快速排序。
   4. **结束条件**:
      - 当递归到数组大小为 0 或 1 时，递归结束。

   **代码示例（Python）**

   ```
   pythonCopy codedef quicksort(arr):
       if len(arr) <= 1:
           return arr
       pivot = arr[len(arr) // 2]
       left = [x for x in arr if x < pivot]
       middle = [x for x in arr if x == pivot]
       right = [x for x in arr if x > pivot]
       return quicksort(left) + middle + quicksort(right)
   
   print(quicksort([3, 6, 8, 10, 1, 2, 1]))
   ```

   **时间复杂度和空间复杂度**

   - 时间复杂度
     - 最好情况：O(n log n)
     - 平均情况：O(n log n)
     - 最坏情况：O(n^2)
   - **空间复杂度**: O(log n) 到 O(n)

   快速排序是不稳定的排序算法，但是它的优点是排序速度快，实现相对简单。希望这个解释有助于你更好地理解快速排序的工作原理。

4. ### **选择排序（Selection Sort）**

   **基本思路**

   1. 在未排序的部分找到最小（或最大）元素。
   2. 将该元素与未排序部分的第一个元素交换位置。

   **时间复杂度和空间复杂度**

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：不稳定

   **示例代码（Python）**

   ```
   pythonCopy codedef selection_sort(arr):
       for i in range(len(arr)):
           min_index = i
           for j in range(i+1, len(arr)):
               if arr[j] < arr[min_index]:
                   min_index = j
           arr[i], arr[min_index] = arr[min_index], arr[i]
   ```

5. ### **插入排序（Insertion Sort）**

   #### 基本思路

   1. 从第一个元素开始，该元素可以认为已经被排序。
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
   4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   pythonCopy codedef insertion_sort(arr):
       for i in range(1, len(arr)):
           key = arr[i]
           j = i - 1
           while j >= 0 and key < arr[j]:
               arr[j + 1] = arr[j]
               j -= 1
           arr[j + 1] = key
   ```



**如何判断链表里有环**

### 快慢指针法

该算法使用两个指针，一个快指针和一个慢指针。快指针每次移动两个节点，而慢指针每次移动一个节点。如果链表中存在环，快慢指针最终会在环内的某个节点相遇。



合并所有的重叠区间，合并后的区间按照升序排列



**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）



### 关系型数据库（RDBMS）

1. **表格存储**：数据存储在表中，表和表之间可能有关系。常见的关系型数据库包括MySQL, PostgreSQL, SQLite, Oracle等。

### 非关系型数据库（NoSQL）

1. **键值存储（Key-Value）**：如Redis, Amazon DynamoDB。适用于需要快速查找的简单数据。
2. **文档存储（Document-Oriented）**：如MongoDB, Couchbase。适用于JSON、XML等文档型的数据存储。
3. **列式存储（Column-Family Stores）**：如Cassandra, HBase。适用于大数据和实时分析。
4. **图形数据库（Graph Databases）**：如Neo4j, Amazon Neptune。适用于存储网络、社交网络、组织结构等复杂关系的数据。

### 其他

1. **对象存储**：用于存储复杂对象和其关系，例如Java的对象数据库。

2. **文件存储（File-based storage）**：例如CSV, XML文件，通常用于简单的应用或数据交换。

3. **内存数据库（In-memory databases）**：如Redis、Memcached，用于需要高速读写的场景。

4. **分布式数据库**：如CockroachDB、Google Spanner，用于确保数据分布在多个地点或集群上。

   

索引是数据库中用于提高数据检索效率的数据结构。通过使用索引，数据库系统可以比全表扫描更快地查找到数据。索引是一种用于快速查找数据的方法，它类似于书籍的目录。



**数据库左连接和右连接的区别**

### 左连接（LEFT JOIN）

- **基本思路**：左连接会返回左表（left table）中的所有记录和右表（right table）中匹配的记录。如果没有找到匹配的记录，则右表中的列会包含`NULL`。

### 右连接（RIGHT JOIN）

- **基本思路**：右连接会返回右表（right table）中的所有记录和左表（left table）中匹配的记录。如果没有找到匹配的记录，则左表的列会包含`NULL`。

  

**SQL，“在一列数据中，找出存在重复的数据”**

```
SELECT my_column, COUNT(*)
FROM my_table
GROUP BY my_column
HAVING COUNT(*) > 1;
```



### **针对一个用户登录页面的网页，你可以编写那些测试用例？**

#### 功能测试

1. **正常登录**：使用有效的用户名和密码进行登录。
2. **无效用户名和/或密码**：使用无效的用户名和密码，应显示错误消息。
3. **空白字段**：不填写用户名或密码或两者都不填写，应显示必填或错误消息。
4. **特殊字符支持**：检查是否可以在用户名和密码中使用特殊字符。
5. **大小写敏感性**：验证用户名和密码是否区分大小写。
6. **忘记密码**：测试忘记密码功能，是否能通过邮箱或手机等方式重置密码。
7. **会话超时**：验证长时间不活动后是否自动登出。

#### 安全性测试

1. **SQL注入**：确保应用程序不受SQL注入攻击的影响。

   假设一个简单的登录表单，后端代码用于检索用户信息可能如下：

   ```
   SELECT * FROM users WHERE username = '$username' AND password = '$password';
   ```

   在这里，`$username` 和 `$password` 是用户输入的内容。如果应用程序没有正确地处理这些输入，攻击者可以输入特殊的字符串来操纵SQL查询，例如：

   ```
   Username: admin' --
   Password: (任意值)
   ```

   这将使SQL查询变为：

   ```
   SELECT * FROM users WHERE username = 'admin' --' AND password = '(任意值)';
   ```

   由于 `--` 是SQL中的注释标记，所以查询的其余部分将被注释掉，这意味着只要用户名为 `admin` 的用户存在，查询就会成功，不管密码是否正确。

2. **XSS攻击**：确保没有跨站脚本（XSS）漏洞。

3. **多次错误尝试**：在多次连续错误登录尝试后，应限制用户尝试登录或触发验证码。

4. **数据传输安全**：确保密码和其他敏感信息在网络上传输时是加密的。

5. **密码安全策略**：检查是否实施了强密码策略。

#### 性能测试

1. **加载时间**：确保页面在不同网络环境下能快速加载。
2. **并发用户**：测试系统能否在多个用户同时登录的情况下保持稳定。

#### 用户体验测试

1. **响应式设计**：确保登录页面在不同大小和类型的设备上都能正常工作。
2. **错误消息**：确保所有错误消息都是清晰和用户友好的。
3. **字段焦点**：在输入错误后，焦点是否会自动移到错误字段。
4. **键盘快捷键**：例如，是否可以使用Enter键提交表单。



### Cookie和Session

**存储位置**

- **Cookie**：存储在客户端（浏览器）。这意味着每次发送HTTP请求时，浏览器都会自动附加与该站点相关的所有Cookie。
- **Session**：通常存储在服务器端。客户端存储一个与服务器端Session相关联的`Session ID`，通常这个`Session ID`是存储在Cookie中的。

**存储容量**

- **Cookie**：由于存储在客户端，因此存储空间有限，通常最大为4KB。
- **Session**：存储在服务器，通常没有存储限制。但是，存储大量数据可能会影响服务器性能。

**存储期限**

- **Cookie**：可以设置过期时间，如果不设置，生命周期则与浏览器会话（Session）同长，即关闭浏览器后消失。
- **Session**：在没有活动的情况下，Session会在一定时间后过期。这个时间是可以配置的。

**数据类型**

- **Cookie**：仅能存储文本信息。
- **Session**：可以存储各种类型的数据，如对象和数组。

**速度和效率**

- **Cookie**：由于每次HTTP请求都会带上Cookie，因此可能会影响性能，特别是当Cookie信息较多时。
- **Session**：由于存储在服务器端，不需要每次都传送，因此相对更高效。



### TCP四层协议

### 1. 应用层（Application Layer）

- **作用**：负责提供网络服务的接口，以便最终用户和应用程序可以交互。
- **常用协议**：
  - HTTP（超文本传输协议）
  - FTP（文件传输协议）
  - SMTP（简单邮件传输协议）
  - DNS（域名系统）

### 2. 传输层（Transport Layer）

- **作用**：负责端到端（即主机到主机）的数据传输和流量控制。它确保数据从源端到目的端可靠、有效地传输。
- **常用协议**：
  - TCP（传输控制协议）：提供可靠、面向连接的通信
  - UDP（用户数据报协议）：提供不可靠、无连接的通信

### 3. 网络层（Network Layer）

- **作用**：负责将数据包从源主机路由到目的主机。这一过程可能涉及多个网络和连接多个网络设备（如路由器、交换机等）。
- **常用协议**：
  - IP（互联网协议）
  - ICMP（互联网控制消息协议）
  - OSPF（开放最短路径优先）

### 4. 链路层（Link Layer）

- **作用**：负责将网络层传来的数据帧从一台机器传输到另一台机器，这通常是在同一局域网内或者在两台相邻网络设备之间。
- **常用协议/标准**：
  - Ethernet
  - Wi-Fi
  - ARP（地址解析协议）



### **回文串判断**

#### 1. 双指针法

- **步骤**：
  1. 初始化两个指针：一个在字符串的起始位置（`left`），一个在字符串的结束位置（`right`）。
  2. 比较两个指针所指向的字符是否相等。如果不相等，则该字符串不是回文串。
  3. 如果相等，将两个指针分别向中间移动，并重复步骤2。
  4. 当`left`大于等于`right`时，确认该字符串是回文串。
- **时间复杂度**：O(n)，其中n是字符串的长度。



### python浅拷贝（Shallow Copy）

1. 使用切片操作（只适用于列表和其他序列类型）。

   ```
   original_list = [1, [2, 3], 4]
   copied_list = original_list[:]
   ```

2. 使用 `copy` 模块的 `copy()` 函数。

   ```
   import copy
   copied_object = copy.copy(original_object)
   ```

3. 对于字典，可以使用 `dict.copy()` 方法。

   ```
   original_dict = {'a': 1, 'b': [2, 3]}
   copied_dict = original_dict.copy()
   ```

4. 对于集合，可以使用 `set.copy()` 方法。

   ```
   original_set = {1, 2, 3}
   copied_set = original_set.copy()
   ```



### python深拷贝（Deep Copy）

深拷贝会复制对象以及其包含的所有嵌套对象。这意味着，生成的新对象是原始对象的完全独立副本。

1. 使用 模块的  函数。

   ```
   deepcopy()
   ```

   ```
   import copy
   deep_copied_object = copy.deepcopy(original_object)
   ```

#### 深拷贝示例

```
import copy

original_list = [1, [2, 3], 4]
deep_copied_list = copy.deepcopy(original_list)

# 修改原始列表
original_list[0] = 0
original_list[1][0] = 0

# 输出两个列表
print("Original:", original_list)  # Output: [0, [0, 3], 4]
print("Deep Copied:", deep_copied_list)  # Output: [1, [2, 3], 4]
```



### 如果需要访问多个域名，那么可以如何节省网络消耗？

**DNS预解析（DNS Prefetch）**

预解析可以预先进行DNS查询，减少实际请求时的DNS解析时间。

```
<link rel="dns-prefetch" href="//example.com">
```

**预连接（Preconnect）**

预连接不仅会预解析DNS，还会预先进行TCP握手和TLS协商。

```
<link rel="preconnect" href="https://example.com">
```

**数据压缩**

使用Gzip或Brotli等压缩算法可以减少传输的数据量。

**使用HTTP/2或HTTP/3**

这些新版本的HTTP协议提供了多路复用、头部压缩等特性，可以减少网络消耗。

**使用持久连接（Keep-Alive）**

通过复用TCP连接，你可以减少TCP握手所需的时间和带宽。

**优化资源**

- **合并文件**：将多个小的CSS或JavaScript文件合并为一个大文件，以减少HTTP请求的数量。
- **异步加载**：对于非关键资源，可以使用异步加载来减少初始页面加载所需的时间。
- **懒加载**：对于例如图片这样的大资源，使用懒加载可以延迟加载直到用户实际需要。

**缓存**

充分利用浏览器缓存和服务器缓存可以减少重复请求，从而减少网络消耗。

**使用WebP格式**

对于图片，使用WebP等更高效的格式可以显著减少数据量。

**限制重定向**

尽量减少或避免使用重定向，因为每次重定向都会消耗额外的网络资源。