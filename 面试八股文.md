





# 设计模式

设计模式（Design Patterns）是软件工程中用来解决特定问题的一种优秀的解决方案模板。它们在很多领域，如深度学习、操作系统、和更一般的编程中，都有一定的应用。设计模式的主要目的是提供一种可重用的解决方案，以解决软件设计中常见的问题，从而提高代码的可维护性、可读性和可扩展性。

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）**: 单例模式（Singleton Pattern）是一种创建型设计模式，用于确保一个类只有一个实例，并提供一个全局点以访问这个实例。单例模式常用于需要全局访问点的场景，如数据库连接、日志记录对象或者配置管理。

   在单例模式的实现中，通常会：

   1. 私有化类的构造器，以防止外部通过`new`关键字创建多个实例。
   2. 创建一个私有静态成员变量，用于保存单一实例。
   3. 提供一个公共静态方法来获取这个唯一的实例。

2. **工厂方法模式（Factory Method）**: 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一个接口用于创建对象，但允许子类决定实例化哪个类。这使得类的实例化可以延迟到其子类。换句话说，工厂方法模式定义了一个创建对象的接口（通常是一个方法），但将选择具体要创建的类类型的责任推迟到子类中。

   工厂方法模式主要包括以下几个组件：

   1. **Creator（创建者）**: 包含返回 Product 类型对象的工厂方法。
   2. **ConcreteCreator（具体创建者）**: 实现 Creator 的工厂方法，返回一个 ConcreteProduct 实例。
   3. **Product（产品）**: 定义工厂方法所创建的对象的接口。
   4. **ConcreteProduct（具体产品）**: 实现 Product 接口。

   如何实现

   1. **定义一个返回对象（Product）的工厂接口（Creator）**。
   2. **创建实现该接口的具体类（ConcreteCreator），并实现工厂方法**。
   3. **客户端代码通过调用工厂方法获取对象，而无需直接实例化对象**。

   ```python
   from abc import ABC, abstractmethod
   
   # Product 类
   class Button(ABC):
   
       @abstractmethod
       def click(self):
           pass
   
   # ConcreteProduct 类
   class WindowsButton(Button):
       
       def click(self):
           print("Windows button clicked")
   
   class LinuxButton(Button):
       
       def click(self):
           print("Linux button clicked")
   
   # Creator 类
   class ButtonFactory(ABC):
       
       @abstractmethod
       def create_button(self):
           pass
   
   # ConcreteCreator 类
   class WindowsButtonFactory(ButtonFactory):
       
       def create_button(self):
           return WindowsButton()
   
   class LinuxButtonFactory(ButtonFactory):
       
       def create_button(self):
           return LinuxButton()
   
   # 客户端代码
   def button_client_code(factory):
       button = factory.create_button()
       button.click()
   
   # 使用
   windows_factory = WindowsButtonFactory()
   button_client_code(windows_factory)
   
   linux_factory = LinuxButtonFactory()
   button_client_code(linux_factory)
   
   ```

   

3. **抽象工厂模式（Abstract Factory）**: 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于提供一个接口以创建一系列相关或依赖的对象，而不需要指定它们具体的类。这个模式与工厂方法模式相似，但它是针对一个产品家族进行创建，而不是单一产品。

   **结构和组件**

   1. **AbstractFactory（抽象工厂）**: 声明了一个或多个抽象方法，用于创建一系列相关的产品。

   2. **ConcreteFactory（具体工厂）**: 实现抽象工厂中定义的方法，生产一组具体的产品。

   3. **AbstractProduct（抽象产品）**: 为一类产品对象声明一个接口。

   4. **ConcreteProduct（具体产品）**: 实现了抽象产品定义的接口，由具体工厂来创建。

      

      1. **定义抽象产品的接口（AbstractProduct）**。

      2. **创建实现该接口的具体产品（ConcreteProduct）**。

      3. **定义用于生产产品的抽象工厂接口（AbstractFactory）**。

      4. **创建实现该抽象工厂接口的具体工厂（ConcreteFactory）**。

      5. **使用具体工厂和抽象工厂来创建产品实例**。

         

      ```python
      from abc import ABC, abstractmethod
      
      # 抽象产品
      class Button(ABC):
          @abstractmethod
          def click(self):
              pass
      
      class Checkbox(ABC):
          @abstractmethod
          def check(self):
              pass
      
      # 具体产品
      class WindowsButton(Button):
          def click(self):
              print("Windows Button clicked")
      
      class WindowsCheckbox(Checkbox):
          def check(self):
              print("Windows Checkbox checked")
      
      class LinuxButton(Button):
          def click(self):
              print("Linux Button clicked")
      
      class LinuxCheckbox(Checkbox):
          def check(self):
              print("Linux Checkbox checked")
      
      # 抽象工厂
      class GUIFactory(ABC):
          @abstractmethod
          def create_button(self):
              pass
      
          @abstractmethod
          def create_checkbox(self):
              pass
      
      # 具体工厂
      class WindowsGUIFactory(GUIFactory):
          def create_button(self):
              return WindowsButton()
      
          def create_checkbox(self):
              return WindowsCheckbox()
      
      class LinuxGUIFactory(GUIFactory):
          def create_button(self):
              return LinuxButton()
      
          def create_checkbox(self):
              return LinuxCheckbox()
      
      # 客户端代码
      def client_code(factory):
          button = factory.create_button()
          checkbox = factory.create_checkbox()
          
          button.click()
          checkbox.check()
      
      # 使用
      windows_factory = WindowsGUIFactory()
      client_code(windows_factory)
      
      linux_factory = LinuxGUIFactory()
      client_code(linux_factory)
      
      ```

      

4. **简单工厂模式和抽象工厂模式的区别**

   **负责创建的对象种类**

   - **简单工厂方法模式**: 通常用于创建一种类型的对象。它定义一个方法用于创建对象，这个方法通常包含一个条件判断语句，根据参数或某种设置返回不同的对象实例。
   - **抽象工厂模式**: 负责创建一系列（或一组，一套）相关或相互依赖的对象。它提供了多个工厂方法，每个工厂方法负责创建一个特定类型的对象。

   **接口和实现**

   - **简单工厂方法模式**: 通常只有一个工厂类（不是接口），该类有一个方法用于创建对象。
   - **抽象工厂模式**: 包含一个或多个抽象工厂接口，以及实现这些接口的具体工厂类。

   **扩展性**

   - **简单工厂方法模式**: 如果需要添加新的产品类型，需要修改工厂类的代码，这违反了开放/封闭原则。
   - **抽象工厂模式**: 更易于扩展。如果需要添加新的产品或产品族，只需添加新的具体工厂和相应的产品接口和实现，无需修改现有代码。

   **使用场景**

   - **简单工厂方法模式**: 更适用于创建单一、简单或不相互依赖的对象。

   - **抽象工厂模式**: 更适用于创建一组相互依赖或具有共同主题的对象。

     

### 结构型模式（Structural Patterns）

1. **适配器模式（Adapter）**: 允许不兼容的接口可以一起工作。
2. **装饰器模式（Decorator）**: 在不改变对象本身的基础上，动态地添加额外的功能。
3. **组合模式（Composite）**: 将对象组合成树形结构以表示“部分-整体”的层次结构。

### 行为型模式（Behavioral Patterns）

1. **观察者模式（Observer）**: 当一个对象的状态发生变化时，其依赖者都会得到通知。
2. **策略模式（Strategy）**: 定义一系列算法，并将每一个算法封装起来，使它们可以互相替换。
3. **命令模式（Command）**: 将请求封装成一个对象，从而允许用户用不同的请求对客户进行参数化。



# Git

### 初始化和配置

1. **`git init`**：在当前目录下初始化一个新的 Git 仓库。
2. **`git config`**: 用于设置 Git 配置信息。

### 克隆和远程操作

1. **`git clone [url]`**：克隆（复制）一个远程仓库到本地。
2. **`git remote`**: 用于管理远程仓库。
3. **`git fetch`**: 获取远程仓库的最新版本，但不合并。
4. **`git pull`**: 获取并合并远程仓库的最新版本。

### 文件和状态操作

1. **`git status`**: 显示工作目录和暂存区的状态。
2. **`git add [file]`**: 将文件添加到暂存区。
3. **`git rm [file]`**: 从版本控制中移除文件。

### 提交和历史

1. **`git commit`**: 提交暂存区的文件。
2. **`git log`**: 查看提交历史。
3. **`git revert`**: 回滚到之前的提交。

### 分支和标签

1. **`git branch`**: 列出、创建或删除分支。
2. **`git checkout [branch]`**: 切换到指定分支。
3. **`git merge [branch]`**: 将指定分支合并到当前分支。
4. **`git tag`**: 用于操作标签。

### 其他

1. **`git stash`**: 临时保存当前的修改。
2. **`git reset`**: 重置当前分支到某个状态。
3. **`git diff`**: 查看文件差异。



# 测试

## 通用测试用例八要素

![img](https://img-blog.csdnimg.cn/img_convert/fde5e8955b1c0d7366ea094708cd1fc6.png)　　<img src="https://img-blog.csdnimg.cn/da3dfbaa6b9441589dd178540d3552ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASVTlpbPlrak=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

**1、用例编号；**

> 一般是数字和字符组合成的字符串，可以包括（下划线、单词缩写、数字等等），但是需要注意的是，尽量不要写汉语拼音，因为拼音的意义可能有好几种，有可能会导致乱码； 
>
> 用例编号具有唯一性和易识别性。（ 比如说我们唯一标识一个人：中国-上海市-xx区xx号-xx楼--xx室-xxx.这样标识的话就具有唯一性了。)

　　不同阶段的测试用例的用例编号有不同的规则：
　　（1）系统测试用例：产品编号-ST-系统测试项名-系统测试子项名-XXX
　　（2）集成测试用例：产品编号-IT-系统测试项名-系统测试子项名-XXX
　　（3）单元测试用例：产品编号-UT-系统测试项名-系统测试子项名-XXX
　　**其中产品编号也叫项目标识，每个公司都有若干不同的项目或者产品，如何来区分它们呢？这就需要有产品编号了，每个公司都有自己的一套定义产品编号的规则，并且每个现有产品的编号已经制定好了，直接拿过来用就可以了。
　　**产品编号后的ST、IT、UT分别对应系统测试阶段、集成测试阶段、单元测试阶段。实际工作中有些公司会将产品编号以及测试阶段省略。
　　**测试阶段后面就是测试项目名了，对应的是较大较系统的测试点。
　　**测试项目名后面就是测试子项目名，有些测试是没有子项目名的，只有当测试项力度比较大的时候才会有成都市子项 （比如说：我们要测试用户能否成功登录这个功能，那我们就可以分为很多个子项，qq登录、邮箱登录等等）。
　	测试子项名后面就是具体的用例编号了，可以是数字：01、001、002等等。



　　**2、测试项目；**

（1）系统测试用例：对应一个功能点（功能测试）、性能指标（性能测试）、界面中控件（GUI测试）等等。
（2）集成测试用例：对应集成后的模块功能或者接口功能。
（3）单元测试用例：对应函数名。 



　　**3、测试标题；**

　　**4、重要级别；**

用例的重要级别一般分成三个级别：高、中、低。
高级别：对应保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例；
中级别：对应重要程度介于高和低之间的测试用例；
低级别：对应实际使用频率不高，对系统业务功能影响比较大的模块或功能的测试用例。



　　**5、预置条件；**

> 　 测试用例在执行前需要满足一些前提条件，否则测试用例是无法执行的，这些前提条件就是预置条件。

　　预置条件分为两种情况：
　　（1）环境的设置。
　　例如：测试word打开文件的功能，预置条件就是：需要提前准备被打开的文件；
　　例如：登录成功的预置条件就是：该用户名已经注册过了。
　　例如：购买商品成功的预置条件就是：后台已经配置好商品、发货区域、以及支付方式了。
　　（2）先要运行的其他用例，有些操作系统会比较复杂，如果都是从最开始的操作开始会导致用例写起来比较麻烦，这样可以在预置条件中设定要先运行的测试用例，后面的用例只需要写后续的操作就可以了。
　　例如：对自动取款机进行测试，有针对的输入账户信息的测试，有对输入取钱金额的测试，后者的预置条件就可以写成输入正确账户信息的测试用例。
　　注：具体预置条件的设置不同的公司会有自己的规定，比如有的公司是不允许第二种情况出现的。



　　**6、测试输入；**

测试输入是用于运行测试用例的具体数据或值。这些输入数据用于模拟不同的用户操作和场景。

- **示例**：

  - 用户名和密码用于登录测试。
  - 搜索关键词用于搜索功能测试。

- **重要性**：

  - 它们是产生预期结果的“触发器”。

  - 用于验证应用程序如何处理不同类型和范围的数据。

    

　　**7、操作步骤；**

明确描述测试执行过程中具体的操作步骤，以方便测试执行人员可以根据该操作步骤完成测试用例执行。

- **示例**：

  1. 打开应用程序。
  2. 在用户名字段中输入预定义的用户名。
  3. 在密码字段中输入预定义的密码。
  4. 点击“登录”按钮。

- **重要性**：

  - 提供了一种结构化的方式来执行测试，确保测试的一致性和可重复性。

  - 有助于准确地复现缺陷和问题。

    

　　**8、预期输出；**

> （1）界面显示：在操作步骤完成之后，界面会有显示；比如说我们测试用户登录功能，界面可能会显示登录成功或者登录失败。
>
> （2）数据库的变化：在操作步骤完成之后，数据库中的记录会发生相应的变化，比如删除功能的测试，点击删除后，数据库中该记录会被删除。
>
> （3）相关信息的变化：在操作步骤执行完成后，一些和被测对象相关的信息会发生变化，比如：注销功能的测试，点击注销后，以前能访问的页面将无法再访问。 



## 测试要点

![img](https://img-blog.csdn.net/20180505154820871)

## 软件测试类别

![img](https://img-blog.csdnimg.cn/20210919103511372.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57qi55uu6aaZ6Jaw,size_20,color_FFFFFF,t_70,g_se,x_16)



## 常用自动化测试工具

https://zhuanlan.zhihu.com/p/603190738

https://blog.csdn.net/weixin_44015669/article/details/121082810

**Selenium**--WebUI自动化测试

**Postman**--接口测试

Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。

**Jmeter**--性能测试

最初是为了测试Web应用程序而开发的

1. **模拟高负载**：JMeter 可以模拟多个用户同时访问一个服务，以测试该服务在高负载下的性能和稳定性。
2. **性能分析**：JMeter 不仅可以测试服务在极限负载下的性能，还可以分析服务在不同负载级别下的整体性能。

**Jenkins**

**Appium** -- AppUI自动化测试



## 软件测试开发流程



## 美团面试真题

### 常用的排序算法

1. ### **冒泡排序（Bubble Sort）**

   #### 基本思路

   1. 遍历整个数组，比较相邻的两个元素，如果它们是逆序的，则交换它们。
   2. 重复这个过程，每次遍历少看一个元素。
   3. 如果一次遍历中没有发生任何交换，则数组已经是有序的，可以提前结束算法。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def bubble_sort(arr):
       n = len(arr)
       for i in range(n):
           swapped = False
           for j in range(0, n-i-1):
               if arr[j] > arr[j+1]:
                   arr[j], arr[j+1] = arr[j+1], arr[j]
                   swapped = True
           if not swapped:
               break
   ```

2. ### **归并排序（Merge Sort）**

   #### 基本思路

   1. 分：将原始数组分成两个或更多的空间。
   2. 解决：递归地将子数组排序。
   3. 合并（Merge）：将排序后的子数组合并，形成一个新的排序数组。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```python
   def merge_sort(arr):
       # 如果数组长度小于或等于 1，那么它已经是有序的
       if len(arr) <= 1:
           return arr
       
       # 计算中点并分割数组为两个子数组
       mid = len(arr) // 2
       left_half = arr[:mid]
       right_half = arr[mid:]
       
       # 递归地对两个子数组进行排序
       sorted_left = merge_sort(left_half)
       sorted_right = merge_sort(right_half)
       
       # 将两个已排序的子数组进行归并
       return merge(sorted_left, sorted_right)
   
   def merge(left, right):
       result = []
       i = j = 0
       
       # 比较 left 和 right 数组中的元素，并添加到结果数组中
       while i < len(left) and j < len(right):
           if left[i] < right[j]:
               result.append(left[i])
               i += 1
           else:
               result.append(right[j])
               j += 1
       
       # 如果 left 数组还有剩余元素，将其添加到结果数组中
       while i < len(left):
           result.append(left[i])
           i += 1
       
       # 如果 right 数组还有剩余元素，将其添加到结果数组中
       while j < len(right):
           result.append(right[j])
           j += 1
       
       return result
   
   # 测试归并排序函数
   if __name__ == "__main__":
       arr = [38, 27, 43, 3, 9, 82, 10]
       sorted_arr = merge_sort(arr)
       print("Sorted Array:", sorted_arr)
   
   ```

   

3. ### **快速排序（Quick Sort）**

   快速排序（Quick Sort）是一种被广泛应用的排序算法，由英国计算机科学家 Tony Hoare 在1960年提出。它是一种分治法（Divide and Conquer）的应用，能够在平均情况下实现 O(n log n) 的时间复杂度。下面是快速排序的基本思路和详细解释。

   **基本思路**

   1. **选取基准元素（Pivot）**: 在数组中选择一个元素作为基准。
   2. **分区（Partitioning）**: 重新排列数组，使得比基准元素小的元素在其左侧，比基准元素大的元素在其右侧。在这一过程中，基准元素到达其最终位置。
   3. **递归排序子数组**: 对基准元素左右两侧的子数组进行同样的操作。
   4. **结束条件**: 当子数组的大小为 0 或 1 时，该子数组已经是有序的，不需要进一步处理。

   **算法步骤**

   假设我们有一个数组 `arr = [3, 6, 8, 10, 1, 2, 1]`，并且我们选择最后一个元素作为基准元素。

   1. **选取基准元素**:
      - 我们选择 `1` 作为基准元素。
   2. **分区**:
      - 定义两个指针 `i` 和 `j`。其中，`i` 从数组的第一个元素开始，`j` 从数组的倒数第二个元素开始。
      - 遍历数组，使得所有小于 `1` 的元素都移到它的左侧，所有大于 `1` 的元素都移到它的右侧。
      - 例如，我们可能得到一个这样的数组：`[1, 1, 8, 10, 3, 6, 2]`。
      - 现在，基准元素 `1` 已经到达了它应该在的位置。
   3. **递归排序子数组**:
      - 对于基准元素左侧的子数组 `[1]` 和右侧的子数组 `[8, 10, 3, 6, 2]`，我们递归地进行快速排序。
   4. **结束条件**:
      - 当递归到数组大小为 0 或 1 时，递归结束。

   **代码示例（Python）**

   ```python
   def quick_sort(arr, low, high):
       if low < high:
           # 找到基准元素后的正确位置
           pivot_index = partition(arr, low, high)
           
           # 递归地对基准元素左边和右边的子数组进行快速排序
           quick_sort(arr, low, pivot_index - 1)
           quick_sort(arr, pivot_index + 1, high)
   
   def partition(arr, low, high):
       # 选择最右侧的元素作为基准
       pivot = arr[high]
       i = low - 1
       
       # 将小于基准的元素移动到基准的左侧
       for j in range(low, high):
           if arr[j] < pivot:
               i += 1
               arr[i], arr[j] = arr[j], arr[i]
               
       # 将基准元素移动到正确的位置
       arr[i + 1], arr[high] = arr[high], arr[i + 1]
       return i + 1
   
   # 测试快速排序函数
   if __name__ == "__main__":
       arr = [10, 7, 8, 9, 1, 5]
       n = len(arr)
       quick_sort(arr, 0, n - 1)
       print("Sorted array:", arr)
   
   ```

   **时间复杂度和空间复杂度**

   - 时间复杂度
     - 最好情况：O(n log n)
     - 平均情况：O(n log n)
     - 最坏情况：O(n^2)
   - **空间复杂度**: O(log n) 到 O(n)

   快速排序是不稳定的排序算法，但是它的优点是排序速度快，实现相对简单。希望这个解释有助于你更好地理解快速排序的工作原理。

   

4. ### **选择排序（Selection Sort）**

   **基本思路**

   选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每次从未排序的元素中找出最小（或最大）元素，将其存放到序列的起始（或末尾）位置。这样，每次迭代后，最小（或最大）元素就被放到了它最终排序后应处于的位置。该过程会持续进行，直到所有元素都被正确排序。

   **时间复杂度和空间复杂度**

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：不稳定

   **示例代码（Python）**

   ```python
   def selection_sort(arr):
       n = len(arr)
       
       # 遍历整个数组
       for i in range(n):
           # 找到从当前位置到数组末尾的最小元素的索引
           min_index = i
           for j in range(i + 1, n):
               if arr[j] < arr[min_index]:
                   min_index = j
                   
           # 交换找到的最小元素和当前位置的元素
           arr[i], arr[min_index] = arr[min_index], arr[i]
   
   # 测试选择排序函数
   if __name__ == "__main__":
       arr = [64, 25, 12, 22, 11]
       selection_sort(arr)
       print("Sorted array:", arr)
   
   ```

5. ### **插入排序（Insertion Sort）**

   #### 基本思路

   1. 从第一个元素开始，该元素可以认为已经被排序。
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
   4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。

   #### 时间复杂度和空间复杂度

   - 时间复杂度：O(n^2)
   - 空间复杂度：O(1)
   - 稳定性：稳定

   #### 示例代码（Python）

   ```
   def insertion_sort(arr):
       for i in range(1, len(arr)):
           key = arr[i]
           j = i - 1
           while j >= 0 and key < arr[j]:
               arr[j + 1] = arr[j]
               j -= 1
           arr[j + 1] = key
   ```

### **合并所有的重叠区间，合并后的区间按照升序排列** 

合并所有重叠区间并按照升序排列是一个经典的算法问题，通常用于间隔调度、时间表生成等场景。这个问题的解决方法一般分为以下几个步骤：

**步骤：**

1. **排序**：首先对给定的区间按照起始点进行排序。

2. **初始化**：将第一个区间添加到结果列表中。

3. 合并

   ：遍历其余的区间，与结果列表中最后一个区间进行比较，看是否有重叠。

   - 如果有重叠，合并它们。
   - 如果没有重叠，直接将当前区间添加到结果列表中。

4. **输出**：返回合并后的结果列表。

**Python 代码示例：**

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    
    # 按区间的起始点进行排序
    intervals.sort(key=lambda x: x[0])
    
    # 初始化结果列表，并将第一个区间添加进去
    result = [intervals[0]]
    
    # 遍历剩下的区间
    for current in intervals[1:]:
        # 获取结果列表中最后一个区间
        last = result[-1]
        
        # 检查当前区间和最后一个区间是否有重叠
        if current[0] <= last[1]:
            # 合并两个重叠的区间
            result[-1] = [last[0], max(last[1], current[1])]
        else:
            # 如果没有重叠，直接添加到结果列表中
            result.append(current)
    
    return result

# 测试代码
if __name__ == "__main__":
    intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
    print("Merged intervals:", merge_intervals(intervals))
```

运行这段代码后，输出的合并后的区间应该是 `[[1, 6], [8, 10], [15, 18]]`。

这个算法的时间复杂度是 O*(*n*log*n*)，主要消耗在排序步骤上。空间复杂度则为 O*(*n*)，用于存储结果列表。



### **如何判断链表里有环**

#### 快慢指针法

该算法使用两个指针，一个快指针和一个慢指针。快指针每次移动两个节点，而慢指针每次移动一个节点。如果链表中存在环，快慢指针最终会在环内的某个节点相遇。



**快慢指针法的终止条件：**

该算法有两个主要的终止条件：

1. **相遇条件**：如果快指针和慢指针在链表中的某个点相遇，这意味着链表存在环。
2. **空指针条件**：如果快指针或其下一个节点成为空指针（`None`），这意味着链表没有环。

**Python 代码示例：**

下面是使用 Python 定义一个简单的链表节点和使用快慢指针法检测链表中是否存在环的代码：

```
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    # 初始化慢指针和快指针
    slow = head
    fast = head
    
    while fast is not None and fast.next is not None:
        # 慢指针移动一步
        slow = slow.next
        # 快指针移动两步
        fast = fast.next.next
        
        # 检查快慢指针是否相遇
        if slow == fast:
            return True  # 存在环
    
    return False  # 不存在环

# 创建一个没有环的链表
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

# 测试函数
print("Has cycle:", has_cycle(head))  # 输出应为 False

# 创建一个有环的链表
head.next.next.next = head

# 测试函数
print("Has cycle:", has_cycle(head))  # 输出应为 True
```

在这个示例中，`ListNode` 类用于创建链表节点，`has_cycle` 函数则用于检测链表是否包含环。我们首先创建一个没有环的链表进行测试，然后修改链表以形成一个环，并再次进行测试。

这种使用快慢指针的方法时间复杂度为 O*(*n*)，其中 n 是链表中的节点数。空间复杂度为 O*(1)，因为我们只使用了两个指针。



### 操作系统八股文

**什么是进程？进程通信方法有哪些？**（进程——OS分配资源的最小单位，程序在系统中运行的载体，有PCB和堆内存栈内存等，开销大；线程——CPU调度的最小单位，进程中可以有多个线程，只有几个寄存器和一些资源，开销小；管道通信，共享内存，内存映射，消息队列等）



**什么是死锁，避免死锁的方法？**（在资源互斥和竞争中可能出现的问题，举例子——互斥锁加锁两次、两个进程相互请求对方已拥有的资源；避免死锁——增加系统资源、银行家算法等）



### **针对一个用户登录页面的网页，你可以编写那些测试用例？**

#### 功能测试

1. **正常登录**：使用有效的用户名和密码进行登录。
2. **无效用户名和/或密码**：使用无效的用户名和密码，应显示错误消息。
3. **空白字段**：不填写用户名或密码或两者都不填写，应显示必填或错误消息。
4. **特殊字符支持**：检查是否可以在用户名和密码中使用特殊字符。
5. **大小写敏感性**：验证用户名和密码是否区分大小写。
6. **忘记密码**：测试忘记密码功能，是否能通过邮箱或手机等方式重置密码。
7. **会话超时**：验证长时间不活动后是否自动登出。

#### 安全性测试

1. **SQL注入**：确保应用程序不受SQL注入攻击的影响。

   假设一个简单的登录表单，后端代码用于检索用户信息可能如下：

   ```
   SELECT * FROM users WHERE username = '$username' AND password = '$password';
   ```

   在这里，`$username` 和 `$password` 是用户输入的内容。如果应用程序没有正确地处理这些输入，攻击者可以输入特殊的字符串来操纵SQL查询，例如：

   ```
   Username: admin' --
   Password: (任意值)
   ```

   这将使SQL查询变为：

   ```
   SELECT * FROM users WHERE username = 'admin' --' AND password = '(任意值)';
   ```

   由于 `--` 是SQL中的注释标记，所以查询的其余部分将被注释掉，这意味着只要用户名为 `admin` 的用户存在，查询就会成功，不管密码是否正确。

2. **XSS攻击**：确保没有跨站脚本（XSS）漏洞。

3. **多次错误尝试**：在多次连续错误登录尝试后，应限制用户尝试登录或触发验证码。

4. **数据传输安全**：确保密码和其他敏感信息在网络上传输时是加密的。

5. **密码安全策略**：检查是否实施了强密码策略。

#### 性能测试

1. **加载时间**：确保页面在不同网络环境下能快速加载。
2. **并发用户**：测试系统能否在多个用户同时登录的情况下保持稳定。

#### 用户体验测试

1. **响应式设计**：确保登录页面在不同大小和类型的设备上都能正常工作。
2. **错误消息**：确保所有错误消息都是清晰和用户友好的。
3. **字段焦点**：在输入错误后，焦点是否会自动移到错误字段。
4. **键盘快捷键**：例如，是否可以使用Enter键提交表单。



### **回文串判断**

#### 1. 双指针法

- **步骤**：
  1. 初始化两个指针：一个在字符串的起始位置（`left`），一个在字符串的结束位置（`right`）。
  2. 比较两个指针所指向的字符是否相等。如果不相等，则该字符串不是回文串。
  3. 如果相等，将两个指针分别向中间移动，并重复步骤2。
  4. 当`left`大于等于`right`时，确认该字符串是回文串。
- **时间复杂度**：O(n)，其中n是字符串的长度。



### 如果需要访问多个域名，那么可以如何节省网络消耗？

**DNS预解析（DNS Prefetch）**

预解析可以预先进行DNS查询，减少实际请求时的DNS解析时间。

```
<link rel="dns-prefetch" href="//example.com">
```

**预连接（Preconnect）**

预连接不仅会预解析DNS，还会预先进行TCP握手和TLS协商。

```
<link rel="preconnect" href="https://example.com">
```

**数据压缩**

使用Gzip或Brotli等压缩算法可以减少传输的数据量。

**使用HTTP/2或HTTP/3**

这些新版本的HTTP协议提供了多路复用、头部压缩等特性，可以减少网络消耗。

**使用持久连接（Keep-Alive）**

通过复用TCP连接，你可以减少TCP握手所需的时间和带宽。

**优化资源**

- **合并文件**：将多个小的CSS或JavaScript文件合并为一个大文件，以减少HTTP请求的数量。
- **异步加载**：对于非关键资源，可以使用异步加载来减少初始页面加载所需的时间。
- **懒加载**：对于例如图片这样的大资源，使用懒加载可以延迟加载直到用户实际需要。

**缓存**

充分利用浏览器缓存和服务器缓存可以减少重复请求，从而减少网络消耗。

**限制重定向**

尽量减少或避免使用重定向，因为每次重定向都会消耗额外的网络资源。



### 接口测试

#### 接口文档分析

接口文档一般是由后端开发提供，可以是在线的swagger也可以是word。

![img](https://pic2.zhimg.com/80/v2-f7e9e8a489498c0c878cb83d9d885df9_1440w.webp)

####  **接口信息五要素**

**1）接口地址url：**

http-请求协议，api.lemonban.com-域名或ip，8765-端口号，/futureloan/member/register-资源路径

**2）请求方法：**

看开发定义的请求方法是什么，测试就对应用什么方法。restful风格中常见的请求方法为post、get、put、patch、delete等

**3）请求头：**

发送请求到服务器，包含的头部信息。常见的content-type。

**4）请求体：**

发送请求到服务器，具体传递的数据。例如要完成注册接口的调用，请求体包含手机号mobile_phone、密码pwd、用户名reg_name、验证码verification_code。

**5）响应内容：**

接口文档中描述的响应内容，与接口测试的实际结果做比较，可以判断当前接口是否通过。响应内容包含：响应码-http状态码、响应头、响应体。



#### 接口用例设计

接口用例设计跟功能测试思维相通，需要：

1）清楚项目业务

 2）运用用例设计8大方法：等价类、边界值、场景法、因果图、判定表、正交试验法、状态迁移法、错误推测法。

**1. 等价类划分（Equivalence Class Partitioning）**

**目的**：简化测试用例的数量，同时保持测试的有效性。

**步骤**：

1. 识别输入参数和它们的值范围。
2. 划分等价类：有效等价类和无效等价类。
3. 为每个等价类设计一个或几个测试用例。

**例子**：测试年龄输入字段，接受18-60岁。有效等价类：[18, 60]，无效等价类：小于18和大于60。

**2. 边界值分析（Boundary Value Analysis）**

**目的**：测试输入或输出边界条件。

**步骤**：

1. 确定输入或输出边界。
2. 设计测试用例，包括边界值。

**例子**：使用年龄18、19、59、60作为测试用例。

**3. 场景法（Scenario Testing）**

**目的**：模拟真实世界的情况。

**步骤**：

1. 理解用户如何使用系统。
2. 根据实际使用场景设计测试用例。

**4. 因果图（Cause-Effect Graphing）**

**目的**：识别输入和输出之间的依赖关系。

**步骤**：

1. 列出所有可能的输入条件（因）和输出结果（果）。
2. 绘制因果图。
3. 生成测试用例。

**5. 判定表（Decision Table）**

**目的**：处理复杂的业务规则。

**步骤**：

1. 确定输入和输出变量。
2. 构建判定表。
3. 根据判定表生成测试用例。

**6. 正交试验法（Orthogonal Array Testing）**

**目的**：在多变量系统中找出最优的测试组合。

**步骤**：

1. 确定要测试的变量和它们的可能值。
2. 使用正交数组来确定测试组合。

**7. 状态迁移法（State Transition Testing）**

**目的**：测试系统在不同状态间的行为。

**步骤**：

1. 确定系统的各种状态。
2. 确定从一个状态到另一个状态的转换。
3. 设计测试用例以覆盖所有可能的状态转换。

**8. 错误推测法（Error Guessing）**

**目的**：基于经验和直觉来设计测试用例。

**步骤**：

1. 根据之前的缺陷或常见的错误模式来推测可能的错误。

2. 设计针对这些错误的测试用例。

   

以下是接口用例模板参考：

![img](https://pic2.zhimg.com/80/v2-71755a986c543385af8e1aac3897d7d9_1440w.webp)



#### 发现bug、定位、提交并跟踪

怎么判断是否是bug呢？

1）接口测试中响应结果错误，返回了错误的code码、msg信息：

- 判断请求：请求地址、方式、请求头、请求正文是否正确，如果不正确则修改对应请求信息再做发送；如果正确，则说明是服务器端问题
- 进一步查看服务器日志、数据库信息，并整理信息提交bug

2）接口测试中响应结果，code码、msg正确，但返回的data数据不正确：

- 查看数据库数据正确完整性，并结合服务器日志，整理信息提交bug

3）接口测试中响应结果正确，但若是增删改业务操作：

- 需进一步确认到数据库层面，数据增删改的正确性

4）考虑安全性：一般接口对请求会做出一些限制,比如请求次数、请求频率限制；涉及敏感信息是否加密



### 对测试开发的理解以及他们日常会做什么工作

测试开发（Test Development 或 Test Automation Development）是软件测试的一个子领域，专注于通过编程来自动化测试过程。测试开发不仅涉及编写自动化测试脚本，还包括设计和维护自动化测试框架、与开发团队紧密合作以提高软件质量，以及参与持续集成（CI）和持续交付（CD）流程。下面详细地介绍一下测试开发的一些核心职责和他们日常可能会做的工作。

**核心职责**

1. **自动化测试脚本编写**：使用编程语言（如 Python、Java 等）和自动化测试工具（如 Selenium、Appium、Junit 等）来编写测试脚本。
2. **测试框架设计与维护**：设计和建立自动化测试框架，以便更容易、更快捷地编写和运行测试脚本。
3. **测试用例设计**：与需求分析师、产品经理和开发人员合作，理解新功能或改动，然后设计相应的测试用例。
4. **持续集成与持续交付（CI/CD）**：将自动化测试脚本融入CI/CD管道，确保每次代码更改都能自动触发相关测试。
5. **代码审查与质量保证**：参与代码审查，以确保测试代码质量；同时也关注产品代码，帮助开发人员提高代码质量。
6. **性能测试**：使用工具如 JMeter 进行性能、压力和负载测试。
7. **文档编写与维护**：编写测试报告和文档，以记录测试计划、测试用例和测试结果。

**日常工作流程**

1. **需求分析**：在一个迭代或开发周期开始时，与团队成员一起了解即将开发或修改的功能。
2. **测试计划与用例设计**：根据需求分析结果，制定测试计划并设计测试用例。
3. **环境准备**：设置和维护测试环境，包括数据准备、服务器配置等。
4. **编写与调试测试代码**：按照测试用例编写自动化测试脚本，并进行调试。
5. **执行测试**：运行测试脚本，手动或自动地执行测试用例。
6. **结果分析与报告**：分析测试结果，找出问题并编写测试报告。
7. **缺陷跟踪与修复**：与开发人员一起跟踪和修复在测试中发现的缺陷。
8. **代码提交与CI/CD**：将测试代码提交到版本控制系统，并确保它被纳入CI/CD流程。
9. **回归测试与维护**：在软件发布后，进行回归测试以确保新添加或修改的代码没有引入新的问题。



### 为什么选择测试开发

自我追求部分

能力匹配部分



1. 技术层面

**全面的技术观点:** 测试开发不仅涉及到测试，还需**理解软件的开发过程**，这为**深入了解整个系统**提供了机会。

**自动化与编程**: 现代测试开发大量依赖自动化，这也意味着有很多编程工作，对于喜欢编程的人来说是个好选择。

2. 问题解决

侦查与调查: **良好的测试能够发现隐藏的问题**，这需要扎实的问题解决能力。

质量保证: 你的工作直接**影响产品质量**，这是个相当有成就感的工作。

6. 学习与成长

- 不断学习: 软件工具和方法论不断更新，需要持续学习。
- 多元化的挑战: **测试开发会接触到多种类型的项目和问题**，这有助于个人成长



### 测试开发职业发展

**入门阶段（0-2年）**

1. **技术基础**：熟悉基本的编程语言如Python, Java等，以及软件测试的基础概念。
2. **工具认识**：学习并熟悉自动化测试工具，如Selenium, JUnit, TestNG等。
3. **基础测试**：进行UI测试、API测试，并掌握基本的脚本编写。

**中级阶段（2-5年）**

1. **框架设计**：学习如何设计和实现自动化测试框架。
2. **集成和持续测试**：熟悉CI/CD流程，如何将自动化测试融入其中。
3. **性能测试**：掌握基础的性能测试概念和工具，如JMeter。

**高级阶段（5-10年）**

1. **架构设计**：能独立完成复杂系统的测试架构设计，并持续优化。
2. **团队管理**：有能力带领测试团队，并负责多个项目的测试工作。
3. **战略规划**：参与公司产品的整体质量战略规划。



### 测试用例设计并讲解：微信发送图片

**功能测试**

1. **基础发送测试**
   - **目的**：验证正常情况下能否成功发送图片。
   - **步骤**：选择一个聊天窗口，点击添加图片的图标，选择一张图片，点击发送。
   - **预期结果**：图片应成功发送并在聊天窗口中显示。
2. **多图发送测试**
   - **目的**：验证是否能同时发送多张图片。
   - **步骤**：在同一个聊天窗口中选择多张图片并发送。
   - **预期结果**：所有选定的图片都应成功发送。
3. **格式支持测试**
   - **目的**：验证支持的图片格式（如 JPEG, PNG, GIF 等）。
   - **步骤**：尝试发送不同格式的图片。
   - **预期结果**：支持的格式应能成功发送，不支持的格式应给出警告。

**性能测试**

1. **大文件发送测试**
   - **目的**：验证大文件（接近或达到微信允许的最大限制）是否能成功发送。
   - **步骤**：选择一张大文件大小的图片尝试发送。
   - **预期结果**：如果在微信允许的大小内，应能成功发送；否则，应有相应的错误提示。
2. **高并发测试**
   - **目的**：模拟多用户同时发送图片的场景。
   - **步骤**：使用测试工具模拟多个用户账号同时发送图片。
   - **预期结果**：图片应成功发送，不应有延迟或失败。

**异常测试**

1. **网络不稳定环境下发送图片**
   - **目的**：测试在网络信号差或不稳定的情况下能否成功发送图片。
   - **步骤**：在网络不稳定的环境下尝试发送图片。
   - **预期结果**：应有合适的处理机制，如重试、提示用户网络不稳定等。
2. **无网络环境下发送图片**
   - **目的**：测试在没有网络的情况下应用的表现。
   - **步骤**：关闭所有网络连接，尝试发送图片。
   - **预期结果**：应提示用户当前无网络，不能发送图片。

**安全性测试**

1. 非法文件测试

   - **目的**：验证应用是否能阻止发送包含恶意代码的图片文件。

   - **步骤**：尝试发送一个包含恶意代码的图片文件。

   - **预期结果**：应阻止发送并给出警告。

     

### 进程和线程资源共享的方式

进程通信：**管道，消息队列，共享内存**。管道：通过内核空间共享，数据传输是单向的，通信效率低，不适合频繁交换数据。消息队列：保存在内核中的消息链表，通信过程中存在用户态与内核态之间的数据拷贝开销。共享内存：两个进程都取一块虚拟地址空间，映射到相同的物理内存，无需消息拷贝。信号，socket。

线程通信：**全局变量**：多个线程可以访问同一个全局变量。全局变量是在程序的整个生命周期内存在的，因此多个线程可以共享并修改它。

动态分配的堆内存：多个线程可以访问和操作通过动态内存分配（如malloc或new）在堆上分配的内存块。类似于全局变量，对于共享堆内存的访问也需要进行同步，以避免并发问题。

共享对象：多个线程可以同时访问和操作通过共享对象实现的数据共享。

文件和网络连接：多个线程可以共享对同一文件或网络连接的访问。



### 用户态切换到内核态的 3 种方式

①系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

②异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

③外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。





### OSI七层协议

OSI（Open Systems Interconnection）模型是一个概念框架，用于标准化网络协议的不同功能层。该模型将网络协议分为七个不同的层次，以促进不同协议和设备间的互操作性。下面是各层的概述：

1. **物理层（Physical Layer）**: 这一层主要处理与物理媒体相关的细节，比如电缆、交换机、网卡等。主要任务是数据比特流（bits）的传输。
2. **数据链路层（Data Link Layer）**: 在物理层之上，数据链路层负责创建一个可靠的链路连接，主要负责 MAC（Media Access Control） 地址和帧的封装与解封装。
3. **网络层（Network Layer）**: 这一层负责数据包的路由和传输，即如何从源到目的地。**IP 协议**就工作在这一层。
4. **传输层（Transport Layer）**: 主要负责端到端（End-to-End）的数据传输和流量控制。**TCP 和 UDP 协议**就工作在这一层。
5. **会话层（Session Layer）**: 该层负责在数据传输中设置和维护会话。
6. **表示层（Presentation Layer）**: 主要负责数据格式的转换或加密。例如，将 EBCDIC 编码转换为 ASCII 编码。
7. **应用层（Application Layer）**: 这一层负责处理特定的应用程序细节。常见的应用层协议包括 **HTTP、FTP、SMTP** 等。

**TCP 和 HTTP 分别属于哪一层？**

- **TCP（Transmission Control Protocol）**: 通常被认为是传输层的一部分。它负责提供可靠、顺序的点对点通信。

- **HTTP（HyperText Transfer Protocol）**: 是应用层的一部分。它定义了客户端和服务器之间如何传送超文本数据。

  

### 堆栈与缓存

栈和堆都是放在内存里的，就是RAM，通常所说的内存条，程序运行就是在运行在内存里的。

栈：**栈的大小是静态的**，编译时就知道，比如数组的大小，每个程序允许申请的栈大小是有上限的，数组申请过大，会导致栈溢出

堆：**堆的大小是动态的**，程序运行是动态申请的，不固定，比如new对象的个数和大小！需要自己手动释放，不然会导致内存泄漏！

缓存：分为两种：程序缓存和CPU缓存

程序缓存：就是所说的缓冲区！栈和堆都属于程序缓存！让数据保存在内存中，加快程序计算效率的！（说法：栈属于一级缓存、堆属于二级缓存）

CPU缓存：这是硬件层次缓存，处于内存条和CPU之间，以为比如CPU的L1 L2 L3等缓存机制，因为CPU缓存比CPU读内存数据更快！用于存放热点数据，数据如何分级存放有自己的算法。



### Python八股文

#### python的回收机制

Python 使用一种称为引用计数的内存管理机制，以及一个垃圾回收器来清理不再使用的对象。下面我将详细地解释这两个方面。

**引用计数（Reference Counting）**

在 Python 中，每个对象都有一个与之关联的引用计数。当创建一个对象并将其分配给一个变量时，这个对象的引用计数就变为1。如果这个对象被其他变量引用，其引用计数会相应增加。每当一个对象的引用被删除或离开其作用域，引用计数就会减1。当引用计数达到0时，内存就会被释放。

```
pythonCopy code# 创建一个对象（引用计数为 1）
a = [1, 2, 3]

# 引用同一对象（引用计数增加到 2）
b = a

# 解除一个引用（引用计数减少到 1）
del a

# 解除另一个引用（引用计数减少到 0，对象被删除）
del b
```

**垃圾回收（Garbage Collection）**

引用计数有一些局限性，尤其是不能处理引用循环。垃圾回收机制可以检测到这样的循环，并将其打破。

```
pythonCopy code# 创建引用循环
a = {}
b = {}
a['b'] = b
b['a'] = a

# 此时即使 del a 和 del b，a 和 b 仍然存在引用循环，不会被销毁
```

Python 的垃圾回收机制主要基于“代”（Generations）的概念。所有新创建的对象开始时都位于第一代（youngest generation）。如果第一代的对象经过一次垃圾回收仍然存在，则被移动到第二代。同理，第二代对象经过垃圾回收后仍然存在的话，则被移动到第三代。

Python 默认开启垃圾回收机制，但你也可以手动控制它：

- `gc.collect()`：手动运行垃圾回收。
- `gc.set_threshold()`：设置垃圾回收触发的阈值。
- `gc.get_stats()`：获取垃圾回收统计信息。

**综合**

Python 的内存管理机制综合了引用计数和垃圾回收，以达到高效和准确的内存回收。这使得在大多数情况下，开发者可以不必担心内存泄漏，而可以集中精力去解决更有意义的问题。

希望这个详细的解释能帮助你更好地理解 Python 的内存回收机制。



#### **解释型和编译型语言的区别**

- 编译型语言：把做好的源程序全部编译成**二进制**的可运行程序。然后，可直接运行这个程序。如：C，C++ ；
- 解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！如：Python。

####  **简述下 Python 中的字符串、列表、元组和字典**

字符串（**str**）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。
列表（**list**）：列表是有序的集合，可以向其中添加或删除元素。
元组（**tuple**）：元组也是有序集合，元组中的数无法修改。即元组是不可变的。
字典（**dict**）：字典是无序的集合，是由键值对（key-value）组成的。
集合（**set**）：是一组 key 的集合，每个元素都是唯一，不重复且无序的。



#### **字符串常见操作**

1. 切片：`'luobodazahui'[1:3]``

2. ``join`：可以用来连接字符串，将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。`'-'.join(['luo', 'bo', 'da', 'za', 'hui'])`

3. `String.replace(old,new,count)`：将字符串中的 `old`字符替换为 `New`字符，`count`为替换的个数 `'luobodazahui-haha'.replace('haha', 'good')`

4. split：切割字符串，得到一个列表

   ```
   >>> mystr5 = 'luobo,dazahui good'
   
   >>> print(mystr5.split())  # 默认以空格分割
   ['luobo,dazahui', 'good']
   
   >>> print(mystr5.split('h'))  # 以h分割
   ['luobo,daza', 'ui good']
   
   >>> print(mystr5.split(','))  # 以逗号分割
   ['luobo', 'dazahui good']
   ```

   

**列表常见操作**

1. 切片，同字符串

2. `append`和 `extend`向列表中添加元素

   ```
   >>> mylist1 = [1, 2]
   >>> mylist2 = [3, 4]
   >>> mylist3 = [1, 2]
   
   >>> mylist1.append(mylist2)
   >>> print(mylist1)
   [1, 2, [3, 4]]
   
   >>> mylist3.extend(mylist2)
   >>> print(mylist3)
   [1, 2, 3, 4]
   ```

   

3. 删除元素

    `del`:根据下标进行删除

   `pop`：删除最后一个元素

   `remove`：根据元素的值进行删除

   ```
   >>> mylist4 = ['a', 'b', 'c', 'd']
   
   >>> del mylist4[0]
   >>> print(mylist4)
   ['b', 'c', 'd']
   
   >>> mylist4.pop()
   >>> print(mylist4)
   ['b', 'c']
   
   >>> mylist4.remove('c')
   >>> print(mylist4)
   ['b']
   ```

   

1. 元素排序 `sort`：是将`list`按特定顺序重新排列，默认为由小到大，参数 `reverse=True`可改为倒序，由大到小。

```
>>> mylist5 = [1, 5, 2, 3, 4]
>>> mylist5.sort()
>>> print(mylist5)
[1, 2, 3, 4, 5]
>>> mylist5.reverse()
>>> print(mylist5)
[5, 4, 3, 2, 1]
```

1. `reverse`：是将`list`逆置。

   

**字典常见操作**

1. 清空字典 `dict.clear()`

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> dict1.clear()
   >>> dict1
   {}
   ```

2. 指定删除：使用 `pop`方法来指定删除字典中的**某一项**（随机的）。

   ```
   >>> dict1 = {'key1':1, 'key2':2}
   >>> d1 = dict1.pop('key1')
   >>> dict1
   {'key2': 2}
   >>> d1
   1
   ```

3. 遍历字典

   ```
   >>> dict2 = {'key1':1, 'key2':2}
   >>> mykey = [key for key in dict2]  # ['key1', 'key2']
   >>> mykey
   ['key1', 'key2']
   >>> myvalue = [value for value in dict2.values()]
   >>> myvalue
   [1, 2]
   >>> key_value = [(k, v) for k, v in dict2.items()]
   >>> key_value
   [('key1', 1), ('key2', 2)]
   ```

4. `fromkeys`用于创建一个新字典，以序列中元素做字典的键，`value`为字典所有键对应的初始值。

```
>>> keys = ['zhangfei', 'guanyu', 'liubei', 'zhaoyun']
>>> dict.fromkeys(keys, 0)
{'zhangfei': 0, 'guanyu': 0, 'liubei': 0, 'zhaoyun': 0}
```



**一行代码实现数值交换**

```
>>> a, b = 1, 2
>>> a, b = b, a
>>> print(a, b)
```



**is 和 == 的区别**

`==`是比较操作符，只是判断对象的**值**（value）是否一致，而 `is` 则判断的是对象之间的身份（**内存地址**）是否一致。对象的身份，可以通过 `id()` 方法来查看。

```
>>> c = d = [1, 2]
>>> e = [1, 2]

>>> print(c is d)
True

>>> print(c == d)
True

>>> print(c is e)
False

>>> print(c == e)
True
```

只有 `id`一致时，`is`比较才会返回 `True`，而当 `value`一致时，`==` 比较就会返回 `True`。



`*arg` 和 `**kwarg` 作用

允许我们在调用函数的时候传入多个实参

```
>>> def test(*arg, **kwarg):
...     if arg:
...         print("arg:", arg)
...     if kwarg:
...         print("kearg:", kwarg)
...
>>> test('ni', 'hao', key='world')
arg: ('ni', 'hao')
kearg: {'key': 'world'}
```



**[lambda x:i*x for i in range(4)]**

```
>>> def num():
...     return [lambda x:i*x for i in range(4)]
...
>>> [m(1) for m in num()]
[3, 3, 3, 3]
```

https://blog.csdn.net/qq_37085158/article/details/126821933



#### python浅拷贝（Shallow Copy）

1. 使用切片操作（只适用于列表和其他序列类型）。

   ```
   original_list = [1, [2, 3], 4]
   copied_list = original_list[:]
   ```

2. 使用 `copy` 模块的 `copy()` 函数。

   ```
   import copy
   copied_object = copy.copy(original_object)
   ```

3. 对于字典，可以使用 `dict.copy()` 方法。

   ```
   original_dict = {'a': 1, 'b': [2, 3]}
   copied_dict = original_dict.copy()
   ```

4. 对于集合，可以使用 `set.copy()` 方法。

   ```
   original_set = {1, 2, 3}
   copied_set = original_set.copy()
   ```



#### python深拷贝（Deep Copy）

深拷贝会复制对象以及其包含的所有嵌套对象。这意味着，生成的新对象是原始对象的完全独立副本。

1. 使用 模块的  函数。

   ```
   deepcopy()
   ```

   ```
   import copy
   deep_copied_object = copy.deepcopy(original_object)
   ```

#### 深拷贝示例

```
import copy

original_list = [1, [2, 3], 4]
deep_copied_list = copy.deepcopy(original_list)

# 修改原始列表
original_list[0] = 0
original_list[1][0] = 0

# 输出两个列表
print("Original:", original_list)  # Output: [0, [0, 3], 4]
print("Deep Copied:", deep_copied_list)  # Output: [1, [2, 3], 4]
```



### JAVA八股文

#### **Java的回收机制（Garbage Collection）**

Java 使用垃圾回收机制自动管理内存，主要目标是识别并回收不再使用的对象。Java中的垃圾收集器通常是后台运行的，它自动地查找不再被引用的对象并释放其占用的内存。

**引用计数（Reference Counting）**



#### **java多态**

多态（Polymorphism）是面向对象编程中的一个重要概念，**它允许你使用一个接口来表示多种数据类型**。在 Java 中，多态主要通过**接口、继承和方法重载来实现**。下面我会详细解释这个概念。

**主要类型：**

1. **编译时多态（静态多态）**：主要是通过方法重载实现的。
2. **运行时多态（动态多态）**：主要是通过继承和接口实现的。

**编译时多态**

方法重载是一种编译时多态。同一个类中可以有多个同名但参数列表不同的方法。

```
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```

**运行时多态**

1. **继承**：子类继承父类，子类对象可以赋值给父类引用。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal makes a sound");
       }
   }
   
   class Dog extends Animal {
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   
   Animal myAnimal = new Dog();  // Dog 对象存储在 Animal 类型的变量中
   myAnimal.makeSound();  // 输出 "Dog barks"
   ```

2. **接口**：一个类可以实现多个接口，接口的实例可以指向实现该接口的任何类的对象。

   ```
   interface Drawable {
       void draw();
   }
   
   class Circle implements Drawable {
       public void draw() {
           System.out.println("Drawing a circle");
       }
   }
   
   Drawable d = new Circle();
   d.draw();
   ```

**优点：**

1. **代码可重用**：你可以编写能以多种方式工作的代码。
2. **可扩展性**：你可以添加新的类型，而不必修改现有的代码。
3. **维护性**：代码结构更清晰，更易于管理和维护。

**注意事项：**

1. 运行时多态在 Java 中是通过虚拟方法表（Virtual Method Table）来实现的，这会带来一定的性能开销。
2. 需要正确地使用方法覆盖（Override）和重载（Overload）。

多态是面向对象编程的四大基本特性之一（封装、继承、多态和抽象）。正确地使用多态可以使代码更灵活、可扩展和易于维护。



#### Java继承

在 Java 中，继承是一种允许我们重用代码和建立类之间关系的机制。通过继承，一个类（称为子类或派生类）可以获得另一个类（称为父类或基类）的字段（变量）和方法。下面详细介绍 Java 中继承的各个方面。

**基础语法**

要创建一个子类，您可以使用 `extends` 关键字：

```
public class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

public class Dog extends Animal {
    // Dog 类继承了 Animal 类
}
```

在这个例子中，`Dog` 类继承了 `Animal` 类，因此 `Dog` 类具有 `Animal` 类的所有非私有属性和方法。您可以创建一个 `Dog` 对象并调用 `makeSound` 方法，即使 `Dog` 类自己并没有定义这个方法：

```
Dog myDog = new Dog();
myDog.makeSound();  // 输出 "Some generic animal sound"
```



**方法覆盖（Method Overriding）**

子类可以提供父类已有方法的特定实现。这被称为方法覆盖。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof woof");
    }
}
```

现在，如果您创建一个 `Dog` 对象并调用 `makeSound` 方法，将输出 "Woof woof"，而不是 "Some generic animal sound"。



**调用父类的方法和构造函数**

子类可以使用 `super` 关键字来调用父类的方法和构造函数。

```
public class Dog extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();
        System.out.println("Woof woof");
    }
}
```



**访问修饰符和继承**

- `private` 成员不会被继承。
- `public` 和 `protected` 成员会被继承，并且在子类中是可访问的。
- 默认（package-private）成员会被继承，但只在同一个包中的子类中是可访问的。



**final 关键字**

如果一个类用 `final` 关键字标记，那么它不能被继承。

```
public final class ImmutableClass {
    // 代码
}
```

同样地，`final` 方法不能在子类中被覆盖。



**Object 类**

在 Java 中，所有类都是 `Object` 类的子类（直接或间接）。这意味着每个 Java 对象都有 `Object` 类的方法，如 `toString()`, `equals()`, `hashCode()` 等。



**抽象类和接口**

- **抽象类**: 定义了一些方法但没有完全实现的类。这些类通常包含抽象方法（没有实现的方法），子类必须提供实现。
- **接口**: 是一种完全抽象的类，它只定义（而不实现）方法。Java 支持多接口继承。



#### Java多线程的实现

在Java中，多线程主要可以通过以下几种方式实现：

**1. 继承 `Thread` 类**

你可以创建一个新类，继承自 `Thread` 类，并重写 `run()` 方法。然后通过创建该类的实例并调用其 `start()` 方法来创建并启动新线程。

```
class MyThread extends Thread {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

**2. 实现 `Runnable` 接口**

你也可以通过实现 `Runnable` 接口来创建多线程。这种方法更为灵活，因为Java不支持多重继承，所以实现接口是一种更好的选择。

```
class MyRunnable implements Runnable {
    public void run() {
        // 代码逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
```

**3. 使用 `Executor` 框架**

Java的 `java.util.concurrent` 包提供了更高级的多线程支持，包括线程池。

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        executorService.execute(new MyRunnable());
        
        executorService.shutdown();
    }
}
```

**4. 使用 `Callable` 和 `Future`**

如果你需要获取线程执行完毕后的结果，可以使用 `Callable` 接口和 `Future` 类。

```
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Main {
    public static void main(String[] args) throws Exception {
        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "Hello, world!";
            }
        });

        new Thread(futureTask).start();
        
        String result = futureTask.get();
        System.out.println(result);
    }
}
```

注意事项：

1. **线程安全**：当多个线程共享资源时，需要注意线程安全问题。可以使用`synchronized`关键字或其他并发工具类进行同步。
2. **死锁**：避免多个线程相互等待资源，导致程序卡住。
3. **线程间通信**：`wait()`, `notify()`, `notifyAll()` 等方法可用于线程间的基本通信。

多线程编程通常涉及更多复杂的概念，例如线程局部存储、线程优先级、守护线程等。但上述几种方法是最基本和最常用的多线程实现方式。



#### 覆盖（Override）和重载（Overload）

`覆盖（Override）` 和 `重载（Overload）` 是 Java 中两个非常重要的概念，它们在形式和目的上有明显的不同。下面详细解释它们之间的主要区别。

**覆盖（Override）**

1. **定义**: 子类提供了一个与父类方法签名（方法名和参数类型）完全相同的方法。

2. **目的**: 为了改变继承自父类的同名方法的行为。

3. **修饰符**: 必须与父类方法的修饰符相同或更为宽松。例如，如果父类方法是 `protected`，则子类覆盖的方法可以是 `protected` 或 `public`。

4. **返回类型**: 必须与父类方法的返回类型相同或是其子类型。

5. **抛出异常**: 子类覆盖的方法所抛出的异常应该是被父类抛出异常的子集。

6. **运行时行为**: Java 使用运行时多态性来选择要执行的方法版本，即它执行的是对象实际类的方法版本。

   ```
   class Animal {
       void makeSound() {
           System.out.println("Animal sound");
       }
   }
   
   class Dog extends Animal {
       @Override  // 这个注解是可选的，但有助于编译器检查
       void makeSound() {
           System.out.println("Dog barks");
       }
   }
   ```



**重载（Overload）**

1. **定义**: 在同一个类中定义一个与已有方法名相同但参数列表不同的方法。

2. **目的**: 让同一个方法可以有不同类型或数量的参数。

3. **修饰符**: 可以与已有的重载方法有不同的访问修饰符。

4. **返回类型**: 可以与已有的重载方法有不同的返回类型。

5. **抛出异常**: 可以与已有的重载方法有不同的异常抛出列表。

6. **编译时行为**: Java 使用编译时多态性来解析应该调用哪个方法。

   ```
   public class Calculator {
       public int add(int a, int b) {
           return a + b;
       }
   
       public double add(double a, double b) {
           return a + b;
       }
   }
   ```



**主要区别总结**

|                 | 覆盖（Override）           | 重载（Overload）         |
| --------------- | -------------------------- | ------------------------ |
| 方法签名        | 必须与父类相同             | 必须与同类中其他方法不同 |
| 返回类型        | 与父类相同或是其子类型     | 可以不同                 |
| 修饰符          | 不能比父类更严格           | 可以不同                 |
| 所在类          | 子类                       | 同一个类                 |
| 抛出的异常      | 只能是父类异常的子集或相同 | 可以不同                 |
| 运行/编译时行为 | 运行时多态                 | 编译时多态               |

这两个概念在 Java 中是非常基础和重要的，正确理解和使用它们可以使代码更为灵活和可维护。



#### 守护线程和非守护线程

守护线程（Daemon Thread）和非守护线程（Non-daemon Thread）是编程中多线程概念的一部分，特别是在Java和Python这样的编程语言中比较常见。这两种线程的主要区别在于程序是否等待它们执行完成。

**守护线程（Daemon Thread）**

1. **生命周期**：守护线程是一种在后台运行的线程，主要用于执行那些不应阻止程序退出的任务。
2. **程序退出**：一旦程序中所有的非守护线程都结束了，守护线程将被自动终止，即使它们没有完成执行。
3. **用例**：常见的例子包括垃圾回收、日志服务等。

**非守护线程（Non-daemon Thread）**

1. **生命周期**：非守护线程是程序的主要工作线程，用于执行核心任务。
2. **程序退出**：程序会等待所有的非守护线程执行完毕才会退出。
3. **用例**：主程序逻辑、用户交互等。



### 动态分配与静态分配

#### 动态分配

动态分配（Dynamic Allocation）是一种在程序运行时（而非编译时）分配内存空间的方法。这与静态分配相对，静态分配是在程序编译时就确定了内存的大小。动态分配的主要优点是它允许程序更灵活地使用内存，适应不同的数据规模和运行环境。

**为什么需要动态分配？**

在很多情况下，你可能无法预先知道需要多少内存。例如：

1. 当你从文件或网络中读取数据时，数据的大小可能是不确定的。
2. 当你实现数据结构（如链表、树、图等）时，元素的数量可能会动态变化。

在这些情况下，动态分配允许你根据需要分配或释放内存，使得内存使用更为高效。

**如何进行动态分配？**

不同的编程语言提供了不同的机制来进行动态内存分配。

1. C/C++

   : 使用 

   ```
   malloc()
   ```

   , 

   ```
   calloc()
   ```

   , 

   ```
   realloc()
   ```

    和 

   ```
   free()
   ```

    等函数进行内存的动态分配和释放。

   ```
   cCopy codeint *arr = (int*) malloc(10 * sizeof(int)); // 分配一个大小为 10 的整数数组
   free(arr); // 释放内存
   ```

2. Java

   : 使用 

   ```
   new
   ```

    关键字进行对象的动态分配。

   ```
   javaCopy code
   int[] arr = new int[10]; // 分配一个大小为 10 的整数数组
   ```

3. Python

   : 动态分配是自动进行的，你只需创建新的对象即可。

   ```
   pythonCopy code
   arr = [None] * 10  # 分配一个大小为 10 的列表
   ```

4. JavaScript

   : 同样自动进行，通常通过字面量或构造函数来创建对象。

   ```
   javascriptCopy code
   const arr = new Array(10);  // 分配一个大小为 10 的数组
   ```

**内存管理和泄漏**

动态分配的内存必须谨慎管理。在一些低级语言（如 C/C++）中，你需要手动释放不再使用的内存，否则会导致内存泄漏。而在一些高级语言（如 Java、Python）中，垃圾回收机制会自动释放不再使用的内存。

#### 静态分配

静态分配是在编译时分配内存的一种方式。这意味着当程序被编译时，内存的大小和位置就已经确定了，无法在程序运行时改变。下面是几个静态分配的例子：

**C/C++ 中的静态数组**

```
cCopy code
int arr[10]; // 分配一个大小为 10 的整数数组，其大小在编译时确定。
```

**Java 中的基础数据类型**

```
javaCopy code
int a; // 在栈上分配一个整数变量，大小和位置在编译时确定。
```

**Python 中的不可变数据类型**

虽然 Python 主要依赖动态分配，但不可变数据类型（如元组和字符串）一旦创建就不能更改，因此可以看作是静态分配的一种。

```
pythonCopy code
t = (1, 2, 3)  # 元组一旦创建，其大小和内容就不能更改。
```

**全局和静态变量**

全局变量和静态变量（在 C/C++ 中使用 `static` 关键字定义）也是静态分配的例子。它们在程序的生命周期内一直存在，不会被动态地创建或销毁。

```
cCopy code
static int x;  // 静态变量，其生命周期在整个程序执行期间。
```

**常量**

常量是在编译时就确定其值的变量，因此它们也是静态分配的。

```
javaCopy code
final int MAX_VALUE = 100;  // 常量，其值在编译时就确定。
```

**结构体和类的静态成员（C++）**

在 C++ 中，类或结构体的静态成员变量也是静态分配的。

```
c++Copy codeclass MyClass {
public:
    static int staticVar;  // 静态成员变量，其生命周期在整个程序执行期间。
};
```